<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai: Threads management services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Threads management services.</h1>  </div>
</div>
<div class="contents">

<p>Threads management services.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Threads management services.:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__cobalt__thread.png" border="0" alt="" usemap="#group____cobalt____thread"/>
<map name="group____cobalt____thread" id="group____cobalt____thread">
<area shape="rect" id="node1" href="group__cobalt__cancel.html" title="Thread cancellation." alt="" coords="279,5,428,35"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__cancel.html">Thread cancellation.</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Thread cancellation. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#gaf6b47d0db16e8f4fae377582a38cc417">pthread_getschedparam</a> (pthread_t tid, int *pol, struct sched_param *par)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the scheduling policy and parameters of the specified thread.  <a href="#gaf6b47d0db16e8f4fae377582a38cc417"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#ga61f6452e41e45f6a57c9cc5277d2a9c9">pthread_getschedparam_ex</a> (pthread_t tid, int *pol, struct sched_param_ex *par)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the extended scheduling policy and parameters of the specified thread.  <a href="#ga61f6452e41e45f6a57c9cc5277d2a9c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#ga3832074a8217566e79b476a964c7eb25">pthread_create</a> (pthread_t *tid, const pthread_attr_t *attr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a thread.  <a href="#ga3832074a8217566e79b476a964c7eb25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#ga28163bf08c41512d1e0a5079fb14081c">pthread_make_periodic_np</a> (pthread_t thread, clockid_t clock_id, struct timespec *starttp, struct timespec *periodtp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a thread periodic.  <a href="#ga28163bf08c41512d1e0a5079fb14081c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#ga023e824df57ad2d88d42bb6e4c6711f3">pthread_set_mode_np</a> (int clrmask, int setmask, int *mode_r)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the mode of the current thread.  <a href="#ga023e824df57ad2d88d42bb6e4c6711f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#ga9fb2ff7a7b9eb54c82b84ca569faa081">pthread_set_name_np</a> (pthread_t thread, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a thread name.  <a href="#ga9fb2ff7a7b9eb54c82b84ca569faa081"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#ga4b9fb2bbdfba8fbc876ae33493e6bcc8">pthread_setschedparam</a> (pthread_t tid, int pol, const struct sched_param *par)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scheduling policy and parameters of the specified thread.  <a href="#ga4b9fb2bbdfba8fbc876ae33493e6bcc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#gaeff2a24c4ed33b06b9d158259bcfa328">pthread_setschedparam_ex</a> (pthread_t tid, int pol, const struct sched_param_ex *par)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the extended scheduling policy and parameters of the specified thread.  <a href="#gaeff2a24c4ed33b06b9d158259bcfa328"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Threads management services. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_09.html#tag_02_09">Specification.</a> </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga3832074a8217566e79b476a964c7eb25"></a><!-- doxytag: member="thread.c::pthread_create" ref="ga3832074a8217566e79b476a964c7eb25" args="(pthread_t *tid, const pthread_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int pthread_create </td>
          <td>(</td>
          <td class="paramtype">pthread_t *&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pthread_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a thread. </p>
<p>This service creates a Cobalt thread control block. The created thread may use Cobalt API services.</p>
<p>The new thread control block can be mapped over a regular Linux thread, forming a Xenomai shadow.</p>
<p>The new thread signal mask is inherited from the current thread, if it was also created with <a class="el" href="group__cobalt__thread.html#ga3832074a8217566e79b476a964c7eb25" title="Create a thread.">pthread_create()</a>, otherwise the new thread signal mask is empty.</p>
<p>Other attributes of the new thread depend on the <em>attr</em> argument. If <em>attr</em> is null, default values for these attributes are used.</p>
<p>Returning from the <em>start</em> routine has the same effect as calling pthread_exit() with the return value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>address where the identifier of the new thread will be stored on success;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>thread attributes;</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>EINVAL, <em>attr</em> is invalid;</li>
<li>EAGAIN, insufficient memory exists in the system heap to create a new thread, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li>
<li>EINVAL, thread attribute <em>inheritsched</em> is set to PTHREAD_INHERIT_SCHED and the calling thread does not belong to the POSIX skin;</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_create.html">Specification.</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>When creating or shadowing a Xenomai thread for the first time in user-space, Xenomai installs a handler for the SIGWINCH signal. If you had installed a handler before that, it will be automatically called by Xenomai for SIGWINCH signals that it has not sent.</p>
<p>If, however, you install a signal handler for SIGWINCH after creating or shadowing the first Xenomai thread, you have to explicitly call the function xeno_sigwinch_handler at the beginning of your signal handler, using its return to know if the signal was in fact an internal signal of Xenomai (in which case it returns 1), or if you should handle the signal (in which case it returns 0). xeno_sigwinch_handler prototype is:</p>
<p><b>int xeno_sigwinch_handler(int sig, siginfo_t *si, void *ctxt);</b></p>
<p>Which means that you should register your handler with sigaction, using the SA_SIGINFO flag, and pass all the arguments you received to xeno_sigwinch_handler. </p>

<p>References <a class="el" href="group__cobalt__thread.html#ga61f6452e41e45f6a57c9cc5277d2a9c9">pthread_getschedparam_ex()</a>, <a class="el" href="group__pod.html#gad71ebccc5b7b3d367f65127a8849c036">xnpod_init_thread()</a>, <a class="el" href="group__pod.html#ga4b8647e7a6969962c788669ff8d46d3b">xnpod_set_thread_tslice()</a>, and <a class="el" href="group__synch.html#ga4c07b8ec87b14cf18ef512f0e0aade51">xnsynch_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf6b47d0db16e8f4fae377582a38cc417"></a><!-- doxytag: member="thread.c::pthread_getschedparam" ref="gaf6b47d0db16e8f4fae377582a38cc417" args="(pthread_t tid, int *pol, struct sched_param *par)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int pthread_getschedparam </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sched_param *&nbsp;</td>
          <td class="paramname"> <em>par</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the scheduling policy and parameters of the specified thread. </p>
<p>This service returns, at the addresses <em>pol</em> and <em>par</em>, the current scheduling policy and scheduling parameters (i.e. priority) of the Xenomai POSIX skin thread <em>tid</em>. If this service is called from user-space and <em>tid</em> is not the identifier of a Xenomai POSIX skin thread, this service fallback to Linux regular pthread_getschedparam service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>target thread;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pol</em>&nbsp;</td><td>address where the scheduling policy of <em>tid</em> is stored on success;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>par</em>&nbsp;</td><td>address where the scheduling parameters of <em>tid</em> is stored on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>tid</em> is invalid.</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_getschedparam.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga61f6452e41e45f6a57c9cc5277d2a9c9"></a><!-- doxytag: member="thread.c::pthread_getschedparam_ex" ref="ga61f6452e41e45f6a57c9cc5277d2a9c9" args="(pthread_t tid, int *pol, struct sched_param_ex *par)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int pthread_getschedparam_ex </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sched_param_ex *&nbsp;</td>
          <td class="paramname"> <em>par</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the extended scheduling policy and parameters of the specified thread. </p>
<p>This service is an extended version of <a class="el" href="group__cobalt__thread.html#gaf6b47d0db16e8f4fae377582a38cc417" title="Get the scheduling policy and parameters of the specified thread.">pthread_getschedparam()</a>, that also supports Xenomai-specific or additional POSIX scheduling policies, which are not available with the host Linux environment.</p>
<p>Typically, SCHED_SPORADIC parameters can be retrieved from this call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>target thread;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pol</em>&nbsp;</td><td>address where the scheduling policy of <em>tid</em> is stored on success;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>par</em>&nbsp;</td><td>address where the scheduling parameters of <em>tid</em> is stored on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>tid</em> is invalid.</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_getschedparam.html">Specification.</a> </dd></dl>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga6f451131910f816dd01fe1ec1fb50fe9">XNRRB</a>.</p>

<p>Referenced by <a class="el" href="group__cobalt__thread.html#ga3832074a8217566e79b476a964c7eb25">pthread_create()</a>.</p>

</div>
</div>
<a class="anchor" id="ga28163bf08c41512d1e0a5079fb14081c"></a><!-- doxytag: member="thread.c::pthread_make_periodic_np" ref="ga28163bf08c41512d1e0a5079fb14081c" args="(pthread_t thread, clockid_t clock_id, struct timespec *starttp, struct timespec *periodtp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int pthread_make_periodic_np </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clockid_t&nbsp;</td>
          <td class="paramname"> <em>clock_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&nbsp;</td>
          <td class="paramname"> <em>starttp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&nbsp;</td>
          <td class="paramname"> <em>periodtp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a thread periodic. </p>
<p>This service make the POSIX skin thread <em>thread</em> periodic.</p>
<p>This service is a non-portable extension of the POSIX interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>thread identifier. This thread is immediately delayed until the first periodic release point is reached.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clock_id</em>&nbsp;</td><td>clock identifier, either CLOCK_REALTIME, CLOCK_MONOTONIC or CLOCK_MONOTONIC_RAW.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>starttp</em>&nbsp;</td><td>start time, expressed as an absolute value of the clock <em>clock_id</em>. The affected thread will be delayed until this point is reached.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>periodtp</em>&nbsp;</td><td>period, expressed as a time interval.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li>
<li>ETIMEDOUT, the start time has already passed.</li>
<li>ENOTSUP, the specified clock is unsupported;</li>
</ul>
</dd></dl>
<p>Rescheduling: always, until the <em>starttp</em> start time has been reached. </p>

<p>References <a class="el" href="group__pod.html#ga1d9aa43e61e6e0b28675412e4cfcc6b0">xnpod_set_thread_periodic()</a>.</p>

</div>
</div>
<a class="anchor" id="ga023e824df57ad2d88d42bb6e4c6711f3"></a><!-- doxytag: member="thread.c::pthread_set_mode_np" ref="ga023e824df57ad2d88d42bb6e4c6711f3" args="(int clrmask, int setmask, int *mode_r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int pthread_set_mode_np </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>setmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>mode_r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the mode of the current thread. </p>
<p>This service sets the mode of the calling thread. <em>clrmask</em> and <em>setmask</em> are two bit masks which are respectively cleared and set in the calling thread status. They are a bitwise OR of the following values:</p>
<ul>
<li>PTHREAD_LOCK_SCHED, when set, locks the scheduler, which prevents the current thread from being switched out until the scheduler is unlocked;</li>
<li>PTHREAD_WARNSW, when set, causes the signal SIGXCPU to be sent to the current thread, whenever it involontary switches to secondary mode;</li>
<li>PTHREAD_CONFORMING can be passed in <em>setmask</em> to switch the current user-space task to its preferred runtime mode. The only meaningful use of this switch is to force a real-time shadow back to primary mode. Any other use either cause to a nop, or an error.</li>
</ul>
<p>PTHREAD_LOCK_SCHED is valid for any Xenomai thread, the other bits are only valid for Xenomai user-space threads.</p>
<p>This service is a non-portable extension of the POSIX interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clrmask</em>&nbsp;</td><td>set of bits to be cleared;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>setmask</em>&nbsp;</td><td>set of bits to be set.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode_r</em>&nbsp;</td><td>If non-NULL, <em>mode_r</em> must be a pointer to a memory location which will be written upon success with the previous set of active mode bits. If NULL, the previous set of active mode bits will not be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>EINVAL, some bit in <em>clrmask</em> or <em>setmask</em> is invalid. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga2defcfb1f04f077baeac9881cbdda627">XNLOCK</a>, <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, <a class="el" href="group__pod.html#ga629c06b152dabfdb679b6e49bd9f7734">xnpod_set_thread_mode()</a>, and <a class="el" href="group__nucleus__state__flags.html#gac664c3bae93da4141d2fc8e88a91afd8">XNSHADOW</a>.</p>

</div>
</div>
<a class="anchor" id="ga9fb2ff7a7b9eb54c82b84ca569faa081"></a><!-- doxytag: member="thread.c::pthread_set_name_np" ref="ga9fb2ff7a7b9eb54c82b84ca569faa081" args="(pthread_t thread, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int pthread_set_name_np </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a thread name. </p>
<p>This service set to <em>name</em>, the name of <em>thread</em>. This name is used for displaying information in /proc/xenomai/sched.</p>
<p>This service is a non-portable extension of the POSIX interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>target thread;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4b9fb2bbdfba8fbc876ae33493e6bcc8"></a><!-- doxytag: member="thread.c::pthread_setschedparam" ref="ga4b9fb2bbdfba8fbc876ae33493e6bcc8" args="(pthread_t tid, int pol, const struct sched_param *par)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int pthread_setschedparam </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sched_param *&nbsp;</td>
          <td class="paramname"> <em>par</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the scheduling policy and parameters of the specified thread. </p>
<p>This service set the scheduling policy of the Xenomai POSIX skin thread <em>tid</em> to the value <em>pol</em>, and its scheduling parameters (i.e. its priority) to the value pointed to by <em>par</em>.</p>
<p>When used in user-space, passing the current thread ID as <em>tid</em> argument, this service turns the current thread into a Xenomai POSIX skin thread. If <em>tid</em> is neither the identifier of the current thread nor the identifier of a Xenomai POSIX skin thread this service falls back to the regular <a class="el" href="group__cobalt__thread.html#ga4b9fb2bbdfba8fbc876ae33493e6bcc8" title="Set the scheduling policy and parameters of the specified thread.">pthread_setschedparam()</a> service, hereby causing the current thread to switch to secondary mode if it is Xenomai thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>target thread;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pol</em>&nbsp;</td><td>scheduling policy, one of SCHED_FIFO, SCHED_COBALT, SCHED_RR or SCHED_OTHER;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>par</em>&nbsp;</td><td>scheduling parameters address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>tid</em> is invalid;</li>
<li>EINVAL, <em>pol</em> or <em>par-&gt;sched_priority</em> is invalid;</li>
<li>EAGAIN, in user-space, insufficient memory exists in the system heap, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li>
<li>EFAULT, in user-space, <em>par</em> is an invalid address;</li>
<li>EPERM, in user-space, the calling process does not have superuser permissions.</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_setschedparam.html">Specification.</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>When creating or shadowing a Xenomai thread for the first time in user-space, Xenomai installs a handler for the SIGWINCH signal. If you had installed a handler before that, it will be automatically called by Xenomai for SIGWINCH signals that it has not sent.</p>
<p>If, however, you install a signal handler for SIGWINCH after creating or shadowing the first Xenomai thread, you have to explicitly call the function xeno_sigwinch_handler at the beginning of your signal handler, using its return to know if the signal was in fact an internal signal of Xenomai (in which case it returns 1), or if you should handle the signal (in which case it returns 0). xeno_sigwinch_handler prototype is:</p>
<p><b>int xeno_sigwinch_handler(int sig, siginfo_t *si, void *ctxt);</b></p>
<p>Which means that you should register your handler with sigaction, using the SA_SIGINFO flag, and pass all the arguments you received to xeno_sigwinch_handler. </p>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, <a class="el" href="group__pod.html#ga6d535ef9821e98fd7f257b50a3c8d595">xnpod_set_thread_schedparam()</a>, and <a class="el" href="group__pod.html#ga4b8647e7a6969962c788669ff8d46d3b">xnpod_set_thread_tslice()</a>.</p>

<p>Referenced by <a class="el" href="group__cobalt__thread.html#gaeff2a24c4ed33b06b9d158259bcfa328">pthread_setschedparam_ex()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeff2a24c4ed33b06b9d158259bcfa328"></a><!-- doxytag: member="thread.c::pthread_setschedparam_ex" ref="gaeff2a24c4ed33b06b9d158259bcfa328" args="(pthread_t tid, int pol, const struct sched_param_ex *par)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int pthread_setschedparam_ex </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sched_param_ex *&nbsp;</td>
          <td class="paramname"> <em>par</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the extended scheduling policy and parameters of the specified thread. </p>
<p>This service is an extended version of <a class="el" href="group__cobalt__thread.html#ga4b9fb2bbdfba8fbc876ae33493e6bcc8" title="Set the scheduling policy and parameters of the specified thread.">pthread_setschedparam()</a>, that supports Xenomai-specific or additional scheduling policies, which are not available with the host Linux environment.</p>
<p>Typically, a Xenomai thread policy can be set to SCHED_SPORADIC using this call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>target thread;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pol</em>&nbsp;</td><td>address where the scheduling policy of <em>tid</em> is stored on success;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>par</em>&nbsp;</td><td>address where the scheduling parameters of <em>tid</em> is stored on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>tid</em> is invalid.</li>
<li>EINVAL, <em>par</em> contains invalid parameters.</li>
<li>ENOMEM, lack of memory to perform the operation.</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_getschedparam.html">Specification.</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__thread.html#ga4b9fb2bbdfba8fbc876ae33493e6bcc8">pthread_setschedparam()</a>, <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, <a class="el" href="group__pod.html#ga6d535ef9821e98fd7f257b50a3c8d595">xnpod_set_thread_schedparam()</a>, and <a class="el" href="group__pod.html#ga4b8647e7a6969962c788669ff8d46d3b">xnpod_set_thread_tslice()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jan 5 2012 10:14:30 for Xenomai by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
