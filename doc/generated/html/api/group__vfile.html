<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Virtual file services</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Virtual file services<br>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Virtual file services:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__vfile.png" border="0" alt="" usemap="#group____vfile_map">
<map name="group____vfile_map">
<area shape="rect" href="group__nucleus.html" title="Xenomai nucleus." alt="" coords="5,5,141,32"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Virtual files provide a mean to export Xenomai object states to user-space, based on common kernel interfaces. This encapsulation is aimed at:<p>
<ul>
<li>supporting consistent collection of very large record-based output, without encurring latency peaks for undergoing real-time activities.</li></ul>
<p>
<ul>
<li>in the future, hiding discrepancies between linux kernel releases, regarding the proper way to export kernel object states to userland, either via the /proc interface or by any other mean.</li></ul>
<p>
This virtual file implementation offers record-based read support based on seq_files, single-buffer write support, directory and link handling, all visible from the /proc namespace.<p>
The vfile support exposes four filesystem object types:<p>
<ul>
<li>snapshot-driven file (struct <a class="el" href="structxnvfile__snapshot.html" title="Snapshot vfile descriptor.">xnvfile_snapshot</a>). This is commonly used to export real-time object states via the /proc filesystem. To minimize the latency involved in protecting the vfile routines from changes applied by real-time code on such objects, a snapshot of the data to output is first taken under proper locking, before the collected data is formatted and sent out in a lockless manner.</li></ul>
<p>
Because a large number of records may have to be output, the data collection phase is not strictly atomic as a whole, but only protected at record level. The vfile implementation can be notified of updates to the underlying data set, and restart the collection from scratch until the snapshot is fully consistent.<p>
<ul>
<li>regular sequential file (struct xnvfile_regular). This is basically an encapsulated sequential file object as available from the host kernel (i.e. seq_file), with a few additional features to make it more handy in a Xenomai environment, like implicit locking support and shortened declaration for simplest, single-record output.</li></ul>
<p>
<ul>
<li>virtual link (struct xnvfile_link). This is a symbolic link feature integrated with the vfile semantics. The link target is computed dynamically at creation time from a user-given helper routine.</li></ul>
<p>
<ul>
<li>virtual directory (struct xnvfile_directory). A directory object, which can be used to create a hierarchy for ordering a set of vfile objects. </li></ul>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="vfile_8h.html">vfile.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the Xenomai project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__lock__ops.html">xnvfile_lock_ops</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vfile locking operations.  <a href="structxnvfile__lock__ops.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html">xnvfile_regular_ops</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Regular vfile operation descriptor.  <a href="structxnvfile__regular__ops.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Regular vfile iterator.  <a href="structxnvfile__regular__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html">xnvfile_snapshot_ops</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Snapshot vfile operation descriptor.  <a href="structxnvfile__snapshot__ops.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__rev__tag.html">xnvfile_rev_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Snapshot revision tag.  <a href="structxnvfile__rev__tag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot.html">xnvfile_snapshot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Snapshot vfile descriptor.  <a href="structxnvfile__snapshot.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Snapshot-driven vfile iterator.  <a href="structxnvfile__snapshot__iterator.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfile.html#gad513ffc19d0ab33ff1722899841a442">xnvfile_init_snapshot</a> (const char *name, struct <a class="el" href="structxnvfile__snapshot.html">xnvfile_snapshot</a> *vfile, struct xnvfile_directory *parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a snapshot-driven vfile.  <a href="#gad513ffc19d0ab33ff1722899841a442"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfile.html#g82b37f521d867ab9a94b15570210f83f">xnvfile_init_regular</a> (const char *name, struct xnvfile_regular *vfile, struct xnvfile_directory *parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a regular vfile.  <a href="#g82b37f521d867ab9a94b15570210f83f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfile.html#gdafe22257ce52d6e35698f4f66bb93c7">xnvfile_init_dir</a> (const char *name, struct xnvfile_directory *vdir, struct xnvfile_directory *parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a virtual directory entry.  <a href="#gdafe22257ce52d6e35698f4f66bb93c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfile.html#g3f28290884ca3c4458ac67e2b1845502">xnvfile_init_link</a> (const char *from, const char *to, struct xnvfile_link *vlink, struct xnvfile_directory *parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a virtual link entry.  <a href="#g3f28290884ca3c4458ac67e2b1845502"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfile.html#g5429178db74b9dd23378cb8f0942629e">xnvfile_destroy</a> (struct xnvfile *vfile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a virtual file entry.  <a href="#g5429178db74b9dd23378cb8f0942629e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfile.html#g6a9005ee997d929f7c8940cfcfcab171">xnvfile_get_blob</a> (struct xnvfile_input *input, void *data, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read in a data bulk written to the vfile.  <a href="#g6a9005ee997d929f7c8940cfcfcab171"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfile.html#ge45ea5410707367c9e032dc36fc30916">xnvfile_get_string</a> (struct xnvfile_input *input, char *s, size_t maxlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read in a C-string written to the vfile.  <a href="#ge45ea5410707367c9e032dc36fc30916"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfile.html#g18746b2aae928c0281ae57ef47086600">xnvfile_get_integer</a> (struct xnvfile_input *input, long *valp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate the string written to the vfile as a long integer.  <a href="#g18746b2aae928c0281ae57ef47086600"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct xnvfile_directory&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfile.html#g7f46f9d1249c5d855b5ead672a0d6ee5">nkvfroot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Xenomai vfile root directory.  <a href="#g7f46f9d1249c5d855b5ead672a0d6ee5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct xnvfile_directory&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfile.html#g7f46f9d1249c5d855b5ead672a0d6ee5">nkvfroot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Xenomai vfile root directory.  <a href="#g7f46f9d1249c5d855b5ead672a0d6ee5"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g5429178db74b9dd23378cb8f0942629e"></a><!-- doxytag: member="vfile.h::xnvfile_destroy" ref="g5429178db74b9dd23378cb8f0942629e" args="(struct xnvfile *vfile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnvfile_destroy           </td>
          <td>(</td>
          <td class="paramtype">struct xnvfile *&nbsp;</td>
          <td class="paramname"> <em>vfile</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a virtual file entry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vfile</em>&nbsp;</td><td>A pointer to the virtual file descriptor to remove. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="vfile_8c-source.html#l00088">nkvfroot</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6a9005ee997d929f7c8940cfcfcab171"></a><!-- doxytag: member="vfile.h::xnvfile_get_blob" ref="g6a9005ee997d929f7c8940cfcfcab171" args="(struct xnvfile_input *input, void *data, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t xnvfile_get_blob           </td>
          <td>(</td>
          <td class="paramtype">struct xnvfile_input *&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read in a data bulk written to the vfile. 
<p>
When writing to a vfile, the associated store() handler from the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_store">snapshot-driven vfile</a> or <a class="el" href="structxnvfile__regular__ops.html#regular_store">regular vfile</a> is called, with a single argument describing the input data. <a class="el" href="group__vfile.html#g6a9005ee997d929f7c8940cfcfcab171" title="Read in a data bulk written to the vfile.">xnvfile_get_blob()</a> retrieves this data as an untyped binary blob, and copies it back to the caller's buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>A pointer to the input descriptor passed to the store() handler.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The address of the destination buffer to copy the input data to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The maximum number of bytes to copy to the destination buffer. If <em>size</em> is larger than the actual data size, the input is truncated to <em>size</em>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes read and copied to the destination buffer upon success. Otherwise, a negative error code is returned:</dd></dl>
<ul>
<li>-EFAULT indicates an invalid source buffer address. </li></ul>

<p>Referenced by <a class="el" href="vfile_8c-source.html#l00852">xnvfile_get_integer()</a>, and <a class="el" href="vfile_8c-source.html#l00802">xnvfile_get_string()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g18746b2aae928c0281ae57ef47086600"></a><!-- doxytag: member="vfile.h::xnvfile_get_integer" ref="g18746b2aae928c0281ae57ef47086600" args="(struct xnvfile_input *input, long *valp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t xnvfile_get_integer           </td>
          <td>(</td>
          <td class="paramtype">struct xnvfile_input *&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>valp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluate the string written to the vfile as a long integer. 
<p>
When writing to a vfile, the associated store() handler from the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_store">snapshot-driven vfile</a> or <a class="el" href="structxnvfile__regular__ops.html#regular_store">regular vfile</a> is called, with a single argument describing the input data. <a class="el" href="group__vfile.html#g18746b2aae928c0281ae57ef47086600" title="Evaluate the string written to the vfile as a long integer.">xnvfile_get_integer()</a> retrieves and interprets this data as a long integer, and copies the resulting value back to <em>valp</em>.<p>
The long integer can be expressed in decimal, octal or hexadecimal bases depending on the prefix found.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>A pointer to the input descriptor passed to the store() handler.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valp</em>&nbsp;</td><td>The address of a long integer variable to receive the value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of characters read while evaluating the input as a long integer upon success. Otherwise, a negative error code is returned:</dd></dl>
<ul>
<li>-EINVAL indicates a parse error on the input stream; the written text cannot be evaluated as a long integer.</li></ul>
<p>
<ul>
<li>-EFAULT indicates an invalid source buffer address. </li></ul>

<p>References <a class="el" href="vfile_8c-source.html#l00759">xnvfile_get_blob()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge45ea5410707367c9e032dc36fc30916"></a><!-- doxytag: member="vfile.h::xnvfile_get_string" ref="ge45ea5410707367c9e032dc36fc30916" args="(struct xnvfile_input *input, char *s, size_t maxlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t xnvfile_get_string           </td>
          <td>(</td>
          <td class="paramtype">struct xnvfile_input *&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>maxlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read in a C-string written to the vfile. 
<p>
When writing to a vfile, the associated store() handler from the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_store">snapshot-driven vfile</a> or <a class="el" href="structxnvfile__regular__ops.html#regular_store">regular vfile</a> is called, with a single argument describing the input data. <a class="el" href="group__vfile.html#ge45ea5410707367c9e032dc36fc30916" title="Read in a C-string written to the vfile.">xnvfile_get_string()</a> retrieves this data as a null-terminated character string, and copies it back to the caller's buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>A pointer to the input descriptor passed to the store() handler.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The address of the destination string buffer to copy the input data to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxlen</em>&nbsp;</td><td>The maximum number of bytes to copy to the destination buffer, including the ending null character. If <em>maxlen</em> is larger than the actual string length, the input is truncated to <em>maxlen</em>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of characters read and copied to the destination buffer upon success. Otherwise, a negative error code is returned:</dd></dl>
<ul>
<li>-EFAULT indicates an invalid source buffer address. </li></ul>

<p>References <a class="el" href="vfile_8c-source.html#l00759">xnvfile_get_blob()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gdafe22257ce52d6e35698f4f66bb93c7"></a><!-- doxytag: member="vfile.h::xnvfile_init_dir" ref="gdafe22257ce52d6e35698f4f66bb93c7" args="(const char *name, struct xnvfile_directory *vdir, struct xnvfile_directory *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnvfile_init_dir           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_directory *&nbsp;</td>
          <td class="paramname"> <em>vdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_directory *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a virtual directory entry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name which should appear in the pseudo-filesystem, identifying the vdir entry.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vdir</em>&nbsp;</td><td>A pointer to the virtual directory descriptor to initialize.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>A pointer to a virtual directory descriptor standing for the parent directory of the new vdir. If NULL, the /proc root directory will be used. /proc/xenomai is mapped on the globally available <em>nkvfroot</em> vdir.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the virtual directory entry cannot be created in the /proc hierarchy. </li></ul>

</div>
</div><p>
<a class="anchor" name="g3f28290884ca3c4458ac67e2b1845502"></a><!-- doxytag: member="vfile.h::xnvfile_init_link" ref="g3f28290884ca3c4458ac67e2b1845502" args="(const char *from, const char *to, struct xnvfile_link *vlink, struct xnvfile_directory *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnvfile_init_link           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_link *&nbsp;</td>
          <td class="paramname"> <em>vlink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_directory *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a virtual link entry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>The name which should appear in the pseudo-filesystem, identifying the vlink entry.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>The target file name which should be referred to symbolically by <em>name</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vlink</em>&nbsp;</td><td>A pointer to the virtual link descriptor to initialize.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>A pointer to a virtual directory descriptor standing for the parent directory of the new vlink. If NULL, the /proc root directory will be used. /proc/xenomai is mapped on the globally available <em>nkvfroot</em> vdir.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the virtual link entry cannot be created in the /proc hierarchy. </li></ul>

</div>
</div><p>
<a class="anchor" name="g82b37f521d867ab9a94b15570210f83f"></a><!-- doxytag: member="vfile.h::xnvfile_init_regular" ref="g82b37f521d867ab9a94b15570210f83f" args="(const char *name, struct xnvfile_regular *vfile, struct xnvfile_directory *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnvfile_init_regular           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_regular *&nbsp;</td>
          <td class="paramname"> <em>vfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_directory *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a regular vfile. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name which should appear in the pseudo-filesystem, identifying the vfile entry.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vfile</em>&nbsp;</td><td>A pointer to a vfile descriptor to initialize from. The following fields in this structure should be filled in prior to call this routine:</td></tr>
  </table>
</dl>
<ul>
<li>.privsz is the size (in bytes) of the private data area to be reserved in the <a class="el" href="structxnvfile__regular__iterator.html#regular_iterator">vfile iterator</a>. A NULL value indicates that no private area should be reserved.</li></ul>
<p>
<ul>
<li>entry.lockops is a pointer to a <a class="el" href="structxnvfile__lock__ops.html#vfile_lockops">locking</a> descriptor", defining the lock and unlock operations for the vfile. This pointer may be left to NULL, in which case no locking will be applied.</li></ul>
<p>
<ul>
<li>.ops is a pointer to an <a class="el" href="structxnvfile__regular__ops.html#regular_ops">operation descriptor</a>.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>A pointer to a virtual directory descriptor; the vfile entry will be created into this directory. If NULL, the /proc root directory will be used. /proc/xenomai is mapped on the globally available <em>nkvfroot</em> vdir.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the virtual file entry cannot be created in the /proc hierarchy. </li></ul>

</div>
</div><p>
<a class="anchor" name="gad513ffc19d0ab33ff1722899841a442"></a><!-- doxytag: member="vfile.h::xnvfile_init_snapshot" ref="gad513ffc19d0ab33ff1722899841a442" args="(const char *name, struct xnvfile_snapshot *vfile, struct xnvfile_directory *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnvfile_init_snapshot           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxnvfile__snapshot.html">xnvfile_snapshot</a> *&nbsp;</td>
          <td class="paramname"> <em>vfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_directory *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a snapshot-driven vfile. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name which should appear in the pseudo-filesystem, identifying the vfile entry.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vfile</em>&nbsp;</td><td>A pointer to a vfile descriptor to initialize from. The following fields in this structure should be filled in prior to call this routine:</td></tr>
  </table>
</dl>
<ul>
<li>.privsz is the size (in bytes) of the private data area to be reserved in the <a class="el" href="structxnvfile__snapshot__iterator.html#snapshot_iterator">vfile iterator</a>. A NULL value indicates that no private area should be reserved.</li></ul>
<p>
<ul>
<li>.datasz is the size (in bytes) of a single record to be collected by the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next() handler</a> from the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_ops">operation descriptor</a>.</li></ul>
<p>
<ul>
<li>.tag is a pointer to a mandatory vfile revision tag structure (struct <a class="el" href="structxnvfile__rev__tag.html" title="Snapshot revision tag.">xnvfile_rev_tag</a>). This tag will be monitored for changes by the vfile core while collecting data to output, so that any update detected will cause the current snapshot data to be dropped, and the collection to restart from the beginning. To this end, any change to the data which may be part of the collected records, should also invoke xnvfile_touch() on the associated tag.</li></ul>
<p>
<ul>
<li>entry.lockops is a pointer to a <a class="el" href="structxnvfile__lock__ops.html#vfile_lockops">locking</a> descriptor", defining the lock and unlock operations for the vfile. This pointer may be left to NULL, in which case the operations on the nucleus lock (i.e. nklock) will be used internally around calls to data collection handlers (see <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_ops">operation descriptor</a>).</li></ul>
<p>
<ul>
<li>.ops is a pointer to an <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_ops">operation descriptor</a>.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>A pointer to a virtual directory descriptor; the vfile entry will be created into this directory. If NULL, the /proc root directory will be used. /proc/xenomai is mapped on the globally available <em>nkvfroot</em> vdir.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the virtual file entry cannot be created in the /proc hierarchy. </li></ul>

<p>References <a class="el" href="vfile_8h-source.html#l00501">xnvfile_snapshot::entry</a>, <a class="el" href="vfile_8h-source.html#l00505">xnvfile_snapshot::ops</a>, <a class="el" href="structxnvfile__snapshot__ops.html#0a509977acecc8bee5c00dabbfcc56d5">xnvfile_snapshot_ops::store</a>, and <a class="el" href="vfile_8h-source.html#l00504">xnvfile_snapshot::tag</a>.</p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="g7f46f9d1249c5d855b5ead672a0d6ee5"></a><!-- doxytag: member="vfile.c::nkvfroot" ref="g7f46f9d1249c5d855b5ead672a0d6ee5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnvfile_directory <a class="el" href="group__vfile.html#g7f46f9d1249c5d855b5ead672a0d6ee5">nkvfroot</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Xenomai vfile root directory. 
<p>
This vdir maps the /proc/xenomai directory. It can be used to create a hierarchy of Xenomai-related vfiles under this root. 
<p>Referenced by <a class="el" href="vfile_8c-source.html#l00725">xnvfile_destroy()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7f46f9d1249c5d855b5ead672a0d6ee5"></a><!-- doxytag: member="vfile.h::nkvfroot" ref="g7f46f9d1249c5d855b5ead672a0d6ee5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnvfile_directory <a class="el" href="group__vfile.html#g7f46f9d1249c5d855b5ead672a0d6ee5">nkvfroot</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Xenomai vfile root directory. 
<p>
This vdir maps the /proc/xenomai directory. It can be used to create a hierarchy of Xenomai-related vfiles under this root. 
<p>Referenced by <a class="el" href="vfile_8c-source.html#l00725">xnvfile_destroy()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Sep 2 20:38:46 2010 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
