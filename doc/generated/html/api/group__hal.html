<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Xenomai API: HAL.</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai API
   &#160;<span id="projectnumber">2.5.6.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__hal.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HAL.</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic Adeos-based hardware abstraction layer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arm_2hal_8c.html">hal.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for ARM. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blackfin_2hal_8c.html">hal.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for the Blackfin architecture. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blackfin_2nmi_8c.html">nmi.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>NMI watchdog support. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generic_2hal_8c.html">hal.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Generic Real-Time HAL. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generic_2nmi_8c.html">nmi.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for x86. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nios2_2hal_8c.html">hal.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for the NIOS2 architecture. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="powerpc_2hal_8c.html">hal.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for PowerPC. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal-common_8c.html">hal-common.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for x86. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__32_8c.html">hal_32.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for x86. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__64_8c.html">hal_64.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for x86_64. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86_2nmi_8c.html">nmi.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>NMI watchdog for x86, from linux/arch/i386/kernel/nmi.c. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="smi_8c.html">smi.c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SMI workaround for x86. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6">rthal_timer_request</a> (void(*tick_handler)(void), void(*mode_emul)(enum clock_event_mode mode, struct clock_event_device *cdev), int(*tick_emul)(unsigned long delay, struct clock_event_device *cdev), int cpu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Grab the hardware timer.  <a href="#ga174a498bd8ee10a2279a9f79b9823bf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga1ff77e4ea7ed60ba6a1b1a61a513058d">rthal_timer_release</a> (int cpu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the hardware timer.  <a href="#ga1ff77e4ea7ed60ba6a1b1a61a513058d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gae84c63d8728c72e9374da3a86df14d64">rthal_irq_host_request</a> (unsigned irq, rthal_irq_host_handler_t handler, char *name, void *dev_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a shared Linux interrupt handler.  <a href="#gae84c63d8728c72e9374da3a86df14d64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga80403d346662fcc3c960f12e4d5b8e09">rthal_irq_host_release</a> (unsigned irq, void *dev_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall a shared Linux interrupt handler.  <a href="#ga80403d346662fcc3c960f12e4d5b8e09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga306c0dcb88589f6a84f9b9d3304c4e8e">rthal_irq_enable</a> (unsigned irq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable an interrupt source.  <a href="#ga306c0dcb88589f6a84f9b9d3304c4e8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga615e2795b5a080f9155bf2f9f29e0b3f">rthal_irq_disable</a> (unsigned irq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable an interrupt source.  <a href="#ga615e2795b5a080f9155bf2f9f29e0b3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gaadf0f98059a5bf1caddda9dd48d51f20">rthal_irq_request</a> (unsigned irq, rthal_irq_handler_t handler, rthal_irq_ackfn_t ackfn, void *cookie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a real-time interrupt handler.  <a href="#gaadf0f98059a5bf1caddda9dd48d51f20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gad7d90c5882463a1d36b7a0ad74a9d4ff">rthal_irq_release</a> (unsigned irq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall a real-time interrupt handler.  <a href="#gad7d90c5882463a1d36b7a0ad74a9d4ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga63c5799998ae73a818b3c3be4cca89bd">rthal_irq_affinity</a> (unsigned irq, cpumask_t cpumask, cpumask_t *oldmask)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get processor affinity for external interrupt.  <a href="#ga63c5799998ae73a818b3c3be4cca89bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rthal_trap_handler_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga3f868180536815c231983781afef99c4">rthal_trap_catch</a> (rthal_trap_handler_t handler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a fault handler.  <a href="#ga3f868180536815c231983781afef99c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gafb91722da28118853a09b1a0d98dd169">rthal_apc_alloc</a> (const char *name, void(*handler)(void *cookie), void *cookie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an APC slot.  <a href="#gafb91722da28118853a09b1a0d98dd169"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gaf11636f94b0a6913241679d84265eba6">rthal_apc_free</a> (int apc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an APC slot.  <a href="#gaf11636f94b0a6913241679d84265eba6"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Generic Adeos-based hardware abstraction layer. </p>
<p>x86_64-specific HAL services.</p>
<p>i386-specific HAL services.</p>
<p>PowerPC-specific HAL services.</p>
<p>NIOS2-specific HAL services.</p>
<p>Generic NMI watchdog services.</p>
<p>Blackfin-specific HAL services.</p>
<p>ARM-specific HAL services. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gafb91722da28118853a09b1a0d98dd169"></a><!-- doxytag: member="hal.c::rthal_apc_alloc" ref="gafb91722da28118853a09b1a0d98dd169" args="(const char *name, void(*handler)(void *cookie), void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hal.html#gafb91722da28118853a09b1a0d98dd169">rthal_apc_alloc</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cookie)&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate an APC slot. </p>
<p>APC is the acronym for Asynchronous Procedure Call, a mean by which activities from the Xenomai domain can schedule deferred invocations of handlers to be run into the Linux domain, as soon as possible when the Linux kernel gets back in control. Up to BITS_PER_LONG APC slots can be active at any point in time. APC support is built upon Adeos's virtual interrupt support.</p>
<p>The HAL guarantees that any Linux kernel service which would be callable from a regular Linux interrupt handler is also available to APC handlers, including over PREEMPT_RT kernels exhibiting a threaded IRQ model.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is a symbolic name identifying the APC which will get reported through the /proc/xenomai/apc interface. Passing NULL to create an anonymous APC is allowed.</td></tr>
    <tr><td class="paramname">handler</td><td>The address of the fault handler to call upon exception condition. The handle will be passed the <em>cookie</em> value unmodified.</td></tr>
    <tr><td class="paramname">cookie</td><td>A user-defined opaque cookie the HAL will pass to the APC handler as its sole argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an valid APC id. is returned upon success, or a negative error code otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>handler</em> is invalid.</li>
</ul>
<ul>
<li>-EBUSY is returned if no more APC slots are available.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Linux domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaf11636f94b0a6913241679d84265eba6"></a><!-- doxytag: member="hal.c::rthal_apc_free" ref="gaf11636f94b0a6913241679d84265eba6" args="(int apc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hal.html#gaf11636f94b0a6913241679d84265eba6">rthal_apc_free</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>apc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases an APC slot. </p>
<p>This service deallocates an APC slot obtained by <a class="el" href="group__hal.html#gafb91722da28118853a09b1a0d98dd169" title="Allocate an APC slot.">rthal_apc_alloc()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">apc</td><td>The APC id. to release, as returned by a successful call to the <a class="el" href="group__hal.html#gafb91722da28118853a09b1a0d98dd169" title="Allocate an APC slot.">rthal_apc_alloc()</a> service.</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga63c5799998ae73a818b3c3be4cca89bd"></a><!-- doxytag: member="hal.c::rthal_irq_affinity" ref="ga63c5799998ae73a818b3c3be4cca89bd" args="(unsigned irq, cpumask_t cpumask, cpumask_t *oldmask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hal.html#ga63c5799998ae73a818b3c3be4cca89bd">rthal_irq_affinity</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpumask_t&#160;</td>
          <td class="paramname"><em>cpumask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpumask_t *&#160;</td>
          <td class="paramname"><em>oldmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set/Get processor affinity for external interrupt. </p>
<p>On SMP systems, this service ensures that the given interrupt is preferably dispatched to the specified set of processors. The previous affinity mask is returned by this service.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>The interrupt source whose processor affinity is affected by the operation. Only external interrupts can have their affinity changed/queried, thus virtual interrupt numbers allocated by rthal_alloc_virq() are invalid values for this parameter.</td></tr>
    <tr><td class="paramname">cpumask</td><td>A list of CPU identifiers passed as a bitmask representing the new affinity for this interrupt. A zero value cause this service to return the current affinity mask without changing it.</td></tr>
    <tr><td class="paramname">oldmask</td><td>If non-NULL, a pointer to a memory area which will bve overwritten by the previous affinity mask used for this interrupt source, or a zeroed mask if an error occurred. This service always returns a zeroed mask on uniprocessor systems.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Linux domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga615e2795b5a080f9155bf2f9f29e0b3f"></a><!-- doxytag: member="hal.c::rthal_irq_disable" ref="ga615e2795b5a080f9155bf2f9f29e0b3f" args="(unsigned irq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hal.html#ga615e2795b5a080f9155bf2f9f29e0b3f">rthal_irq_disable</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>irq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable an interrupt source. </p>
<p>Disables an interrupt source at PIC level. After this call has returned, no more IRQs from the given source will be allowed, until the latter is enabled again using <a class="el" href="group__hal.html#ga306c0dcb88589f6a84f9b9d3304c4e8e" title="Enable an interrupt source.">rthal_irq_enable()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>The interrupt source to disable. This value is architecture-dependent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li>
</ul>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga306c0dcb88589f6a84f9b9d3304c4e8e"></a><!-- doxytag: member="hal.c::rthal_irq_enable" ref="ga306c0dcb88589f6a84f9b9d3304c4e8e" args="(unsigned irq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hal.html#ga306c0dcb88589f6a84f9b9d3304c4e8e">rthal_irq_enable</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>irq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable an interrupt source. </p>
<p>Enables an interrupt source at PIC level. Since Adeos masks and acknowledges the associated interrupt source upon IRQ receipt, this action is usually needed whenever the HAL handler does not propagate the IRQ event to the Linux domain, thus preventing the regular Linux interrupt handling code from re-enabling said source. After this call has returned, IRQs from the given source will be enabled again.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>The interrupt source to enable. This value is architecture-dependent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li>
</ul>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga80403d346662fcc3c960f12e4d5b8e09"></a><!-- doxytag: member="hal.c::rthal_irq_host_release" ref="ga80403d346662fcc3c960f12e4d5b8e09" args="(unsigned irq, void *dev_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hal.html#ga80403d346662fcc3c960f12e4d5b8e09">rthal_irq_host_release</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uninstall a shared Linux interrupt handler. </p>
<p>Uninstalls a shared interrupt handler from the Linux domain for the given interrupt source. The handler is removed from the existing list of Linux handlers for this interrupt source.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>The interrupt source to detach the shared handler from. This value is architecture-dependent.</td></tr>
    <tr><td class="paramname">dev_id</td><td>is a valid device id, identical in essence to the one requested by the free_irq() service provided by the Linux kernel. This value will be used to locate the handler to remove from the chain of existing Linux handlers for the given interrupt source. This parameter must match the device id. passed to <a class="el" href="group__hal.html#gae84c63d8728c72e9374da3a86df14d64" title="Install a shared Linux interrupt handler.">rthal_irq_host_request()</a> for the same handler instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Linux domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae84c63d8728c72e9374da3a86df14d64"></a><!-- doxytag: member="hal.c::rthal_irq_host_request" ref="gae84c63d8728c72e9374da3a86df14d64" args="(unsigned irq, rthal_irq_host_handler_t handler, char *name, void *dev_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hal.html#gae84c63d8728c72e9374da3a86df14d64">rthal_irq_host_request</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rthal_irq_host_handler_t&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install a shared Linux interrupt handler. </p>
<p>Installs a shared interrupt handler in the Linux domain for the given interrupt source. The handler is appended to the existing list of Linux handlers for this interrupt source.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>The interrupt source to attach the shared handler to. This value is architecture-dependent.</td></tr>
    <tr><td class="paramname">handler</td><td>The address of a valid interrupt service routine. This handler will be called each time the corresponding IRQ is delivered, as part of the chain of existing regular Linux handlers for this interrupt source. The handler prototype is the same as the one required by the request_irq() service provided by the Linux kernel.</td></tr>
    <tr><td class="paramname">name</td><td>is a symbolic name identifying the handler which will get reported through the /proc/interrupts interface.</td></tr>
    <tr><td class="paramname">dev_id</td><td>is a unique device id, identical in essence to the one requested by the request_irq() service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid or <em>handler</em> is NULL.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Linux domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="gad7d90c5882463a1d36b7a0ad74a9d4ff"></a><!-- doxytag: member="hal.c::rthal_irq_release" ref="gad7d90c5882463a1d36b7a0ad74a9d4ff" args="(unsigned irq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hal.html#gad7d90c5882463a1d36b7a0ad74a9d4ff">rthal_irq_release</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>irq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uninstall a real-time interrupt handler. </p>
<p>Uninstalls an interrupt handler previously attached using the <a class="el" href="group__hal.html#gaadf0f98059a5bf1caddda9dd48d51f20" title="Install a real-time interrupt handler.">rthal_irq_request()</a> service.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>The hardware interrupt channel to uninstall a handler from. This value is architecture-dependent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li>
</ul>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

<p>Referenced by <a class="el" href="group__hal.html#ga1ff77e4ea7ed60ba6a1b1a61a513058d">rthal_timer_release()</a>.</p>

</div>
</div>
<a class="anchor" id="gaadf0f98059a5bf1caddda9dd48d51f20"></a><!-- doxytag: member="hal.c::rthal_irq_request" ref="gaadf0f98059a5bf1caddda9dd48d51f20" args="(unsigned irq, rthal_irq_handler_t handler, rthal_irq_ackfn_t ackfn, void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hal.html#gaadf0f98059a5bf1caddda9dd48d51f20">rthal_irq_request</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rthal_irq_handler_t&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rthal_irq_ackfn_t&#160;</td>
          <td class="paramname"><em>ackfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install a real-time interrupt handler. </p>
<p>Installs an interrupt handler for the specified IRQ line by requesting the appropriate Adeos virtualization service. The handler is invoked by Adeos on behalf of the Xenomai domain context. Once installed, the HAL interrupt handler will be called prior to the regular Linux handler for the same interrupt source.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>The hardware interrupt channel to install a handler on. This value is architecture-dependent.</td></tr>
    <tr><td class="paramname">handler</td><td>The address of a valid interrupt service routine. This handler will be called each time the corresponding IRQ is delivered, and will be passed the <em>cookie</em> value unmodified.</td></tr>
    <tr><td class="paramname">ackfn</td><td>The address of an optional interrupt acknowledge routine, aimed at replacing the one provided by Adeos. Only very specific situations actually require to override the default Adeos setting for this parameter, like having to acknowledge non-standard PIC hardware. If <em>ackfn</em> is NULL, the default Adeos routine will be used instead.</td></tr>
    <tr><td class="paramname">cookie</td><td>A user-defined opaque cookie the HAL will pass to the interrupt handler as its sole argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if an interrupt handler is already installed. <a class="el" href="group__hal.html#gad7d90c5882463a1d36b7a0ad74a9d4ff" title="Uninstall a real-time interrupt handler.">rthal_irq_release()</a> must be issued first before a handler is installed anew.</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid or <em>handler</em> is NULL.</li>
</ul>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

<p>Referenced by <a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6">rthal_timer_request()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ff77e4ea7ed60ba6a1b1a61a513058d"></a><!-- doxytag: member="hal.c::rthal_timer_release" ref="ga1ff77e4ea7ed60ba6a1b1a61a513058d" args="(int cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__hal.html#ga1ff77e4ea7ed60ba6a1b1a61a513058d">rthal_timer_release</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the hardware timer. </p>
<p>Releases the hardware timer, thus reverting the effect of a previous call to <a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6" title="Grab the hardware timer.">rthal_timer_request()</a>. In case the timer hardware is shared with Linux, a periodic setup suitable for the Linux kernel will be reset.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu</td><td>The CPU number the timer was grabbed from.</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Linux domain context. </li>
</ul>

<p>References <a class="el" href="group__hal.html#gad7d90c5882463a1d36b7a0ad74a9d4ff">rthal_irq_release()</a>.</p>

</div>
</div>
<a class="anchor" id="ga174a498bd8ee10a2279a9f79b9823bf6"></a><!-- doxytag: member="hal.c::rthal_timer_request" ref="ga174a498bd8ee10a2279a9f79b9823bf6" args="(void(*tick_handler)(void), void(*mode_emul)(enum clock_event_mode mode, struct clock_event_device *cdev), int(*tick_emul)(unsigned long delay, struct clock_event_device *cdev), int cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6">rthal_timer_request</a> </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>tick_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(enum clock_event_mode mode, struct clock_event_device *cdev)&#160;</td>
          <td class="paramname"><em>mode_emul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(unsigned long delay, struct clock_event_device *cdev)&#160;</td>
          <td class="paramname"><em>tick_emul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Grab the hardware timer. </p>
<p><a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6" title="Grab the hardware timer.">rthal_timer_request()</a> grabs and tunes the hardware timer in oneshot mode in order to clock the master time base.</p>
<p>A user-defined routine is registered as the clock tick handler. This handler will always be invoked on behalf of the Xenomai domain for each incoming tick.</p>
<p>Hooks for emulating oneshot mode for the tick device are accepted when CONFIG_GENERIC_CLOCKEVENTS is defined for the host kernel. Host tick emulation is a way to share the clockchip hardware between Linux and Xenomai, when the former provides support for oneshot timing (i.e. high resolution timers and no-HZ scheduler ticking).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tick_handler</td><td>The address of the Xenomai tick handler which will process each incoming tick.</td></tr>
    <tr><td class="paramname">mode_emul</td><td>The optional address of a callback to be invoked upon mode switch of the host tick device, notified by the Linux kernel. This parameter is only considered whenever CONFIG_GENERIC_CLOCKEVENTS is defined.</td></tr>
    <tr><td class="paramname">tick_emul</td><td>The optional address of a callback to be invoked upon setup of the next shot date for the host tick device, notified by the Linux kernel. This parameter is only considered whenever CONFIG_GENERIC_CLOCKEVENTS is defined.</td></tr>
    <tr><td class="paramname">cpu</td><td>The CPU number to grab the timer from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a positive value is returned on success, representing the duration of a Linux periodic tick expressed as a count of nanoseconds; zero should be returned when the Linux kernel does not undergo periodic timing on the given CPU (e.g. oneshot mode). Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if the hardware timer has already been grabbed. <a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6" title="Grab the hardware timer.">rthal_timer_request()</a> must be issued before <a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6" title="Grab the hardware timer.">rthal_timer_request()</a> is called again.</li>
</ul>
<ul>
<li>-ENODEV is returned if the hardware timer cannot be used. This situation may occur after the kernel disabled the timer due to invalid calibration results; in such a case, such hardware is unusable for any timing duties.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Linux domain context. </li>
</ul>

<p>References <a class="el" href="group__hal.html#gaadf0f98059a5bf1caddda9dd48d51f20">rthal_irq_request()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f868180536815c231983781afef99c4"></a><!-- doxytag: member="hal.c::rthal_trap_catch" ref="ga3f868180536815c231983781afef99c4" args="(rthal_trap_handler_t handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hal.html#ga3f868180536815c231983781afef99c4">rthal_trap_catch</a> </td>
          <td>(</td>
          <td class="paramtype">rthal_trap_handler_t&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Installs a fault handler. </p>
<p>The HAL attempts to invoke a fault handler whenever an uncontrolled exception or fault is caught at machine level. This service allows to install a user-defined handler for such events.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The address of the fault handler to call upon exception condition. The handler is passed the address of the low-level information block describing the fault as passed by Adeos. Its layout is implementation-dependent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the fault handler previously installed.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Thu Aug 2 2012 09:31:35 for Xenomai API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
