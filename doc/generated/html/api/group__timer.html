<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: Timer services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Timer services.<br>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>]</small>
</h1>
<p>
Collaboration diagram for Timer services.:<center><table><tr><td><img src="group__timer.png" border="0" alt="" usemap="#group____timer_map">
<map name="group____timer_map">
<area href="group__nucleus.html" shape="rect" coords="5,5,147,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The Xenomai timer facility always operate the timer hardware in oneshot mode, regardless of the time base in effect. Periodic timing is obtained through a software emulation, using cascading timers.<p>
Depending on the time base used, the timer object stores time values either as count of jiffies (periodic), or as count of CPU ticks (aperiodic). 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="include_2nucleus_2timer_8h.html">timer.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="note" compact><dt><b>Note:</b></dt><dd>Copyright (C) 2001,2002,2003 Philippe Gerum &lt;<a href="mailto:rpm@xenomai.org">rpm@xenomai.org</a>&gt;. </dd></dl>
<br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2nucleus_2timer_8c.html">timer.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="note" compact><dt><b>Note:</b></dt><dd>Copyright (C) 2001,2002,2003,2007 Philippe Gerum &lt;<a href="mailto:rpm@xenomai.org">rpm@xenomai.org</a>&gt;. </dd></dl>
<br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#g0d9ee64879bfc01d1446a740278ce3d0">xntimer_start</a> (xntimer_t *timer, xnticks_t value, xnticks_t interval, xntmode_t mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arm a timer.  <a href="#g0d9ee64879bfc01d1446a740278ce3d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#g45eada4d1d8b091d6b8faf5a750748e2">xntimer_stop</a> (xntimer_t *timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disarm a timer.  <a href="#g45eada4d1d8b091d6b8faf5a750748e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static xnticks_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#g3da67e8c10030397f8ba64478d64fd9e">xntimer_get_date</a> (xntimer_t *timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the absolute expiration date.  <a href="#g3da67e8c10030397f8ba64478d64fd9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static xnticks_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga0b725a8041740b39607c5c1d1886ece">xntimer_get_timeout</a> (xntimer_t *timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the relative expiration date.  <a href="#ga0b725a8041740b39607c5c1d1886ece"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static xnticks_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#g8ee662ebd2d5e280beff1a158002a78d">xntimer_get_interval</a> (xntimer_t *timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the timer interval value.  <a href="#g8ee662ebd2d5e280beff1a158002a78d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#g19c80223924cb28cec8ab5bd0a79af37">xntimer_tick_aperiodic</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process a timer tick for the aperiodic master time base.  <a href="#g19c80223924cb28cec8ab5bd0a79af37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ge31412b50c0fb559194fd8a361430131">xntimer_tick_periodic</a> (xntimer_t *mtimer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process a timer tick for a slave periodic time base.  <a href="#ge31412b50c0fb559194fd8a361430131"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#gaff8afdafbf1065689fbd28f9da58723">xntimer_init</a> (xntimer_t *timer, xntbase_t *base, void(*handler)(xntimer_t *timer))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a timer object.  <a href="#gaff8afdafbf1065689fbd28f9da58723"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#g9ea17553c381821d2ac8798689a13122">xntimer_destroy</a> (xntimer_t *timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a timer object.  <a href="#g9ea17553c381821d2ac8798689a13122"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#g1b2d68c3cdf9941213dd3f4002e32843">xntimer_get_overruns</a> (xntimer_t *timer, xnticks_t now)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the count of overruns for the last tick.  <a href="#g1b2d68c3cdf9941213dd3f4002e32843"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#gb4d6a7fe746455fb3e025307d4b84c87">xntimer_freeze</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Freeze all timers (from every time bases).  <a href="#gb4d6a7fe746455fb3e025307d4b84c87"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g9ea17553c381821d2ac8798689a13122"></a><!-- doxytag: member="timer.c::xntimer_destroy" ref="g9ea17553c381821d2ac8798689a13122" args="(xntimer_t *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_destroy           </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release a timer object. 
<p>
Destroys a timer. After it has been destroyed, all resources associated with the timer have been released. The timer is automatically deactivated before deletion if active on entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="gb4d6a7fe746455fb3e025307d4b84c87"></a><!-- doxytag: member="timer.c::xntimer_freeze" ref="gb4d6a7fe746455fb3e025307d4b84c87" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_freeze           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Freeze all timers (from every time bases). 
<p>
<p><b>For internal use only.</b></p>
<p>
This routine deactivates all active timers atomically.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. </p>

</div>
</div><p>
<a class="anchor" name="g3da67e8c10030397f8ba64478d64fd9e"></a><!-- doxytag: member="timer.h::xntimer_get_date" ref="g3da67e8c10030397f8ba64478d64fd9e" args="(xntimer_t *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnticks_t xntimer_get_date           </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the absolute expiration date. 
<p>
Return the next expiration date of a timer in absolute clock ticks (see note).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The expiration date converted to the current time unit. The special value XN_INFINITE is returned if <em>timer</em> is currently inactive.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the associated time base, as defined by the xnpod_init_timebase() service. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8ee662ebd2d5e280beff1a158002a78d"></a><!-- doxytag: member="timer.h::xntimer_get_interval" ref="g8ee662ebd2d5e280beff1a158002a78d" args="(xntimer_t *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnticks_t xntimer_get_interval           </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the timer interval value. 
<p>
Return the timer interval value in clock ticks (see note).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The expiration date converted to the current time unit. The special value XN_INFINITE is returned if <em>timer</em> is currently inactive or aperiodic.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the associated time base, as defined by the xnpod_init_timebase() service. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1b2d68c3cdf9941213dd3f4002e32843"></a><!-- doxytag: member="timer.c::xntimer_get_overruns" ref="g1b2d68c3cdf9941213dd3f4002e32843" args="(xntimer_t *timer, xnticks_t now)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long xntimer_get_overruns           </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>now</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the count of overruns for the last tick. 
<p>
This service returns the count of pending overruns for the last tick of a given timer, as measured by the difference between the expected expiry date of the timer and the date <em>now</em> passed as argument.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>now</em>&nbsp;</td><td>current date (in the monotonic time base)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of overruns of <em>timer</em> at date <em>now</em> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga0b725a8041740b39607c5c1d1886ece"></a><!-- doxytag: member="timer.h::xntimer_get_timeout" ref="ga0b725a8041740b39607c5c1d1886ece" args="(xntimer_t *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnticks_t xntimer_get_timeout           </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the relative expiration date. 
<p>
Return the next expiration date of a timer in relative clock ticks (see note).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The expiration date converted to the current time unit. The special value XN_INFINITE is returned if <em>timer</em> is currently inactive. In oneshot mode, it might happen that the timer has already expired when this service is run (even if the associated handler has not been fired yet); in such a case, 1 is returned.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the associated time base, as defined by the xnpod_init_timebase() service. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gaff8afdafbf1065689fbd28f9da58723"></a><!-- doxytag: member="timer.c::xntimer_init" ref="gaff8afdafbf1065689fbd28f9da58723" args="(xntimer_t *timer, xntbase_t *base, void(*handler)(xntimer_t *timer))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_init           </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntbase_t *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(xntimer_t *timer)&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a timer object. 
<p>
Creates a timer. When created, a timer is left disarmed; it must be started using <a class="el" href="group__timer.html#g0d9ee64879bfc01d1446a740278ce3d0">xntimer_start()</a> in order to be activated.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a timer descriptor the nucleus will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>The descriptor address of the time base the new timer depends on. See <a class="el" href="group__timebase.html#g6e7eb1a04be7f71cb1986ef530060e49">xntbase_alloc()</a> for detailed explanations about time bases.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The routine to call upon expiration of the timer.</td></tr>
  </table>
</dl>
There is no limitation on the number of timers which can be created/active concurrently.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g0d9ee64879bfc01d1446a740278ce3d0"></a><!-- doxytag: member="timer.h::xntimer_start" ref="g0d9ee64879bfc01d1446a740278ce3d0" args="(xntimer_t *timer, xnticks_t value, xnticks_t interval, xntmode_t mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_start           </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntmode_t&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Arm a timer. 
<p>
Activates a timer so that the associated timeout handler will be fired after each expiration time. A timer can be either periodic or single-shot, depending on the reload value passed to this routine. The given timer must have been previously initialized, and will be clocked according to the policy defined by the time base specified in xntimer_init().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The date of the initial timer shot, expressed in clock ticks (see note).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>The reload value of the timer. It is a periodic interval value to be used for reprogramming the next timer shot, expressed in clock ticks (see note). If <em>interval</em> is equal to XN_INFINITE, the timer will not be reloaded after it has expired.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The timer mode. It can be XN_RELATIVE if <em>value</em> shall be interpreted as a relative date, XN_ABSOLUTE for an absolute date based on the monotonic clock of the related time base (as returned my xntbase_get_jiffies()), or XN_REALTIME if the absolute date is based on the adjustable real-time clock of the time base (as returned by <a class="el" href="group__timebase.html#gedd3ccb7c998cfe35f946b1806d3eac8">xntbase_get_time()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, or -ETIMEDOUT if an absolute date in the past has been given.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the associated time base, as defined by the xnpod_init_timebase() service. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds.<p>
Must be called with nklock held, IRQs off. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g45eada4d1d8b091d6b8faf5a750748e2"></a><!-- doxytag: member="timer.h::xntimer_stop" ref="g45eada4d1d8b091d6b8faf5a750748e2" args="(xntimer_t *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xntimer_stop           </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disarm a timer. 
<p>
This service deactivates a timer previously armed using <a class="el" href="group__timer.html#g0d9ee64879bfc01d1446a740278ce3d0">xntimer_start()</a>. Once disarmed, the timer can be subsequently re-armed using the latter service.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Must be called with nklock held, IRQs off. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g19c80223924cb28cec8ab5bd0a79af37"></a><!-- doxytag: member="timer.c::xntimer_tick_aperiodic" ref="g19c80223924cb28cec8ab5bd0a79af37" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_tick_aperiodic           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Process a timer tick for the aperiodic master time base. 
<p>
<p><b>For internal use only.</b></p>
<p>
This routine informs all active timers that the clock has been updated by processing the outstanding timer list. Elapsed timer actions will be fired.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Interrupt service routine, nklock locked, interrupts off</li></ul>
<p>
Rescheduling: never. </p>

</div>
</div><p>
<a class="anchor" name="ge31412b50c0fb559194fd8a361430131"></a><!-- doxytag: member="timer.c::xntimer_tick_periodic" ref="ge31412b50c0fb559194fd8a361430131" args="(xntimer_t *mtimer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_tick_periodic           </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>mtimer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Process a timer tick for a slave periodic time base. 
<p>
<p><b>For internal use only.</b></p>
<p>
The periodic timer tick is cascaded from a software timer managed from the master aperiodic time base; in other words, periodic timing is emulated by software timers running in aperiodic timing mode. There may be several concurrent periodic time bases (albeit a single aperiodic time base - i.e. the master one called "nktbase" - may exist at any point in time).<p>
This routine informs all active timers that the clock has been updated by processing the timer wheel. Elapsed timer actions will be fired.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mtimer</em>&nbsp;</td><td>The address of the cascading timer running in the master time base which announced the tick.</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Interrupt service routine, nklock locked, interrupts off</li></ul>
<p>
Rescheduling: never.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Only active timers are inserted into the timer wheel. </dd></dl>
</p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Sun Sep 9 22:42:51 2007 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
