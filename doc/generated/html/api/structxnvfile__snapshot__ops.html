<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: xnvfile_snapshot_ops Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xnvfile_snapshot_ops Struct Reference<br>
<small>
[<a class="el" href="group__vfile.html">Virtual file services</a>]</small>
</h1><!-- doxytag: class="xnvfile_snapshot_ops" --><hr><a name="_details"></a><h2>Detailed Description</h2>
Snapshot vfile operation descriptor. 
<p>
<a class="anchor" name="snapshot_ops"></a><p>
This structure describes the operations available with a snapshot-driven vfile. It defines handlers for returning a printable snapshot of some Xenomai object contents upon a user-space read request, and for updating this object upon a user-space write request. <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#2bb1150c2a0f60c6eb979781cbc451c1">rewind</a> )(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#43f7c2737ab6ac530041ba0ede25684c">begin</a> )(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#e32a9a16730fa80bfb420111832750e2">end</a> )(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *buf)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#37a216b44ddfa5c895b7de05da0acd10">next</a> )(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#ebfdb0fda48d23b475d93d8945412ab6">show</a> )(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#0a509977acecc8bee5c00dabbfcc56d5">store</a> )(struct xnvfile_input *input)</td></tr>

</table>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="2bb1150c2a0f60c6eb979781cbc451c1"></a><!-- doxytag: member="xnvfile_snapshot_ops::rewind" ref="2bb1150c2a0f60c6eb979781cbc451c1" args=")(struct xnvfile_snapshot_iterator *it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structxnvfile__snapshot__ops.html#2bb1150c2a0f60c6eb979781cbc451c1">xnvfile_snapshot_ops::rewind</a>)(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="anchor" name="snapshot_rewind"></a> This handler (re-)initializes the data collection, moving the seek pointer at the first record. When the file revision tag is touched while collecting data, the current reading is aborted, all collected data dropped, and the vfile is eventually rewound.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>A pointer to the current snapshot iterator. Two useful information can be retrieved from this iterator in this context:</td></tr>
  </table>
</dl>
<ul>
<li>it-&gt;vfile is a pointer to the descriptor of the virtual file being rewound.</li></ul>
<p>
<ul>
<li>xnvfile_iterator_priv(it) returns a pointer to the private data area, available from the descriptor, which size is vfile-&gt;privsz. If the latter size is zero, the returned pointer is meaningless and should not be used.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative error code aborts the data collection, and is passed back to the reader. Otherwise:</dd></dl>
<ul>
<li>a strictly positive value is interpreted as the total number of records which will be returned by the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next() handler</a> during the data collection phase. If no <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_begin">begin() handler</a> is provided in the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_ops">operation descriptor</a>, this value is used to allocate the snapshot buffer internally. The size of this buffer would then be vfile-&gt;datasz * value.</li></ul>
<p>
<ul>
<li>zero leaves the allocation to the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_begin">begin() handler</a> if present, or indicates that no record is to be output in case such handler is not given.</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This handler is optional; a NULL value indicates that nothing needs to be done for rewinding the vfile. It is called with the vfile lock held. </dd></dl>

</div>
</div><p>
<a class="anchor" name="43f7c2737ab6ac530041ba0ede25684c"></a><!-- doxytag: member="xnvfile_snapshot_ops::begin" ref="43f7c2737ab6ac530041ba0ede25684c" args=")(struct xnvfile_snapshot_iterator *it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* <a class="el" href="structxnvfile__snapshot__ops.html#43f7c2737ab6ac530041ba0ede25684c">xnvfile_snapshot_ops::begin</a>)(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="anchor" name="snapshot_begin"></a> This handler should allocate the snapshot buffer to hold records during the data collection phase. When specified, all records collected via the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next()</a> handler" will be written to a cell from the memory area returned by <a class="el" href="structxnvfile__snapshot__ops.html#43f7c2737ab6ac530041ba0ede25684c">begin()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>A pointer to the current snapshot iterator.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the record buffer, if the call succeeds. Otherwise:</dd></dl>
<ul>
<li>NULL in case of allocation error. This will abort the data collection, and return -ENOMEM to the reader.</li></ul>
<p>
<ul>
<li>VFILE_SEQ_EMPTY, a special value indicating that no record will be output. In such a case, the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next() handler</a> will not be called, and the data collection will stop immediately. However, the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_show">show() handler</a> will still be called once, with a NULL data pointer (i.e. header display request).</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This handler is optional; if none is given, an internal allocation depending on the value returned by the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_rewind">rewind() handler</a> can be obtained. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e32a9a16730fa80bfb420111832750e2"></a><!-- doxytag: member="xnvfile_snapshot_ops::end" ref="e32a9a16730fa80bfb420111832750e2" args=")(struct xnvfile_snapshot_iterator *it, void *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structxnvfile__snapshot__ops.html#e32a9a16730fa80bfb420111832750e2">xnvfile_snapshot_ops::end</a>)(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *buf)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="anchor" name="snapshot_end"></a> This handler releases the memory buffer previously obtained from <a class="el" href="structxnvfile__snapshot__ops.html#43f7c2737ab6ac530041ba0ede25684c">begin()</a>. It is usually called after the snapshot data has been output by <a class="el" href="structxnvfile__snapshot__ops.html#ebfdb0fda48d23b475d93d8945412ab6">show()</a>, but it may also be called before rewinding the vfile after a revision change, to release the dropped buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>A pointer to the current snapshot iterator.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>A pointer to the buffer to release.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine is optional and the pointer may be NULL. It is not needed upon internal buffer allocation; see the description of the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_rewind">rewind()</a> handler". </dd></dl>

</div>
</div><p>
<a class="anchor" name="37a216b44ddfa5c895b7de05da0acd10"></a><!-- doxytag: member="xnvfile_snapshot_ops::next" ref="37a216b44ddfa5c895b7de05da0acd10" args=")(struct xnvfile_snapshot_iterator *it, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structxnvfile__snapshot__ops.html#37a216b44ddfa5c895b7de05da0acd10">xnvfile_snapshot_ops::next</a>)(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="anchor" name="snapshot_next"></a> This handler fetches the next record, as part of the snapshot data to be sent back to the reader via the <a class="el" href="structxnvfile__snapshot__ops.html#ebfdb0fda48d23b475d93d8945412ab6">show()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>A pointer to the current snapshot iterator.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to the record to fill in.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a strictly positive value, if the call succeeds and leaves a valid record into <em>data</em>, which should be passed to the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_show">show() handler()</a> during the formatting and output phase. Otherwise:</dd></dl>
<ul>
<li>A negative error code. This will abort the data collection, and return this status to the reader.</li></ul>
<p>
<ul>
<li>VFILE_SEQ_SKIP, a special value indicating that the current record should be skipped. In such a case, the <em>data</em> pointer is not advanced to the next position before the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next() handler</a> is called anew.</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This handler is called with the vfile lock held. Before each invocation of this handler, the vfile core checks whether the revision tag has been touched, in which case the data collection is restarted from scratch. A data collection phase succeeds whenever all records can be fetched via the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next() handler</a>, while the revision tag remains unchanged, which indicates that a consistent snapshot of the object state was taken. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ebfdb0fda48d23b475d93d8945412ab6"></a><!-- doxytag: member="xnvfile_snapshot_ops::show" ref="ebfdb0fda48d23b475d93d8945412ab6" args=")(struct xnvfile_snapshot_iterator *it, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structxnvfile__snapshot__ops.html#ebfdb0fda48d23b475d93d8945412ab6">xnvfile_snapshot_ops::show</a>)(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="anchor" name="snapshot_show"></a> This handler should format and output a record from the collected data.<p>
xnvfile_printf(), xnvfile_write(), xnvfile_puts() and xnvfile_putc() are available to format and/or emit the output. All routines take the iterator argument <em>it</em> as their first parameter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>A pointer to the current snapshot iterator.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to the record to format then output. The first call to the handler is always passed a NULL <em>data</em> pointer; the show handler should test this special value to output any header that fits, prior to receiving more calls with actual records.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>zero if the call succeeds, also indicating that the handler should be called for the next record if any. Otherwise:</dd></dl>
<ul>
<li>A negative error code. This will abort the output phase, and return this status to the reader.</li></ul>
<p>
<ul>
<li>VFILE_SEQ_SKIP, a special value indicating that the current record should be skipped and will not be output. </li></ul>

</div>
</div><p>
<a class="anchor" name="0a509977acecc8bee5c00dabbfcc56d5"></a><!-- doxytag: member="xnvfile_snapshot_ops::store" ref="0a509977acecc8bee5c00dabbfcc56d5" args=")(struct xnvfile_input *input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t(* <a class="el" href="structxnvfile__snapshot__ops.html#0a509977acecc8bee5c00dabbfcc56d5">xnvfile_snapshot_ops::store</a>)(struct xnvfile_input *input)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="anchor" name="snapshot_store"></a> This handler receives data written to the vfile, likely for updating the associated Xenomai object's state, or triggering any other action which fits. This is the only handler which deals with the write-side of a vfile. It is called when writing to the /proc entry of the vfile from a user-space process.<p>
The input data is described by a descriptor passed to the handler, which may be subsequently passed to parsing helper routines. For instance, <a class="el" href="group__vfile.html#ge45ea5410707367c9e032dc36fc30916" title="Read in a C-string written to the vfile.">xnvfile_get_string()</a> will accept the input descriptor for returning the written data as a null-terminated character string. On the other hand, <a class="el" href="group__vfile.html#g18746b2aae928c0281ae57ef47086600" title="Evaluate the string written to the vfile as a long integer.">xnvfile_get_integer()</a> will attempt to return a long integer from the input data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>A pointer to an input descriptor. It refers to an opaque data from the handler's standpoint.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes read from the input descriptor if the call succeeds. Otherwise, a negative error code. Return values from parsing helper routines are commonly passed back to the caller by the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_store">store() handler</a>.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This handler is optional, and may be omitted for read-only vfiles. </dd></dl>

<p>Referenced by <a class="el" href="vfile_8c-source.html#l00383">xnvfile_init_snapshot()</a>.</p>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>include/nucleus/<a class="el" href="vfile_8h-source.html">vfile.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Sep 2 20:38:48 2010 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
