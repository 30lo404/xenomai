<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: CAN Devices</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>CAN Devices<br>
<small>
[<a class="el" href="group__profiles.html">Device Profiles</a>]</small>
</h1>
<p>
Collaboration diagram for CAN Devices:<center><table><tr><td><img src="group__rtcan.png" border="0" alt="" usemap="#group____rtcan_map">
<map name="group____rtcan_map">
<area href="group__profiles.html" shape="rect" coords="9,8,118,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This is the common interface a RTDM-compliant CAN device has to provide. Feel free to report bugs and comments on this profile to the "Socketcan" mailing list (<a href="mailto:Socketcan-core@lists.berlios.de">Socketcan-core@lists.berlios.de</a>) or directly to the authors (<a href="mailto:wg@grandegger.com">wg@grandegger.com</a> or <a href="mailto:Sebastian.Smolorz@stud.uni-hannover.de">Sebastian.Smolorz@stud.uni-hannover.de</a>). <br>
 <dl compact><dt><b>Device Characteristics</b></dt><dd><br>
 <a class="el" href="structrtdm__device.html#o1">Device Flags</a>: <code>RTDM_PROTOCOL_DEVICE</code> <br>
 <br>
 <a class="el" href="structrtdm__device.html#o4">Protocol Family</a>: <code>PF_CAN</code> <br>
 <br>
 <a class="el" href="structrtdm__device.html#o5">Socket Type</a>: <code>SOCK_RAW</code> <br>
 <br>
 <a class="el" href="structrtdm__device.html#o11">Device Class</a>: <code>RTDM_CLASS_CAN</code> <br>
 <br>
</dd></dl>
<dl compact><dt><b>Supported Operations</b></dt><dd><br>
 <b>Socket</b> <br>
 Environments: non-RT (RT optional)<br>
 <br>
 Specific return values:<ul>
<li>-EPROTONOSUPPORT (Protocol is not supported by the driver. See <a class="el" href="group__rtcan.html#CAN_PROTO">CAN protocols</a> for possible protocols.)</li></ul>
<br>
 <br>
 <b>Close</b> <br>
 Blocking calls to any of the <a class="el" href="group__rtcan.html#Send">Send</a> or <a class="el" href="group__rtcan.html#Recv">Receive</a> functions will be unblocked when the socket is closed and return with an error. <br>
 <br>
 Environments: non-RT (RT optional)<br>
 <br>
 Specific return values: none <br>
 <br>
 <br>
 <b>IOCTL</b> <br>
 Mandatory Environments: see <a class="el" href="group__rttesting.html#IOCTLs">below</a> <br>
 Specific return values: see <a class="el" href="group__rttesting.html#IOCTLs">below</a> <br>
 <br>
 <br>
 <a class="anchor" name="Bind"></a> <b>Bind</b> <br>
 Binds a socket to one or all CAN devices (see struct <a class="el" href="structsockaddr__can.html">sockaddr_can</a>). If a filter list has been defined with setsockopt (see <a class="el" href="group__rtcan.html#Sockopts">Sockopts</a>), it will be used upon reception of CAN frames to decide whether the bound socket will receive a frame. If no filter has been defined, the socket will receive <b>all</b> CAN frames on the specified interface(s). <br>
 <br>
 Binding to special interface index <code>0</code> will make the socket receive CAN frames from all CAN interfaces. <br>
 <br>
 Binding to an interface index is also relevant for the <a class="el" href="group__rtcan.html#Send">Send</a> functions because they will transmit a message over the interface the socket is bound to when no socket address is given to them. <br>
 <br>
 <br>
 Environments: non-RT (RT optional)<br>
 <br>
 Specific return values:<ul>
<li>-EFAULT (It was not possible to access user space memory area at the specified address.)</li><li>-ENOMEM (Not enough memory to fulfill the operation)</li><li>-EINVAL (Invalid address family, or invalid length of address structure)</li><li>-ENODEV (Invalid CAN interface index)</li><li>-ENOSPC (No enough space for filter list)</li><li>-EBADF (Socket is about to be closed)</li><li>-EAGAIN (Too many receivers. Old binding (if any) is still active. Close some sockets and try again.)</li></ul>
<br>
 <br>
 <a class="anchor" name="Sockopts"></a> <b>Setsockopt, Getsockopt</b><br>
 These functions allow to set and get various socket options. Currently, only CAN raw sockets are supported. <br>
 <br>
 Supported Levels and Options: <br>
<ul>
<li>Level <b>SOL_CAN_RAW</b> : CAN RAW protocol (see <a class="el" href="group__rtcan.html#gga102a102">CAN_PROTO_RAW</a>)<ul>
<li>Option <a class="el" href="group__rtcan.html#ga30">CAN_RAW_FILTER</a> : CAN filter list</li><li>Option <a class="el" href="group__rtcan.html#ga31">CAN_RAW_ERR_FILTER</a> : CAN error mask</li></ul>
</li></ul>
<br>
 Environments: non-RT (RT optional)<br>
 Specific return values: see links to options above. <br>
 <br>
 <br>
 <a class="anchor" name="Recv"></a> <b>Recv, Recvfrom, Recvmsg</b> <br>
 These functions receive CAN messages from a socket. Only one message per call can be received, so only one buffer with the correct length must be passed. For <code>SOCK_RAW</code>, this is the size of struct <a class="el" href="structcan__frame.html">can_frame</a>. <br>
 <br>
 Unlike a call to one of the <a class="el" href="group__rtcan.html#Send">Send</a> functions, a Recv function will not return with an error if an interface is down (due to bus-off or setting of stop mode) or in sleep mode. Moreover, in such a case there may still be some CAN messages in the socket buffer which could be read out successfully. <br>
 <br>
 It is possible to receive a high precision timestamp with every CAN message. The condition is a former instruction to the socket via <a class="el" href="group__rtcan.html#ga41">RTCAN_RTIOC_TAKE_TIMESTAMP</a>. The timestamp will be copied to the <code>msg_control</code> buffer of <code>struct msghdr</code> if it points to a valid memory location with size of <a class="el" href="group__rtcan.html#ga11">nanosecs_abs_t</a>. If this is a NULL pointer the timestamp will be discarded silently. <br>
 <br>
 <b>Note:</b> A <code>msg_controllen</code> of <code>0</code> upon completion of the function call indicates that no timestamp is available for that message. <br>
 <br>
 Supported Flags [in]:<ul>
<li>MSG_DONTWAIT (By setting this flag the operation will only succeed if it would not block, i.e. if there is a message in the socket buffer. This flag takes precedence over a timeout specified by <a class="el" href="group__rtcan.html#ga42">RTCAN_RTIOC_RCV_TIMEOUT</a>.)</li><li>MSG_PEEK (Receive a message but leave it in the socket buffer. The next receive operation will get that message again.)</li></ul>
<br>
 Supported Flags [out]: none <br>
 <br>
 Environments: RT (non-RT optional)<br>
 <br>
 Specific return values:<ul>
<li>Non-negative value (Indicating the successful reception of a CAN message. For <code>SOCK_RAW</code>, this is the size of struct <a class="el" href="structcan__frame.html">can_frame</a> regardless of the actual size of the payload.)</li><li>-EFAULT (It was not possible to access user space memory area at one of the specified addresses.)</li><li>-EINVAL (Unsupported flag detected, or invalid length of socket address buffer, or invalid length of message control buffer)</li><li>-EMSGSIZE (Zero or more than one iovec buffer passed, or buffer too small)</li><li>-EAGAIN (No data available in non-blocking mode)</li><li>-EBADF (Socket was closed.)</li><li>-EINTR (Operation was interrupted explicitly or by signal.)</li><li>-ETIMEDOUT (Timeout)</li></ul>
<br>
 <br>
 <a class="anchor" name="Send"></a> <b>Send, Sendto, Sendmsg</b> <br>
 These functions send out CAN messages. Only one message per call can be transmitted, so only one buffer with the correct length must be passed. For <code>SOCK_RAW</code>, this is the size of struct <a class="el" href="structcan__frame.html">can_frame</a>. <br>
 <br>
 The following only applies to <code>SOCK_RAW:</code> If a socket address of struct <a class="el" href="structsockaddr__can.html">sockaddr_can</a> is given, only <code>can_ifindex</code> is used. It is also possible to omit the socket address. Then the interface the socket is bound to will be used for sending messages. <br>
 <br>
 If an interface goes down (due to bus-off or setting of stop mode) all senders that were blocked on this interface will be woken up. <br>
 <br>
 <br>
 Supported Flags:<ul>
<li>MSG_DONTWAIT (By setting this flag the transmit operation will only succeed if it would not block. This flag takes precedence over a timeout specified by <a class="el" href="group__rtcan.html#ga43">RTCAN_RTIOC_SND_TIMEOUT</a>.)</li></ul>
Environments: RT (non-RT optional)<br>
 <br>
 Specific return values:<ul>
<li>Non-negative value equal to given buffer size (Indicating the successful completion of the function call. See also note.)</li><li>-EOPNOTSUPP (MSG_OOB flag is not supported.)</li><li>-EINVAL (Unsupported flag detected <em>or:</em> Invalid length of socket address <em>or:</em> Invalid address family <em>or:</em> Data length code of CAN frame not between 0 and 15 <em>or:</em> CAN standard frame has got an ID not between 0 and 2031)</li><li>-EMSGSIZE (Zero or more than one buffer passed or invalid size of buffer)</li><li>-EFAULT (It was not possible to access user space memory area at one of the specified addresses.)</li><li>-ENXIO (Invalid CAN interface index - <code>0</code> is not allowed here - or socket not bound or rather bound to all interfaces.)</li><li>-ENETDOWN (Controller is bus-off or in stopped state.)</li><li>-ECOMM (Controller is sleeping)</li><li>-EAGAIN (Cannot transmit without blocking but a non-blocking call was requested.)</li><li>-EINTR (Operation was interrupted explicitly or by signal)</li><li>-EBADF (Socket was closed.)</li><li>-ETIMEDOUT (Timeout)</li></ul>
<b>Note:</b> A successful completion of the function call does not implicate a successful transmission of the message. </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtcan_8h.html">rtcan.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real-Time Driver Model for RT-Socket-CAN, CAN device profile header. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__bittime__std.html">can_bittime_std</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard bit-time parameters according to Bosch.  <a href="structcan__bittime__std.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__bittime__btr.html">can_bittime_btr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hardware-specific BTR bit-times.  <a href="structcan__bittime__btr.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__bittime.html">can_bittime</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Custom CAN bit-time definition.  <a href="structcan__bittime.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__filter.html">can_filter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filter for reception of CAN messages.  <a href="structcan__filter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsockaddr__can.html">sockaddr_can</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket address structure for the CAN address family.  <a href="structsockaddr__can.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__frame.html">can_frame</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raw CAN frame.  <a href="structcan__frame.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>CAN ID masks</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="CAN_xxx_MASK"></a> Bit masks for masking CAN IDs <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga14" doxytag="rtcan::CAN_EFF_MASK"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga14">CAN_EFF_MASK</a>&nbsp;&nbsp;&nbsp;0x1FFFFFFF</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit mask for extended CAN IDs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga15" doxytag="rtcan::CAN_SFF_MASK"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga15">CAN_SFF_MASK</a>&nbsp;&nbsp;&nbsp;0x000007FF</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit mask for standard CAN IDs. <br></td></tr>
<tr><td colspan="2"><br><h2>CAN ID flags</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="CAN_xxx_FLAG"></a> Flags within a CAN ID indicating special CAN frame attributes <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga16" doxytag="rtcan::CAN_EFF_FLAG"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga16">CAN_EFF_FLAG</a>&nbsp;&nbsp;&nbsp;0x80000000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">extended frame <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga17" doxytag="rtcan::CAN_RTR_FLAG"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga17">CAN_RTR_FLAG</a>&nbsp;&nbsp;&nbsp;0x40000000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">remote transmission flag <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga18" doxytag="rtcan::CAN_ERR_FLAG"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga18">CAN_ERR_FLAG</a>&nbsp;&nbsp;&nbsp;0x20000000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">error frame (see <a class="el" href="group__rtcan.html#Errors">Errors</a>) <br></td></tr>
<tr><td colspan="2"><br><h2>CAN controller modes</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="CAN_CTRLMODE"></a> Special CAN controllers modes, which can be or'ed together. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga21" doxytag="rtcan::CAN_CTRLMODE_LISTENONLY"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga21">CAN_CTRLMODE_LISTENONLY</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Listen-Only mode. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga22" doxytag="rtcan::CAN_CTRLMODE_LOOPBACK"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga22">CAN_CTRLMODE_LOOPBACK</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loopback mode. <br></td></tr>
<tr><td colspan="2"><br><h2>Timestamp switches</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="RTCAN_TIMESTAMPS"></a> Arguments to pass to <a class="el" href="group__rtcan.html#ga41">RTCAN_RTIOC_TAKE_TIMESTAMP</a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga24" doxytag="rtcan::RTCAN_TAKE_NO_TIMESTAMPS"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga24">RTCAN_TAKE_NO_TIMESTAMPS</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch off taking timestamps. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga25" doxytag="rtcan::RTCAN_TAKE_TIMESTAMPS"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga25">RTCAN_TAKE_TIMESTAMPS</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do take timestamps. <br></td></tr>
<tr><td colspan="2"><br><h2>Timeouts</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="RTCAN_TIMEOUTS"></a> Special reception and transmission timeouts <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga26" doxytag="rtcan::RTCAN_TIMEOUT_INFINITE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga26">RTCAN_TIMEOUT_INFINITE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">wait for ever <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga27" doxytag="rtcan::RTCAN_TIMEOUT_NONE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga27">RTCAN_TIMEOUT_NONE</a>&nbsp;&nbsp;&nbsp;(-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">equivalent to non-blocking <br></td></tr>
<tr><td colspan="2"><br><h2>RAW socket options</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="Rawsockopts"></a> Setting and getting CAN RAW socket options. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga30">CAN_RAW_FILTER</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CAN filter definition.  <a href="#ga30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga31">CAN_RAW_ERR_FILTER</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CAN error mask.  <a href="#ga31"></a><br></td></tr>
<tr><td colspan="2"><br><h2>IOCTLs</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="IOCTLs"></a> CAN device IOCTLs <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga32">SIOCGIFINDEX</a>&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x00, struct ifreq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get CAN interface index by name.  <a href="#ga32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga33">SIOCSCANBAUDRATE</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x01, struct ifreq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set baud rate.  <a href="#ga33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga34">SIOCGCANBAUDRATE</a>&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x02, struct ifreq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get baud rate.  <a href="#ga34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga35">SIOCSCANCUSTOMBITTIME</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x03, struct ifreq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set custom bit time parameter.  <a href="#ga35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga36">SIOCGCANCUSTOMBITTIME</a>&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x04, struct ifreq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get custum bit-time parameters.  <a href="#ga36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga37">SIOCSCANMODE</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x05, struct ifreq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set operation mode of CAN controller.  <a href="#ga37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga38">SIOCGCANSTATE</a>&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x06, struct ifreq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current state of CAN controller.  <a href="#ga38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga39">SIOCSCANCTRLMODE</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x07, struct ifreq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set special controller modes.  <a href="#ga39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga40">SIOCGCANCTRLMODE</a>&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x08, struct ifreq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get special controller modes.  <a href="#ga40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga41">RTCAN_RTIOC_TAKE_TIMESTAMP</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x09, int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable storing a high precision timestamp upon reception of a CAN frame.  <a href="#ga41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga42">RTCAN_RTIOC_RCV_TIMEOUT</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x0A, nanosecs_rel_t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify a reception timeout for a socket.  <a href="#ga42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga43">RTCAN_RTIOC_SND_TIMEOUT</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x0B, nanosecs_rel_t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify a transmission timeout for a socket.  <a href="#ga43"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Error mask</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="Errors"></a> Error class (mask) in <code>can_id</code> field of struct <a class="el" href="structcan__frame.html">can_frame</a> to be used with <a class="el" href="group__rtcan.html#ga31">CAN_RAW_ERR_FILTER</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga45" doxytag="rtcan::CAN_ERR_TX_TIMEOUT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga45">CAN_ERR_TX_TIMEOUT</a>&nbsp;&nbsp;&nbsp;0x00000001U</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TX timeout (netdevice driver). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga46" doxytag="rtcan::CAN_ERR_LOSTARB"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga46">CAN_ERR_LOSTARB</a>&nbsp;&nbsp;&nbsp;0x00000002U</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lost arbitration (see <a class="el" href="group__rtcan.html#Error0">data[0]</a>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga47" doxytag="rtcan::CAN_ERR_CRTL"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga47">CAN_ERR_CRTL</a>&nbsp;&nbsp;&nbsp;0x00000004U</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Controller problems (see <a class="el" href="group__rtcan.html#Error1">data[1]</a>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga48" doxytag="rtcan::CAN_ERR_PROT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga48">CAN_ERR_PROT</a>&nbsp;&nbsp;&nbsp;0x00000008U</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Protocol violations (see <a class="el" href="group__rtcan.html#Error2">data[2]</a>, <a class="el" href="group__rtcan.html#Error3">data[3]</a>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga49" doxytag="rtcan::CAN_ERR_TRX"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga49">CAN_ERR_TRX</a>&nbsp;&nbsp;&nbsp;0x00000010U</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transceiver status (see <a class="el" href="group__rtcan.html#Error4">data[4]</a>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga50" doxytag="rtcan::CAN_ERR_ACK"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga50">CAN_ERR_ACK</a>&nbsp;&nbsp;&nbsp;0x00000020U</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Received no ACK on transmission. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga51" doxytag="rtcan::CAN_ERR_BUSOFF"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga51">CAN_ERR_BUSOFF</a>&nbsp;&nbsp;&nbsp;0x00000040U</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bus off. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga52" doxytag="rtcan::CAN_ERR_BUSERROR"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga52">CAN_ERR_BUSERROR</a>&nbsp;&nbsp;&nbsp;0x00000080U</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bus error (may flood!). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga53" doxytag="rtcan::CAN_ERR_RESTARTED"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga53">CAN_ERR_RESTARTED</a>&nbsp;&nbsp;&nbsp;0x00000100U</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Controller restarted. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga54" doxytag="rtcan::CAN_ERR_MASK"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga54">CAN_ERR_MASK</a>&nbsp;&nbsp;&nbsp;0x1FFFFFFFU</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Omit EFF, RTR, ERR flags. <br></td></tr>
<tr><td colspan="2"><br><h2>Arbitration lost error</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="Error0"></a> Error in the data[0] field of struct <a class="el" href="structcan__frame.html">can_frame</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga55" doxytag="rtcan::CAN_ERR_LOSTARB_UNSPEC"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga55">CAN_ERR_LOSTARB_UNSPEC</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">else bit number in bitstream <br></td></tr>
<tr><td colspan="2"><br><h2>Controller problems</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="Error1"></a> Error in the data[1] field of struct <a class="el" href="structcan__frame.html">can_frame</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga56" doxytag="rtcan::CAN_ERR_CRTL_UNSPEC"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga56">CAN_ERR_CRTL_UNSPEC</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unspecified <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga57" doxytag="rtcan::CAN_ERR_CRTL_RX_OVERFLOW"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga57">CAN_ERR_CRTL_RX_OVERFLOW</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RX buffer overflow. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga58" doxytag="rtcan::CAN_ERR_CRTL_TX_OVERFLOW"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga58">CAN_ERR_CRTL_TX_OVERFLOW</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TX buffer overflow. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga59" doxytag="rtcan::CAN_ERR_CRTL_RX_WARNING"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga59">CAN_ERR_CRTL_RX_WARNING</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reached warning level for RX errors <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga60" doxytag="rtcan::CAN_ERR_CRTL_TX_WARNING"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga60">CAN_ERR_CRTL_TX_WARNING</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reached warning level for TX errors <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga61" doxytag="rtcan::CAN_ERR_CRTL_RX_PASSIVE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga61">CAN_ERR_CRTL_RX_PASSIVE</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reached passive level for RX errors <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga62" doxytag="rtcan::CAN_ERR_CRTL_TX_PASSIVE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga62">CAN_ERR_CRTL_TX_PASSIVE</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reached passive level for TX errors <br></td></tr>
<tr><td colspan="2"><br><h2>Protocoll error type</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="Error2"></a> Error in the data[2] field of struct <a class="el" href="structcan__frame.html">can_frame</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga63" doxytag="rtcan::CAN_ERR_PROT_UNSPEC"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga63">CAN_ERR_PROT_UNSPEC</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unspecified <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga64" doxytag="rtcan::CAN_ERR_PROT_BIT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga64">CAN_ERR_PROT_BIT</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">single bit error <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga65" doxytag="rtcan::CAN_ERR_PROT_FORM"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga65">CAN_ERR_PROT_FORM</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">frame format error <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga66" doxytag="rtcan::CAN_ERR_PROT_STUFF"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga66">CAN_ERR_PROT_STUFF</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bit stuffing error <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga67" doxytag="rtcan::CAN_ERR_PROT_BIT0"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga67">CAN_ERR_PROT_BIT0</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unable to send dominant bit <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga68" doxytag="rtcan::CAN_ERR_PROT_BIT1"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga68">CAN_ERR_PROT_BIT1</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unable to send recessive bit <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga69" doxytag="rtcan::CAN_ERR_PROT_OVERLOAD"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga69">CAN_ERR_PROT_OVERLOAD</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bus overload <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga70" doxytag="rtcan::CAN_ERR_PROT_ACTIVE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga70">CAN_ERR_PROT_ACTIVE</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">active error announcement <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga71" doxytag="rtcan::CAN_ERR_PROT_TX"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga71">CAN_ERR_PROT_TX</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">error occured on transmission <br></td></tr>
<tr><td colspan="2"><br><h2>Protocoll error location</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="Error3"></a> Error in the data[3] field of struct <a class="el" href="structcan__frame.html">can_frame</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga72" doxytag="rtcan::CAN_ERR_PROT_LOC_UNSPEC"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga72">CAN_ERR_PROT_LOC_UNSPEC</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unspecified <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga73" doxytag="rtcan::CAN_ERR_PROT_LOC_SOF"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga73">CAN_ERR_PROT_LOC_SOF</a>&nbsp;&nbsp;&nbsp;0x03</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">start of frame <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga74" doxytag="rtcan::CAN_ERR_PROT_LOC_ID28_21"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga74">CAN_ERR_PROT_LOC_ID28_21</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID bits 28 - 21 (SFF: 10 - 3). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga75" doxytag="rtcan::CAN_ERR_PROT_LOC_ID20_18"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga75">CAN_ERR_PROT_LOC_ID20_18</a>&nbsp;&nbsp;&nbsp;0x06</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID bits 20 - 18 (SFF: 2 - 0 ). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga76" doxytag="rtcan::CAN_ERR_PROT_LOC_SRTR"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga76">CAN_ERR_PROT_LOC_SRTR</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">substitute RTR (SFF: RTR) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga77" doxytag="rtcan::CAN_ERR_PROT_LOC_IDE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga77">CAN_ERR_PROT_LOC_IDE</a>&nbsp;&nbsp;&nbsp;0x05</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">identifier extension <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga78" doxytag="rtcan::CAN_ERR_PROT_LOC_ID17_13"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga78">CAN_ERR_PROT_LOC_ID17_13</a>&nbsp;&nbsp;&nbsp;0x07</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID bits 17-13. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga79" doxytag="rtcan::CAN_ERR_PROT_LOC_ID12_05"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga79">CAN_ERR_PROT_LOC_ID12_05</a>&nbsp;&nbsp;&nbsp;0x0F</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID bits 12-5. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga80" doxytag="rtcan::CAN_ERR_PROT_LOC_ID04_00"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga80">CAN_ERR_PROT_LOC_ID04_00</a>&nbsp;&nbsp;&nbsp;0x0E</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID bits 4-0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga81" doxytag="rtcan::CAN_ERR_PROT_LOC_RTR"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga81">CAN_ERR_PROT_LOC_RTR</a>&nbsp;&nbsp;&nbsp;0x0C</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RTR. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga82" doxytag="rtcan::CAN_ERR_PROT_LOC_RES1"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga82">CAN_ERR_PROT_LOC_RES1</a>&nbsp;&nbsp;&nbsp;0x0D</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reserved bit 1 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga83" doxytag="rtcan::CAN_ERR_PROT_LOC_RES0"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga83">CAN_ERR_PROT_LOC_RES0</a>&nbsp;&nbsp;&nbsp;0x09</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reserved bit 0 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga84" doxytag="rtcan::CAN_ERR_PROT_LOC_DLC"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga84">CAN_ERR_PROT_LOC_DLC</a>&nbsp;&nbsp;&nbsp;0x0B</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">data length code <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga85" doxytag="rtcan::CAN_ERR_PROT_LOC_DATA"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga85">CAN_ERR_PROT_LOC_DATA</a>&nbsp;&nbsp;&nbsp;0x0A</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">data section <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga86" doxytag="rtcan::CAN_ERR_PROT_LOC_CRC_SEQ"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga86">CAN_ERR_PROT_LOC_CRC_SEQ</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CRC sequence. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga87" doxytag="rtcan::CAN_ERR_PROT_LOC_CRC_DEL"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga87">CAN_ERR_PROT_LOC_CRC_DEL</a>&nbsp;&nbsp;&nbsp;0x18</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CRC delimiter. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga88" doxytag="rtcan::CAN_ERR_PROT_LOC_ACK"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga88">CAN_ERR_PROT_LOC_ACK</a>&nbsp;&nbsp;&nbsp;0x19</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ACK slot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga89" doxytag="rtcan::CAN_ERR_PROT_LOC_ACK_DEL"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga89">CAN_ERR_PROT_LOC_ACK_DEL</a>&nbsp;&nbsp;&nbsp;0x1B</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ACK delimiter. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga90" doxytag="rtcan::CAN_ERR_PROT_LOC_EOF"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga90">CAN_ERR_PROT_LOC_EOF</a>&nbsp;&nbsp;&nbsp;0x1A</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">end of frame <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga91" doxytag="rtcan::CAN_ERR_PROT_LOC_INTERM"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga91">CAN_ERR_PROT_LOC_INTERM</a>&nbsp;&nbsp;&nbsp;0x12</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">intermission <br></td></tr>
<tr><td colspan="2"><br><h2>Protocoll error location</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="Error4"></a> Error in the data[4] field of struct <a class="el" href="structcan__frame.html">can_frame</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga92" doxytag="rtcan::CAN_ERR_TRX_UNSPEC"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga92">CAN_ERR_TRX_UNSPEC</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0000 0000 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga93" doxytag="rtcan::CAN_ERR_TRX_CANH_NO_WIRE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga93">CAN_ERR_TRX_CANH_NO_WIRE</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0000 0100 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga94" doxytag="rtcan::CAN_ERR_TRX_CANH_SHORT_TO_BAT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga94">CAN_ERR_TRX_CANH_SHORT_TO_BAT</a>&nbsp;&nbsp;&nbsp;0x05</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0000 0101 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga95" doxytag="rtcan::CAN_ERR_TRX_CANH_SHORT_TO_VCC"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga95">CAN_ERR_TRX_CANH_SHORT_TO_VCC</a>&nbsp;&nbsp;&nbsp;0x06</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0000 0110 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga96" doxytag="rtcan::CAN_ERR_TRX_CANH_SHORT_TO_GND"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga96">CAN_ERR_TRX_CANH_SHORT_TO_GND</a>&nbsp;&nbsp;&nbsp;0x07</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0000 0111 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga97" doxytag="rtcan::CAN_ERR_TRX_CANL_NO_WIRE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga97">CAN_ERR_TRX_CANL_NO_WIRE</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0100 0000 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga98" doxytag="rtcan::CAN_ERR_TRX_CANL_SHORT_TO_BAT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga98">CAN_ERR_TRX_CANL_SHORT_TO_BAT</a>&nbsp;&nbsp;&nbsp;0x50</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0101 0000 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga99" doxytag="rtcan::CAN_ERR_TRX_CANL_SHORT_TO_VCC"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga99">CAN_ERR_TRX_CANL_SHORT_TO_VCC</a>&nbsp;&nbsp;&nbsp;0x60</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0110 0000 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga100" doxytag="rtcan::CAN_ERR_TRX_CANL_SHORT_TO_GND"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga100">CAN_ERR_TRX_CANL_SHORT_TO_GND</a>&nbsp;&nbsp;&nbsp;0x70</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0111 0000 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga101" doxytag="rtcan::CAN_ERR_TRX_CANL_SHORT_TO_CANH"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga101">CAN_ERR_TRX_CANL_SHORT_TO_CANH</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">1000 0000 <br></td></tr>
<tr><td colspan="2"><br><h2>Types of time values</h2></td></tr>
<tr><td colspan="2">Absolute and relative time values <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga10" doxytag="rtcan::nanosecs_rel_t"></a>
typedef int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga10">nanosecs_rel_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Representing a relative time in nanoseconds. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga11" doxytag="rtcan::nanosecs_abs_t"></a>
typedef uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga11">nanosecs_abs_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Representing an absolute time in nanoseconds. <br></td></tr>
<tr><td colspan="2"><br><h2>CAN protocols</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="CAN_PROTO"></a> Possible protocols for PF_CAN protocol family <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga102">CAN_PROTO</a> { <a class="el" href="group__rtcan.html#gga102a102">CAN_PROTO_RAW</a>
 }</td></tr>

<tr><td colspan="2"><br><h2>CAN operation modes</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="CAN_MODE"></a> Modes into which CAN controllers can be set <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga104">CAN_MODE</a> { <a class="el" href="group__rtcan.html#gga104a106">CAN_MODE_STOP</a> =  0, 
<a class="el" href="group__rtcan.html#gga104a107">CAN_MODE_START</a>, 
<a class="el" href="group__rtcan.html#gga104a108">CAN_MODE_SLEEP</a>
 }</td></tr>

<tr><td colspan="2"><br><h2>CAN controller states</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="CAN_STATE"></a> States a CAN controller can be in. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga105">CAN_STATE</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__rtcan.html#gga105a109">CAN_STATE_ACTIVE</a> =  0, 
<a class="el" href="group__rtcan.html#gga105a110">CAN_STATE_BUS_WARNING</a>, 
<a class="el" href="group__rtcan.html#gga105a111">CAN_STATE_BUS_PASSIVE</a>, 
<a class="el" href="group__rtcan.html#gga105a112">CAN_STATE_BUS_OFF</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__rtcan.html#gga105a113">CAN_STATE_SCANNING_BAUDRATE</a>, 
<a class="el" href="group__rtcan.html#gga105a114">CAN_STATE_STOPPED</a>, 
<a class="el" href="group__rtcan.html#gga105a115">CAN_STATE_SLEEPING</a>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga12" doxytag="rtcan::AF_CAN"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga12">AF_CAN</a>&nbsp;&nbsp;&nbsp;29</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CAN address family. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga13" doxytag="rtcan::PF_CAN"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga13">PF_CAN</a>&nbsp;&nbsp;&nbsp;AF_CAN</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CAN protocol family. <br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga0" doxytag="rtcan::can_id_t"></a>
typedef uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga0">can_id_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of CAN id (see <a class="el" href="group__rtcan.html#CAN_xxx_MASK">CAN_xxx_MASK</a> and <a class="el" href="group__rtcan.html#CAN_xxx_FLAG">CAN_xxx_FLAG</a>). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga2" doxytag="rtcan::can_err_mask_t"></a>
typedef <a class="el" href="group__rtcan.html#ga0">can_id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga2">can_err_mask_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of CAN error mask. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga3" doxytag="rtcan::can_baudrate_t"></a>
typedef uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga3">can_baudrate_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Baudrate definition in bits per second. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga4" doxytag="rtcan::can_bittime_type_t"></a>
typedef enum <a class="el" href="group__rtcan.html#ga103">CAN_BITTIME_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga4">can_bittime_type_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="group__rtcan.html#ga103">CAN_BITTIME_TYPE</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga5" doxytag="rtcan::can_mode_t"></a>
typedef enum <a class="el" href="group__rtcan.html#ga104">CAN_MODE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga5">can_mode_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="group__rtcan.html#CAN_MODE">CAN_MODE</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga6" doxytag="rtcan::can_ctrlmode_t"></a>
typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga6">can_ctrlmode_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="group__rtcan.html#CAN_CTRLMODE">CAN_CTRLMODE</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga7" doxytag="rtcan::can_state_t"></a>
typedef enum <a class="el" href="group__rtcan.html#ga105">CAN_STATE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga7">can_state_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="group__rtcan.html#CAN_STATE">CAN_STATE</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structcan__filter.html">can_filter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga8">can_filter_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filter for reception of CAN messages.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structcan__frame.html">can_frame</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga9">can_frame_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raw CAN frame.  <a href="#ga9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga103">CAN_BITTIME_TYPE</a> { <a class="el" href="group__rtcan.html#gga103a104">CAN_BITTIME_STD</a>, 
<a class="el" href="group__rtcan.html#gga103a105">CAN_BITTIME_BTR</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supported CAN bit-time types.  <a href="group__rtcan.html#ga103">More...</a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ga31" doxytag="rtcan.h::CAN_RAW_ERR_FILTER"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define CAN_RAW_ERR_FILTER&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
CAN error mask. 
<p>
A CAN error mask (see <a class="el" href="group__rtcan.html#Errors">Errors</a>) can be set with <code>setsockopt</code>. This mask is then used to decided if error frames are send to this socket in case of error condidtions. The error frames are marked with the <a class="el" href="group__rtcan.html#ga18">CAN_ERR_FLAG</a> of <a class="el" href="group__rtcan.html#CAN_xxx_FLAG">CAN_xxx_FLAG</a> and must be handled by the application properly. A detailed description of the error can be found in the <code>can_id</code> and the <code>data</code> fields of struct <a class="el" href="structcan__frame.html">can_frame</a> (see <a class="el" href="group__rtcan.html#Errors">Errors</a> for futher details).<p>
<br>
 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><b>SOL_CAN_RAW</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>CAN_RAW_ERR_FILTER</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to error mask of type can_err_mask_t.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>Size of error mask: sizeof(can_err_mask_t).</td></tr>
  </table>
</dl>
Environments: non-RT (RT optional)<br>
 <br>
 Specific return values:<ul>
<li>-EFAULT (It was not possible to access user space memory area at the specified address.)</li><li>-ENOMEM (Not enough memory to fulfill the operation)</li><li>-EINVAL (Invalid address family, or invalid length of address structure)</li><li>-ENODEV (Invalid CAN interface index)</li><li>-EBADF (Socket is about to be closed)</li><li>-EAGAIN (Too many receivers. Old binding (if any) is still active. Close some sockets and try again.)</li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="ga30" doxytag="rtcan.h::CAN_RAW_FILTER"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define CAN_RAW_FILTER&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
CAN filter definition. 
<p>
A CAN raw filter list with elements of struct <a class="el" href="structcan__filter.html">can_filter</a> can be installed with <code>setsockopt</code>. This list is used upon reception of CAN frames to decide whether the bound socket will receive a frame. <br>
 If the socket was already bound with <a class="el" href="group__rtcan.html#Bind">Bind</a>, the old filter list gets replaced with the new one. Be aware that already received, but not read out CAN frames may stay in the socket buffer. <br>
 <br>
 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><b>SOL_CAN_RAW</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>CAN_RAW_FILTER</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to array of struct <a class="el" href="structcan__filter.html">can_filter</a>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>Size of filter list: count * sizeof( struct can_filter). <br>
 Environments: non-RT (RT optional)<br>
 <br>
 Specific return values:<ul>
<li>-EFAULT (It was not possible to access user space memory area at the specified address.)</li><li>-ENOMEM (Not enough memory to fulfill the operation)</li><li>-EINVAL (Invalid address family, or invalid length of address structure)</li><li>-ENODEV (Invalid CAN interface index)</li><li>-EBADF (Socket is about to be closed)</li><li>-EAGAIN (Too many receivers. Old binding (if any) is still active. Close some sockets and try again.)</li></ul>
</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga42" doxytag="rtcan.h::RTCAN_RTIOC_RCV_TIMEOUT"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define RTCAN_RTIOC_RCV_TIMEOUT&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x0A, nanosecs_rel_t)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specify a reception timeout for a socket. 
<p>
Defines a timeout for all receive operations via a socket which will take effect when one of the <a class="el" href="group__rtcan.html#Recv">receive functions</a> is called without the <code>MSG_DONTWAIT</code> flag set.<p>
The default value for a newly created socket is an infinite timeout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to <a class="el" href="group__rtcan.html#ga10">nanosecs_rel_t</a> variable. The value is interpreted as relative timeout in nanoseconds in case of a positive value. See <a class="el" href="group__rtcan.html#RTCAN_TIMEOUTS">Timeouts</a> for special timeouts.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li></ul>
</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga43" doxytag="rtcan.h::RTCAN_RTIOC_SND_TIMEOUT"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define RTCAN_RTIOC_SND_TIMEOUT&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x0B, nanosecs_rel_t)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specify a transmission timeout for a socket. 
<p>
Defines a timeout for all send operations via a socket which will take effect when one of the <a class="el" href="group__rtcan.html#Send">send functions</a> is called without the <code>MSG_DONTWAIT</code> flag set.<p>
The default value for a newly created socket is an infinite timeout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to <a class="el" href="group__rtcan.html#ga10">nanosecs_rel_t</a> variable. The value is interpreted as relative timeout in nanoseconds in case of a positive value. See <a class="el" href="group__rtcan.html#RTCAN_TIMEOUTS">Timeouts</a> for special timeouts.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li></ul>
</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga41" doxytag="rtcan.h::RTCAN_RTIOC_TAKE_TIMESTAMP"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define RTCAN_RTIOC_TAKE_TIMESTAMP&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x09, int)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable or disable storing a high precision timestamp upon reception of a CAN frame. 
<p>
A newly created socket takes no timestamps by default.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>int variable, see <a class="el" href="group__rtcan.html#RTCAN_TIMESTAMPS">Timestamp switches</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Activating taking timestamps only has an effect on newly received CAN messages from the bus. Frames that already are in the socket buffer do not have timestamps if it was deactivated before. See <a class="el" href="group__rtcan.html#Recv">Receive</a> for more details.</dd></dl>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga34" doxytag="rtcan.h::SIOCGCANBAUDRATE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define SIOCGCANBAUDRATE&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x02, struct ifreq)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get baud rate. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> will be filled with an instance of <a class="el" href="group__rtcan.html#ga3">can_baudrate_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li><li>-ENODEV: No device with specified name exists.</li><li>-EINVAL: No baud rate was set yet.</li></ul>
</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga40" doxytag="rtcan.h::SIOCGCANCTRLMODE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define SIOCGCANCTRLMODE&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x08, struct ifreq)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get special controller modes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtcan.html#ga6">can_ctrlmode_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li><li>-ENODEV: No device with specified name exists.</li><li>-EINVAL: No baud rate was set yet.</li></ul>
</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga36" doxytag="rtcan.h::SIOCGCANCUSTOMBITTIME"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define SIOCGCANCUSTOMBITTIME&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x04, struct ifreq)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get custum bit-time parameters. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> will be filled with an instance of struct <a class="el" href="structcan__bittime.html">can_bittime</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li><li>-ENODEV: No device with specified name exists.</li><li>-EINVAL: No baud rate was set yet.</li></ul>
</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga38" doxytag="rtcan.h::SIOCGCANSTATE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define SIOCGCANSTATE&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x06, struct ifreq)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get current state of CAN controller. 
<p>
States are divided into main states and additional error indicators. A CAN controller is always in exactly one main state. CAN bus errors are registered by the CAN hardware and collected by the driver. There is one error indicator (bit) per error type. If this IOCTL is triggered the error types which occured since the last call of this IOCTL are reported and thereafter the error indicators are cleared. See also <a class="el" href="group__rtcan.html#CAN_STATE">CAN controller states</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> will be filled with an instance of <a class="el" href="group__rtcan.html#ga5">can_mode_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li><li>-ENODEV: No device with specified name exists.</li></ul>
</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga32" doxytag="rtcan.h::SIOCGIFINDEX"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define SIOCGIFINDEX&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x00, struct ifreq)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get CAN interface index by name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). If <code>ifr_name</code> holds a valid CAN interface name <code>ifr_ifindex</code> will be filled with the corresponding interface index.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li><li>-ENODEV: No device with specified name exists.</li></ul>
</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga33" doxytag="rtcan.h::SIOCSCANBAUDRATE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define SIOCSCANBAUDRATE&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x01, struct ifreq)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set baud rate. 
<p>
The baudrate must be specified in bits per second. The driver will try to calculate resonable CAN bit-timing parameters. You can use <a class="el" href="group__rtcan.html#ga35">SIOCSCANCUSTOMBITTIME</a> to set custom bit-timing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtcan.html#ga3">can_baudrate_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li><li>-ENODEV: No device with specified name exists.</li><li>-EINVAL: No valid baud rate, see <a class="el" href="group__rtcan.html#ga3">can_baudrate_t</a>.</li><li>-EDOM : Baud rate not possible.</li><li>-EAGAIN: Request could not be successully fulfilled. Try again.</li></ul>
</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Setting the baud rate is a configuration task. It should be done deliberately or otherwise CAN messages will likely be lost.</dd></dl>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga39" doxytag="rtcan.h::SIOCSCANCTRLMODE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define SIOCSCANCTRLMODE&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x07, struct ifreq)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set special controller modes. 
<p>
Various special controller modes could be or'ed together (see <a class="el" href="group__rtcan.html#CAN_CTRLMODE">CAN_CTRLMODE</a> for further information).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtcan.html#ga6">can_ctrlmode_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li><li>-ENODEV: No device with specified name exists.</li><li>-EINVAL: No valid baud rate, see <a class="el" href="group__rtcan.html#ga3">can_baudrate_t</a>.</li><li>-EAGAIN: Request could not be successully fulfilled. Try again.</li></ul>
</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Setting specia controlelr modes is a configuration task. It should be done deliberately or otherwise CAN messages will likely be lost.</dd></dl>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga35" doxytag="rtcan.h::SIOCSCANCUSTOMBITTIME"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define SIOCSCANCUSTOMBITTIME&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x03, struct ifreq)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set custom bit time parameter. 
<p>
Custem-bit time could be defined in various formats (see struct <a class="el" href="structcan__bittime.html">can_bittime</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of struct <a class="el" href="structcan__bittime.html">can_bittime</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li><li>-ENODEV: No device with specified name exists.</li><li>-EINVAL: No valid baud rate, see <a class="el" href="group__rtcan.html#ga3">can_baudrate_t</a>.</li><li>-EAGAIN: Request could not be successully fulfilled. Try again.</li></ul>
</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Setting the bit-time is a configuration task. It should be done deliberately or otherwise CAN messages will likely be lost.</dd></dl>
Rescheduling: possible.     </td>
  </tr>
</table>
<a class="anchor" name="ga37" doxytag="rtcan.h::SIOCSCANMODE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define SIOCSCANMODE&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x05, struct ifreq)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set operation mode of CAN controller. 
<p>
See <a class="el" href="group__rtcan.html#CAN_MODE">CAN controller modes</a> for available modes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtcan.html#ga5">can_mode_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li><li>-ENODEV: No device with specified name exists.</li><li>-EAGAIN: (<a class="el" href="group__rtcan.html#gga104a107">CAN_MODE_START</a>, <a class="el" href="group__rtcan.html#gga104a106">CAN_MODE_STOP</a>) Could not successfully set mode, hardware is busy. Try again.</li><li>-EINVAL: (<a class="el" href="group__rtcan.html#gga104a107">CAN_MODE_START</a>) Cannot start controller, set baud rate first.</li><li>-ENETDOWN: (<a class="el" href="group__rtcan.html#gga104a108">CAN_MODE_SLEEP</a>) Cannot go into sleep mode because controller is stopped or bus off.</li><li>-EOPNOTSUPP: unknown mode</li></ul>
</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Setting a CAN controller into normal operation after a bus-off can take some time (128 occurrences of 11 consecutive recessive bits). In such a case, although this IOCTL will return immediately with success and <a class="el" href="group__rtcan.html#ga38">SIOCGCANSTATE</a> will report <a class="el" href="group__rtcan.html#gga105a109">CAN_STATE_ACTIVE</a>, bus-off recovery may still be in progress. <br>
 If a controller is bus-off, setting it into stop mode will return no error but the controller remains bus-off.</dd></dl>
Rescheduling: possible.     </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga8" doxytag="rtcan.h::can_filter_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct <a class="el" href="structcan__filter.html">can_filter</a>  <a class="el" href="structcan__filter.html">can_filter_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Filter for reception of CAN messages. 
<p>
This filter works as follows: A received CAN ID is AND'ed bitwise with <code>can_mask</code> and then compared to <code>can_id</code>. If this comparison is true the message will be received by the socket.<p>
Multiple filters can be arranged in a filter list and set with <a class="el" href="group__rtcan.html#Sockopts">Sockopts</a>. If one of these filters matches a CAN ID upon reception of a CAN frame, this frame is accepted.<p>
<dl compact><dt><b>Note:</b></dt><dd>Only <a class="el" href="group__rtcan.html#ga16">CAN_EFF_FLAG</a> of <a class="el" href="group__rtcan.html#CAN_xxx_FLAG">CAN ID flags</a> is valid for <code>can_id</code> and none for <code>can_mask</code>. This means that the RTR bit is not taken into account while filtering messages.</dd></dl>
Extended IDs are received only if <a class="el" href="group__rtcan.html#ga16">CAN_EFF_FLAG</a> is set in <code>can_id</code>. If it is cleared only standard IDs are accepted.     </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="rtcan.h::can_frame_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct <a class="el" href="structcan__frame.html">can_frame</a>  <a class="el" href="structcan__frame.html">can_frame_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Raw CAN frame. 
<p>
Central structure for receiving and sending CAN frames.     </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ga103" doxytag="rtcan.h::CAN_BITTIME_TYPE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__rtcan.html#ga103">CAN_BITTIME_TYPE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Supported CAN bit-time types. 
<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga103a104" doxytag="CAN_BITTIME_STD"></a>CAN_BITTIME_STD</em>&nbsp;</td><td>
Standard bit-time definition according to Bosch. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga103a105" doxytag="CAN_BITTIME_BTR"></a>CAN_BITTIME_BTR</em>&nbsp;</td><td>
Hardware-specific BTR bit-time definition. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga104" doxytag="rtcan.h::CAN_MODE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__rtcan.html#ga104">CAN_MODE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga104a106" doxytag="CAN_MODE_STOP"></a>CAN_MODE_STOP</em>&nbsp;</td><td>
Set controller in Stop mode (no reception / transmission possible). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga104a107" doxytag="CAN_MODE_START"></a>CAN_MODE_START</em>&nbsp;</td><td>
Set controller into normal operation. <br>
 Coming from stopped mode or bus off, the controller begins with no errors in <a class="el" href="group__rtcan.html#gga105a109">CAN_STATE_ACTIVE</a>. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga104a108" doxytag="CAN_MODE_SLEEP"></a>CAN_MODE_SLEEP</em>&nbsp;</td><td>
Set controller into Sleep mode. <br>
 This is only possible if the controller is not stopped or bus-off. <br>
 Notice that sleep mode will only be entered when there is no bus activity. If the controller detects bus activity while "sleeping" it will go into operating mode again. <br>
 To actively leave sleep mode again trigger <code>CAN_MODE_START</code>. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga102" doxytag="rtcan.h::CAN_PROTO"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__rtcan.html#ga102">CAN_PROTO</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga102a102" doxytag="CAN_PROTO_RAW"></a>CAN_PROTO_RAW</em>&nbsp;</td><td>
Raw protocol of <code>PF_CAN</code>, applicable to socket type <code>SOCK_RAW</code>. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga105" doxytag="rtcan.h::CAN_STATE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__rtcan.html#ga105">CAN_STATE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga105a109" doxytag="CAN_STATE_ACTIVE"></a>CAN_STATE_ACTIVE</em>&nbsp;</td><td>
CAN controller is error active. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga105a110" doxytag="CAN_STATE_BUS_WARNING"></a>CAN_STATE_BUS_WARNING</em>&nbsp;</td><td>
CAN controller is error active, warning level is reached. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga105a111" doxytag="CAN_STATE_BUS_PASSIVE"></a>CAN_STATE_BUS_PASSIVE</em>&nbsp;</td><td>
CAN controller is error passive. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga105a112" doxytag="CAN_STATE_BUS_OFF"></a>CAN_STATE_BUS_OFF</em>&nbsp;</td><td>
CAN controller went into Bus Off. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga105a113" doxytag="CAN_STATE_SCANNING_BAUDRATE"></a>CAN_STATE_SCANNING_BAUDRATE</em>&nbsp;</td><td>
CAN controller is scanning to get the baudrate. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga105a114" doxytag="CAN_STATE_STOPPED"></a>CAN_STATE_STOPPED</em>&nbsp;</td><td>
CAN controller is in stopped mode. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga105a115" doxytag="CAN_STATE_SLEEPING"></a>CAN_STATE_SLEEPING</em>&nbsp;</td><td>
CAN controller is in Sleep mode. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sun Aug 13 11:47:53 2006 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
