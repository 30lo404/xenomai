<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai: Semaphores services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Semaphores services.</h1>  </div>
</div>
<div class="contents">

<p>Semaphores services.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__sem.html#ga9bcb1f6b8ca3695c4add766167f94c57">sem_destroy</a> (struct __shadow_sem *sm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy an unnamed semaphore.  <a href="#ga9bcb1f6b8ca3695c4add766167f94c57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sem_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__sem.html#gad935e509cd7f0d2792d08ec83077ca85">sem_open</a> (const char *name, int oflags,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a named semaphore.  <a href="#gad935e509cd7f0d2792d08ec83077ca85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__sem.html#gafdc90cf3d1da895f92a0f58aa1d33437">sem_close</a> (struct __shadow_sem *sm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a named semaphore.  <a href="#gafdc90cf3d1da895f92a0f58aa1d33437"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__sem.html#ga776256d1a473906f8b7490689bfcb75c">sem_unlink</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlink a named semaphore.  <a href="#ga776256d1a473906f8b7490689bfcb75c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__sem.html#gab4b51aa432b9ec35bd3279b8bb0459d4">sem_trywait</a> (cobalt_sem_t *sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to decrement a semaphore.  <a href="#gab4b51aa432b9ec35bd3279b8bb0459d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__sem.html#gac3fc4dcd95ac278047b5fba6fb4c0593">sem_wait</a> (cobalt_sem_t *sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrement a semaphore.  <a href="#gac3fc4dcd95ac278047b5fba6fb4c0593"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__sem.html#ga949c09e76e07dbee909d11e521c1d334">sem_timedwait</a> (cobalt_sem_t *sem, const struct timespec *abs_timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt, during a bounded time, to decrement a semaphore.  <a href="#ga949c09e76e07dbee909d11e521c1d334"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__sem.html#ga1a8968c239e3085d93835b4d5885ee1b">sem_post</a> (cobalt_sem_t *sm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post a semaphore.  <a href="#ga1a8968c239e3085d93835b4d5885ee1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__sem.html#ga3abc08c4656eb03156dbabdb0c492fee">sem_getvalue</a> (cobalt_sem_t *sem, int *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of a semaphore.  <a href="#ga3abc08c4656eb03156dbabdb0c492fee"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Semaphores services. </p>
<p>Semaphores are counters for resources shared between threads. The basic operations on semaphores are: increment the counter atomically, and wait until the counter is non-null and decrement it atomically.</p>
<p>Semaphores have a maximum value past which they cannot be incremented. The macro <em>SEM_VALUE_MAX</em> is defined to be this maximum value. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gafdc90cf3d1da895f92a0f58aa1d33437"></a><!-- doxytag: member="sem.c::sem_close" ref="gafdc90cf3d1da895f92a0f58aa1d33437" args="(struct __shadow_sem *sm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_close </td>
          <td>(</td>
          <td class="paramtype">struct __shadow_sem *&nbsp;</td>
          <td class="paramname"> <em>sm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a named semaphore. </p>
<p>This service closes the semaphore <em>sm</em>. The semaphore is destroyed only when unlinked with a call to the <a class="el" href="group__cobalt__sem.html#ga776256d1a473906f8b7490689bfcb75c" title="Unlink a named semaphore.">sem_unlink()</a> service and when each call to <a class="el" href="group__cobalt__sem.html#gad935e509cd7f0d2792d08ec83077ca85" title="Open a named semaphore.">sem_open()</a> matches a call to this service.</p>
<p>When a semaphore is destroyed, the memory it used is returned to the system heap, so that further references to this semaphore are not guaranteed to fail, as is the case for unnamed semaphores.</p>
<p>This service fails if <em>sm</em> is an unnamed semaphore.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm</em>&nbsp;</td><td>the semaphore to be closed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>EINVAL, the semaphore <em>sm</em> is invalid or is an unnamed semaphore.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_close.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9bcb1f6b8ca3695c4add766167f94c57"></a><!-- doxytag: member="sem.c::sem_destroy" ref="ga9bcb1f6b8ca3695c4add766167f94c57" args="(struct __shadow_sem *sm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int sem_destroy </td>
          <td>(</td>
          <td class="paramtype">struct __shadow_sem *&nbsp;</td>
          <td class="paramname"> <em>sm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy an unnamed semaphore. </p>
<p>This service destroys the semaphore <em>sm</em>. Threads currently blocked on <em>sm</em> are unblocked and the service they called return -1 with <em>errno</em> set to EINVAL. The semaphore is then considered invalid by all semaphore services (they all fail with <em>errno</em> set to EINVAL) except sem_init().</p>
<p>This service fails if <em>sm</em> is a named semaphore.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm</em>&nbsp;</td><td>the semaphore to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>always</em>&nbsp;</td><td>0 on success if SEM_WARNDEL was not mentioned via sem_init_np(). If SEM_WARNDEL was mentioned, then a strictly positive value is returned to warn the caller if threads were pending on the semaphore, or zero otherwise.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>EINVAL, the semaphore <em>sm</em> is invalid or a named semaphore;</li>
<li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_destroy.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3abc08c4656eb03156dbabdb0c492fee"></a><!-- doxytag: member="sem.c::sem_getvalue" ref="ga3abc08c4656eb03156dbabdb0c492fee" args="(cobalt_sem_t *sem, int *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_getvalue </td>
          <td>(</td>
          <td class="paramtype">cobalt_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the value of a semaphore. </p>
<p>This service stores at the address <em>value</em>, the current count of the semaphore <em>sm</em>. The state of the semaphore is unchanged.</p>
<p>If the semaphore is currently fully depleted, the value stored is zero, unless SEM_REPORT was mentioned for a non-standard semaphore (see sem_init_np()), in which case the current number of waiters is returned as the semaphore's negative value (e.g. -2 would mean the semaphore is fully depleted AND two threads are currently pending on it).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>a semaphore;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>address where the semaphore count will be stored on success.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>EINVAL, the semaphore is invalid or uninitialized;</li>
<li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_getvalue.html">Specification.</a> </dd></dl>

<p>Referenced by <a class="el" href="group__cobalt__time.html#ga8260c4071d25fcddae4192a72605570b">timer_create()</a>.</p>

</div>
</div>
<a class="anchor" id="gad935e509cd7f0d2792d08ec83077ca85"></a><!-- doxytag: member="sem.c::sem_open" ref="gad935e509cd7f0d2792d08ec83077ca85" args="(const char *name, int oflags,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sem_t* sem_open </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>oflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a named semaphore. </p>
<p>This service establishes a connection between the semaphore named <em>name</em> and the calling context (kernel-space as a whole, or user-space process).</p>
<p>If no semaphore named <em>name</em> exists and <em>oflags</em> has the <em>O_CREAT</em> bit set, the semaphore is created by this function, using two more arguments:</p>
<ul>
<li>a <em>mode</em> argument, of type <b>mode_t</b>, currently ignored;</li>
<li>a <em>value</em> argument, of type <b>unsigned</b>, specifying the initial value of the created semaphore.</li>
</ul>
<p>If <em>oflags</em> has the two bits <em>O_CREAT</em> and <em>O_EXCL</em> set and the semaphore already exists, this service fails.</p>
<p><em>name</em> may be any arbitrary string, in which slashes have no particular meaning. However, for portability, using a name which starts with a slash and contains no other slash is recommended.</p>
<p>If <a class="el" href="group__cobalt__sem.html#gad935e509cd7f0d2792d08ec83077ca85" title="Open a named semaphore.">sem_open()</a> is called from the same context (kernel-space as a whole, or user-space process) several times with the same value of <em>name</em>, the same address is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the semaphore to be created;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oflags</em>&nbsp;</td><td>flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the address of the named semaphore on success; </dd>
<dd>
SEM_FAILED with <em>errno</em> set if:<ul>
<li>ENAMETOOLONG, the length of the <em>name</em> argument exceeds 64 characters;</li>
<li>EEXIST, the bits <em>O_CREAT</em> and <em>O_EXCL</em> were set in <em>oflags</em> and the named semaphore already exists;</li>
<li>ENOENT, the bit <em>O_CREAT</em> is not set in <em>oflags</em> and the named semaphore does not exist;</li>
<li>ENOSPC, insufficient memory exists in the system heap to create the semaphore, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li>
<li>EINVAL, the <em>value</em> argument exceeds <em>SEM_VALUE_MAX</em>.</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_open.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a8968c239e3085d93835b4d5885ee1b"></a><!-- doxytag: member="sem.c::sem_post" ref="ga1a8968c239e3085d93835b4d5885ee1b" args="(cobalt_sem_t *sm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int sem_post </td>
          <td>(</td>
          <td class="paramtype">cobalt_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Post a semaphore. </p>
<p>This service posts the semaphore <em>sm</em>.</p>
<p>If no thread is currently blocked on this semaphore, its count is incremented unless "pulse" mode is enabled for it (see sem_init_np(), SEM_PULSE). If a thread is blocked on the semaphore, the thread heading the wait queue is unblocked.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm</em>&nbsp;</td><td>the semaphore to be signaled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with errno set if:</p>
<ul>
<li>EINVAL, the specified semaphore is invalid or uninitialized;</li>
<li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process;</li>
<li>EAGAIN, the semaphore count is <em>SEM_VALUE_MAX</em>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_post.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga949c09e76e07dbee909d11e521c1d334"></a><!-- doxytag: member="sem.c::sem_timedwait" ref="ga949c09e76e07dbee909d11e521c1d334" args="(cobalt_sem_t *sem, const struct timespec *abs_timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int sem_timedwait </td>
          <td>(</td>
          <td class="paramtype">cobalt_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&nbsp;</td>
          <td class="paramname"> <em>abs_timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt, during a bounded time, to decrement a semaphore. </p>
<p>This service is equivalent to <a class="el" href="group__cobalt__sem.html#gac3fc4dcd95ac278047b5fba6fb4c0593" title="Decrement a semaphore.">sem_wait()</a>, except that the caller is only blocked until the timeout <em>abs_timeout</em> expires.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>the semaphore to be decremented;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>abs_timeout</em>&nbsp;</td><td>the timeout, expressed as an absolute value of the relevant clock for the semaphore, either CLOCK_MONOTONIC if SEM_RAWCLOCK was mentioned via sem_init_np(), or CLOCK_REALTIME otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>EPERM, the caller context is invalid;</li>
<li>EINVAL, the semaphore is invalid or uninitialized;</li>
<li>EINVAL, the specified timeout is invalid;</li>
<li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process;</li>
<li>EINTR, the caller was interrupted by a signal while blocked in this service;</li>
<li>ETIMEDOUT, the semaphore could not be decremented and the specified timeout expired.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread,</li>
<li>Xenomai user-space thread (switches to primary mode).</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_timedwait.html">Specification.</a> </dd></dl>

<p>Referenced by <a class="el" href="group__rtdmsync.html#ga8aadb120a93df5dfd717c5bac6d4c1a9">rtdm_sem_timeddown()</a>.</p>

</div>
</div>
<a class="anchor" id="gab4b51aa432b9ec35bd3279b8bb0459d4"></a><!-- doxytag: member="sem.c::sem_trywait" ref="gab4b51aa432b9ec35bd3279b8bb0459d4" args="(cobalt_sem_t *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int sem_trywait </td>
          <td>(</td>
          <td class="paramtype">cobalt_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to decrement a semaphore. </p>
<p>This service is equivalent to <a class="el" href="group__cobalt__sem.html#gac3fc4dcd95ac278047b5fba6fb4c0593" title="Decrement a semaphore.">sem_wait()</a>, except that it returns immediately if the semaphore <em>sm</em> is currently depleted, and that it is not a cancellation point.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>the semaphore to be decremented.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>EINVAL, the specified semaphore is invalid or uninitialized;</li>
<li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process;</li>
<li>EAGAIN, the specified semaphore is currently fully depleted.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>* </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_trywait.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga776256d1a473906f8b7490689bfcb75c"></a><!-- doxytag: member="sem.c::sem_unlink" ref="ga776256d1a473906f8b7490689bfcb75c" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_unlink </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlink a named semaphore. </p>
<p>This service unlinks the semaphore named <em>name</em>. This semaphore is not destroyed until all references obtained with <a class="el" href="group__cobalt__sem.html#gad935e509cd7f0d2792d08ec83077ca85" title="Open a named semaphore.">sem_open()</a> are closed by calling <a class="el" href="group__cobalt__sem.html#gafdc90cf3d1da895f92a0f58aa1d33437" title="Close a named semaphore.">sem_close()</a>. However, the unlinked semaphore may no longer be reached with the <a class="el" href="group__cobalt__sem.html#gad935e509cd7f0d2792d08ec83077ca85" title="Open a named semaphore.">sem_open()</a> service.</p>
<p>When a semaphore is destroyed, the memory it used is returned to the system heap, so that further references to this semaphore are not guaranteed to fail, as is the case for unnamed semaphores.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the semaphore to be unlinked.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>ENAMETOOLONG, the length of the <em>name</em> argument exceeds 64 characters;</li>
<li>ENOENT, the named semaphore does not exist.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_unlink.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac3fc4dcd95ac278047b5fba6fb4c0593"></a><!-- doxytag: member="sem.c::sem_wait" ref="gac3fc4dcd95ac278047b5fba6fb4c0593" args="(cobalt_sem_t *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int sem_wait </td>
          <td>(</td>
          <td class="paramtype">cobalt_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrement a semaphore. </p>
<p>This service decrements the semaphore <em>sm</em> if it is currently if its value is greater than 0. If the semaphore's value is currently zero, the calling thread is suspended until the semaphore is posted, or a signal is delivered to the calling thread.</p>
<p>This service is a cancellation point for Xenomai POSIX skin threads (created with the <a class="el" href="group__cobalt__thread.html#ga3832074a8217566e79b476a964c7eb25" title="Create a thread.">pthread_create()</a> service). When such a thread is cancelled while blocked in a call to this service, the semaphore state is left unchanged before the cancellation cleanup handlers are called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>the semaphore to be decremented.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>EPERM, the caller context is invalid;</li>
<li>EINVAL, the semaphore is invalid or uninitialized;</li>
<li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process;</li>
<li>EINTR, the caller was interrupted by a signal while blocked in this service.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread,</li>
<li>Xenomai user-space thread (switches to primary mode).</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_wait.html">Specification.</a> </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jan 5 2012 10:14:30 for Xenomai by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
