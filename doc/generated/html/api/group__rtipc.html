<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Real-time IPC protocols</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Real-time IPC protocols<br>
<small>
[<a class="el" href="group__profiles.html">Device Profiles</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Real-time IPC protocols:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__rtipc.png" border="0" alt="" usemap="#group____rtipc_map">
<map name="group____rtipc_map">
<area shape="rect" href="group__profiles.html" title="Device Profiles" alt="" coords="5,5,120,32"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<b>Profile</b> <b>Revision:</b> 1 <br>
 <br>
 
<p>
<dl class="user" compact><dt><b>Device Characteristics</b></dt><dd><br>
 <a class="el" href="structrtdm__device.html#f459bf86f0d037c99bb669f627d78764">Device Flags</a>: <code>RTDM_PROTOCOL_DEVICE</code> <br>
 <br>
 <a class="el" href="structrtdm__device.html#e58c050e09a79b277f718d796eda2072">Protocol Family</a>: <code>PF_RTIPC</code> <br>
 <br>
 <a class="el" href="structrtdm__device.html#02552f2d91052bd801576b3a132ba3f9">Socket Type</a>: <code>SOCK_DGRAM</code> <br>
 <br>
 <a class="el" href="structrtdm__device.html#94aa3100258b43c812c5240b55777f07">Device Class</a>: <code>RTDM_CLASS_RTIPC</code> <br>
 <br>
 </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtipc_8h.html">rtipc.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the Xenomai project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtipc__port__label.html">rtipc_port_label</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Port label information structure.  <a href="structrtipc__port__label.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsockaddr__ipc.html">sockaddr_ipc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket address structure for the RTIPC address family.  <a href="structsockaddr__ipc.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>RTIPC protocol list</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="RTIPC_PROTO"></a> protocols for the PF_RTIPC protocol family <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a259a5b551f46faa3b63b002fdde789e2ba">IPCPROTO_IPC</a> =  0, 
<a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a2528a488c3e7fc47dee4d5757f215f62e9">IPCPROTO_XDDP</a> =  1, 
<a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a257f1e80711306177a6f5d48031efe0080">IPCPROTO_IDDP</a> =  2, 
<a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a25fb2400ca0886ef0a4eff1328afd92c18">IPCPROTO_BUFP</a> =  3
 }</td></tr>

<tr><td colspan="2"><br><h2>Supported operations</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="rtipc_operations"></a> Standard socket operations supported by the RTIPC protocols. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g77d456500c719b5ac81b051cb957f581">socket__AF_RTIPC</a> (int domain=AF_RTIPC, int type=SOCK_DGRAM, int protocol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an endpoint for communication in the AF_RTIPC domain.  <a href="#g77d456500c719b5ac81b051cb957f581"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g446307f82b9d1e3464a852984bc875bc">close__AF_RTIPC</a> (int sockfd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a RTIPC socket descriptor.  <a href="#g446307f82b9d1e3464a852984bc875bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g6f0c6f408fc0dee63c39393c42572d11">bind__AF_RTIPC</a> (int sockfd, const struct <a class="el" href="structsockaddr__ipc.html">sockaddr_ipc</a> *addr, socklen_t addrlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind a RTIPC socket to a port.  <a href="#g6f0c6f408fc0dee63c39393c42572d11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g61bb0c8ac9896f5b8d56b18163fa5bf0">connect__AF_RTIPC</a> (int sockfd, const struct <a class="el" href="structsockaddr__ipc.html">sockaddr_ipc</a> *addr, socklen_t addrlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiate a connection on a RTIPC socket.  <a href="#g61bb0c8ac9896f5b8d56b18163fa5bf0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#gd529c20d5d8d9660703759f0eb109a67">setsockopt__AF_RTIPC</a> (int sockfd, int level, int optname, const void *optval, socklen_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set options on RTIPC sockets.  <a href="#gd529c20d5d8d9660703759f0eb109a67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g26876fedfc5b831c9d49c630650f5bc6">getsockopt__AF_RTIPC</a> (int sockfd, int level, int optname, void *optval, socklen_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get options on RTIPC sockets.  <a href="#g26876fedfc5b831c9d49c630650f5bc6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#gb77f8a835dd741535882e2e50126b0af">sendmsg__AF_RTIPC</a> (int sockfd, const struct msghdr *msg, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message on a RTIPC socket.  <a href="#gb77f8a835dd741535882e2e50126b0af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g69ad5e9d75282d13e69ba2c472ea4ed0">recvmsg__AF_RTIPC</a> (int sockfd, struct msghdr *msg, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message from a RTIPC socket.  <a href="#g69ad5e9d75282d13e69ba2c472ea4ed0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#gd24c6013d32d57b90c392993a1118385">getsockname__AF_RTIPC</a> (int sockfd, struct <a class="el" href="structsockaddr__ipc.html">sockaddr_ipc</a> *addr, socklen_t *addrlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get socket name.  <a href="#gd24c6013d32d57b90c392993a1118385"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g620af595b33bbc2284f86ee25b8759dd">getpeername__AF_RTIPC</a> (int sockfd, struct <a class="el" href="structsockaddr__ipc.html">sockaddr_ipc</a> *addr, socklen_t *addrlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get socket peer.  <a href="#g620af595b33bbc2284f86ee25b8759dd"></a><br></td></tr>
<tr><td colspan="2"><br><h2>XDDP socket options</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="sockopts_xddp"></a> Setting and getting XDDP socket options. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#gf8b123d7b54c95dd655b8a3b02d2759f">XDDP_LABEL</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XDDP label assignment.  <a href="#gf8b123d7b54c95dd655b8a3b02d2759f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g40cc2513c4beb830fe3af2c205292d27">XDDP_POOLSZ</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XDDP local pool size configuration.  <a href="#g40cc2513c4beb830fe3af2c205292d27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g61a2c99e1588e761aff890c27df6e5bd">XDDP_BUFSZ</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XDDP streaming buffer size configuration.  <a href="#g61a2c99e1588e761aff890c27df6e5bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g6330fd82333ff062b27fb7ab7bce499e">XDDP_MONITOR</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XDDP monitoring callback.  <a href="#g6330fd82333ff062b27fb7ab7bce499e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>XDDP events</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="XDDP_EVENTS"></a> Specific events occurring on XDDP channels, which can be monitored via the <a class="el" href="group__rtipc.html#g6330fd82333ff062b27fb7ab7bce499e">XDDP_MONITOR</a> socket option. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#gbfefbb6b077a725dab659af9efcf3967">XDDP_EVTIN</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__rtipc.html#g6330fd82333ff062b27fb7ab7bce499e">Monitor</a> writes to the non real-time endpoint.  <a href="#gbfefbb6b077a725dab659af9efcf3967"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g3526c0440d308aee62e603b819ecd8f7">XDDP_EVTOUT</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__rtipc.html#g6330fd82333ff062b27fb7ab7bce499e">Monitor</a> reads from the non real-time endpoint.  <a href="#g3526c0440d308aee62e603b819ecd8f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g6a7b8aa43efe65c79ec692b716202666">XDDP_EVTDOWN</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__rtipc.html#g6330fd82333ff062b27fb7ab7bce499e">Monitor</a> close from the non real-time endpoint.  <a href="#g6a7b8aa43efe65c79ec692b716202666"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g218c2d5522d38235e44094ac229a6f09">XDDP_EVTNOBUF</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__rtipc.html#g6330fd82333ff062b27fb7ab7bce499e">Monitor</a> memory shortage for non real-time datagrams.  <a href="#g218c2d5522d38235e44094ac229a6f09"></a><br></td></tr>
<tr><td colspan="2"><br><h2>IDDP socket options</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="sockopts_iddp"></a> Setting and getting IDDP socket options. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#gc62cba4b02621f8536f5d4d3f9d993bd">IDDP_LABEL</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IDDP label assignment.  <a href="#gc62cba4b02621f8536f5d4d3f9d993bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g458014cc6cab9854202a0852a9f00c39">IDDP_POOLSZ</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IDDP local pool size configuration.  <a href="#g458014cc6cab9854202a0852a9f00c39"></a><br></td></tr>
<tr><td colspan="2"><br><h2>BUFP socket options</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="sockopts_bufp"></a> Setting and getting BUFP socket options. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g0ff681be80a29ba24d5d591ca5dd6fca">BUFP_LABEL</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BUFP label assignment.  <a href="#g0ff681be80a29ba24d5d591ca5dd6fca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#g5bbbae934f8a7f982e94ed310ed9a364">BUFP_BUFSZ</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BUFP buffer size configuration.  <a href="#g5bbbae934f8a7f982e94ed310ed9a364"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Socket level options</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="sockopts_socket"></a> Setting and getting supported standard socket level options. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#gb9d2f7ca5c94bd51cdab3e1913b66e2d">SO_SNDTIMEO</a>&nbsp;&nbsp;&nbsp;defined_by_kernel_header_file</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a257f1e80711306177a6f5d48031efe0080">IPCPROTO_IDDP</a> and <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a25fb2400ca0886ef0a4eff1328afd92c18">IPCPROTO_BUFP</a> protocols support the standard SO_SNDTIMEO socket option, from the <code>SOL_SOCKET</code> level.  <a href="#gb9d2f7ca5c94bd51cdab3e1913b66e2d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#gf2d1ed6a34336a6f3df80fb518325846">SO_RCVTIMEO</a>&nbsp;&nbsp;&nbsp;defined_by_kernel_header_file</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All RTIPC protocols support the standard SO_RCVTIMEO socket option, from the <code>SOL_SOCKET</code> level.  <a href="#gf2d1ed6a34336a6f3df80fb518325846"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gca557a3fe7881593a440c797c94cd19a"></a><!-- doxytag: member="rtipc::rtipc_port_t" ref="gca557a3fe7881593a440c797c94cd19a" args="" -->
typedef int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtipc.html#gca557a3fe7881593a440c797c94cd19a">rtipc_port_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Port number type for the RTIPC address family. <br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g5bbbae934f8a7f982e94ed310ed9a364"></a><!-- doxytag: member="rtipc.h::BUFP_BUFSZ" ref="g5bbbae934f8a7f982e94ed310ed9a364" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFP_BUFSZ&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
BUFP buffer size configuration. 
<p>
All messages written to a BUFP socket are buffered in a single per-socket memory area. Configuring the size of such buffer prior to binding the socket to a destination port is mandatory.<p>
It is not allowed to configure a buffer size after the socket was bound. However, multiple configuration calls are allowed prior to the binding; the last value set will be used.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>: the buffer memory is obtained from the host allocator by the <a class="el" href="group__rtipc.html#g6f0c6f408fc0dee63c39393c42572d11">bind call</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="group__rtipc.html#sockopts_bufp">SOL_BUFP</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>BUFP_BUFSZ</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to a variable of type size_t, containing the required size of the buffer to reserve at binding time </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>sizeof(size_t)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT (Invalid data address given)</li><li>-EALREADY (socket already bound)</li><li>-EINVAL (<em>optlen</em> is invalid or *<em>optval</em> is zero)</li></ul>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="bufp-label_8c-example.html#a3">bufp-label.c</a>, and <a class="el" href="bufp-readwrite_8c-example.html#a2">bufp-readwrite.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="g0ff681be80a29ba24d5d591ca5dd6fca"></a><!-- doxytag: member="rtipc.h::BUFP_LABEL" ref="g0ff681be80a29ba24d5d591ca5dd6fca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFP_LABEL&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
BUFP label assignment. 
<p>
ASCII label strings can be attached to BUFP ports, in order to connect sockets to them in a more descriptive way than using plain numeric port values.<p>
When available, this label will be registered when binding, in addition to the port number (see <a class="el" href="group__rtipc.html#bufp_label_binding">BUFP port binding</a>).<p>
It is not allowed to assign a label after the socket was bound. However, multiple assignment calls are allowed prior to the binding; the last label set will be used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="group__rtipc.html#sockopts_bufp">SOL_BUFP</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>BUFP_LABEL</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to struct <a class="el" href="structrtipc__port__label.html" title="Port label information structure.">rtipc_port_label</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>sizeof(struct rtipc_port_label)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT (Invalid data address given)</li><li>-EALREADY (socket already bound)</li><li>-EINVAL (<em>optlen</em> is invalid)</li></ul>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="bufp-label_8c-example.html#a4">bufp-label.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="gc62cba4b02621f8536f5d4d3f9d993bd"></a><!-- doxytag: member="rtipc.h::IDDP_LABEL" ref="gc62cba4b02621f8536f5d4d3f9d993bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IDDP_LABEL&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
IDDP label assignment. 
<p>
ASCII label strings can be attached to IDDP ports, in order to connect sockets to them in a more descriptive way than using plain numeric port values.<p>
When available, this label will be registered when binding, in addition to the port number (see <a class="el" href="group__rtipc.html#iddp_label_binding">IDDP port binding</a>).<p>
It is not allowed to assign a label after the socket was bound. However, multiple assignment calls are allowed prior to the binding; the last label set will be used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="group__rtipc.html#sockopts_iddp">SOL_IDDP</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>IDDP_LABEL</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to struct <a class="el" href="structrtipc__port__label.html" title="Port label information structure.">rtipc_port_label</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>sizeof(struct rtipc_port_label)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT (Invalid data address given)</li><li>-EALREADY (socket already bound)</li><li>-EINVAL (<em>optlen</em> is invalid)</li></ul>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="iddp-label_8c-example.html#a3">iddp-label.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="g458014cc6cab9854202a0852a9f00c39"></a><!-- doxytag: member="rtipc.h::IDDP_POOLSZ" ref="g458014cc6cab9854202a0852a9f00c39" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IDDP_POOLSZ&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
IDDP local pool size configuration. 
<p>
By default, the memory needed to convey the data is pulled from Xenomai's system pool. Setting a local pool size overrides this default for the socket.<p>
If a non-zero size was configured, a local pool is allocated at binding time. This pool will provide storage for pending datagrams.<p>
It is not allowed to configure a local pool size after the socket was bound. However, multiple configuration calls are allowed prior to the binding; the last value set will be used.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>: the pool memory is obtained from the host allocator by the <a class="el" href="group__rtipc.html#g6f0c6f408fc0dee63c39393c42572d11">bind call</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="group__rtipc.html#sockopts_iddp">SOL_IDDP</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>IDDP_POOLSZ</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to a variable of type size_t, containing the required size of the local pool to reserve at binding time </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>sizeof(size_t)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT (Invalid data address given)</li><li>-EALREADY (socket already bound)</li><li>-EINVAL (<em>optlen</em> is invalid or *<em>optval</em> is zero)</li></ul>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="iddp-sendrecv_8c-example.html#a2">iddp-sendrecv.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="gf2d1ed6a34336a6f3df80fb518325846"></a><!-- doxytag: member="rtipc.h::SO_RCVTIMEO" ref="gf2d1ed6a34336a6f3df80fb518325846" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SO_RCVTIMEO&nbsp;&nbsp;&nbsp;defined_by_kernel_header_file          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All RTIPC protocols support the standard SO_RCVTIMEO socket option, from the <code>SOL_SOCKET</code> level. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><code>setsockopt()</code>, <code>getsockopt()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399/">http://www.opengroup.org/onlinepubs/009695399/</a> </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="xddp-label_8c-example.html#a4">xddp-label.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="gb9d2f7ca5c94bd51cdab3e1913b66e2d"></a><!-- doxytag: member="rtipc.h::SO_SNDTIMEO" ref="gb9d2f7ca5c94bd51cdab3e1913b66e2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SO_SNDTIMEO&nbsp;&nbsp;&nbsp;defined_by_kernel_header_file          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a257f1e80711306177a6f5d48031efe0080">IPCPROTO_IDDP</a> and <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a25fb2400ca0886ef0a4eff1328afd92c18">IPCPROTO_BUFP</a> protocols support the standard SO_SNDTIMEO socket option, from the <code>SOL_SOCKET</code> level. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><code>setsockopt()</code>, <code>getsockopt()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399/">http://www.opengroup.org/onlinepubs/009695399/</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g61a2c99e1588e761aff890c27df6e5bd"></a><!-- doxytag: member="rtipc.h::XDDP_BUFSZ" ref="g61a2c99e1588e761aff890c27df6e5bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDDP_BUFSZ&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XDDP streaming buffer size configuration. 
<p>
In addition to sending datagrams, real-time threads may stream data in a byte-oriented mode through the port as well. This increases the bandwidth and reduces the overhead, when the overall data to send to the Linux domain is collected by bits, and keeping the message boundaries is not required.<p>
This feature is enabled when a non-zero buffer size is set for the socket. In that case, the real-time data accumulates into the streaming buffer when MSG_MORE is passed to any of the <a class="el" href="group__rtipc.html#gb77f8a835dd741535882e2e50126b0af">send functions</a>, until:<p>
<ul>
<li>the receiver from the Linux domain wakes up and consumes it,</li><li>a different source port attempts to send data to the same destination port,</li><li>MSG_MORE is absent from the send flags,</li><li>the buffer is full,</li></ul>
whichever comes first.<p>
Setting *<em>optval</em> to zero disables the streaming buffer, in which case all sendings are conveyed in separate datagrams, regardless of MSG_MORE.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>only a single streaming buffer exists per socket. When this buffer is full, the real-time data stops accumulating and sending operations resume in mere datagram mode. Accumulation may happen again after some or all data in the streaming buffer is consumed from the Linux domain endpoint.</dd></dl>
The streaming buffer size may be adjusted multiple times during the socket lifetime; the latest configuration change will take effect when the accumulation resumes after the previous buffer was flushed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="group__rtipc.html#sockopts_xddp">SOL_XDDP</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>XDDP_BUFSZ</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to a variable of type size_t, containing the required size of the streaming buffer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>sizeof(size_t)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT (Invalid data address given)</li><li>-ENOMEM (Not enough memory)</li><li>-EINVAL (<em>optlen</em> is invalid)</li></ul>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="xddp-stream_8c-example.html#a2">xddp-stream.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="g6a7b8aa43efe65c79ec692b716202666"></a><!-- doxytag: member="rtipc.h::XDDP_EVTDOWN" ref="g6a7b8aa43efe65c79ec692b716202666" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDDP_EVTDOWN&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="group__rtipc.html#g6330fd82333ff062b27fb7ab7bce499e">Monitor</a> close from the non real-time endpoint. 
<p>
XDDP_EVTDOWN is sent when the non real-time endpoint is closed. The argument is always 0. 
</div>
</div><p>
<a class="anchor" name="gbfefbb6b077a725dab659af9efcf3967"></a><!-- doxytag: member="rtipc.h::XDDP_EVTIN" ref="gbfefbb6b077a725dab659af9efcf3967" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDDP_EVTIN&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="group__rtipc.html#g6330fd82333ff062b27fb7ab7bce499e">Monitor</a> writes to the non real-time endpoint. 
<p>
XDDP_EVTIN is sent when data is written to the non real-time endpoint the socket is bound to (i.e. via /dev/rtp<em>N</em>), which means that some input is pending for the real-time endpoint. The argument is the size of the incoming message. 
</div>
</div><p>
<a class="anchor" name="g218c2d5522d38235e44094ac229a6f09"></a><!-- doxytag: member="rtipc.h::XDDP_EVTNOBUF" ref="g218c2d5522d38235e44094ac229a6f09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDDP_EVTNOBUF&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="group__rtipc.html#g6330fd82333ff062b27fb7ab7bce499e">Monitor</a> memory shortage for non real-time datagrams. 
<p>
XDDP_EVTNOBUF is sent when no memory is available from the pool to hold the message currently sent from the non real-time endpoint. The argument is the size of the failed allocation. Upon return from the callback, the caller will block and retry until enough space is available from the pool; during that process, the callback might be invoked multiple times, each time a new attempt to get the required memory fails. 
</div>
</div><p>
<a class="anchor" name="g3526c0440d308aee62e603b819ecd8f7"></a><!-- doxytag: member="rtipc.h::XDDP_EVTOUT" ref="g3526c0440d308aee62e603b819ecd8f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDDP_EVTOUT&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="group__rtipc.html#g6330fd82333ff062b27fb7ab7bce499e">Monitor</a> reads from the non real-time endpoint. 
<p>
XDDP_EVTOUT is sent when the non real-time endpoint successfully reads a complete message (i.e. via /dev/rtp<em>N</em>). The argument is the size of the outgoing message. 
</div>
</div><p>
<a class="anchor" name="gf8b123d7b54c95dd655b8a3b02d2759f"></a><!-- doxytag: member="rtipc.h::XDDP_LABEL" ref="gf8b123d7b54c95dd655b8a3b02d2759f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDDP_LABEL&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XDDP label assignment. 
<p>
ASCII label strings can be attached to XDDP ports, so that opening the non-RT endpoint can be done by specifying this symbolic device name rather than referring to a raw pseudo-device entry (i.e. /dev/rtp<em>N</em>).<p>
When available, this label will be registered when binding, in addition to the port number (see <a class="el" href="group__rtipc.html#xddp_label_binding">XDDP port binding</a>).<p>
It is not allowed to assign a label after the socket was bound. However, multiple assignment calls are allowed prior to the binding; the last label set will be used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="group__rtipc.html#sockopts_xddp">SOL_XDDP</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>XDDP_LABEL</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to struct <a class="el" href="structrtipc__port__label.html" title="Port label information structure.">rtipc_port_label</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>sizeof(struct rtipc_port_label)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT (Invalid data address given)</li><li>-EALREADY (socket already bound)</li><li>-EINVAL (<em>optlen</em> invalid)</li></ul>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="xddp-label_8c-example.html#a3">xddp-label.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="g6330fd82333ff062b27fb7ab7bce499e"></a><!-- doxytag: member="rtipc.h::XDDP_MONITOR" ref="g6330fd82333ff062b27fb7ab7bce499e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDDP_MONITOR&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XDDP monitoring callback. 
<p>
Other RTDM drivers may install a user-defined callback via the <a class="el" href="group__interdrv.html#g681bc2eeba278b66803c18ca5ea539d7">rtdm_setsockopt</a> call from the inter-driver API, in order to collect particular events occurring on the channel.<p>
This notification mechanism is particularly useful to monitor a channel asynchronously while performing other tasks.<p>
The user-provided routine will be passed the RTDM file descriptor of the socket receiving the event, the event code, and an optional argument. Four events are currently defined, see <a class="el" href="group__rtipc.html#XDDP_EVENTS">XDDP_EVENTS</a>.<p>
The XDDP_EVTIN and XDDP_EVTOUT events are fired on behalf of a fully atomic context; therefore, care must be taken to keep their overhead low. In those cases, the Xenomai services that may be called from the callback are restricted to the set allowed to a real-time interrupt handler.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="group__rtipc.html#sockopts_xddp">SOL_XDDP</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>XDDP_MONITOR</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to a pointer to function of type int (*)(int fd, int event, long arg), containing the address of the user-defined callback.Passing a NULL callback pointer in <em>optval</em> disables monitoring. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>sizeof(int (*)(int fd, int event, long arg))</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT (Invalid data address given)</li><li>-EPERM (Operation not allowed from user-space)</li><li>-EINVAL (<em>optlen</em> is invalid)</li></ul>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT, kernel space only </dd></dl>

</div>
</div><p>
<a class="anchor" name="g40cc2513c4beb830fe3af2c205292d27"></a><!-- doxytag: member="rtipc.h::XDDP_POOLSZ" ref="g40cc2513c4beb830fe3af2c205292d27" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDDP_POOLSZ&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XDDP local pool size configuration. 
<p>
By default, the memory needed to convey the data is pulled from Xenomai's system pool. Setting a local pool size overrides this default for the socket.<p>
If a non-zero size was configured, a local pool is allocated at binding time. This pool will provide storage for pending datagrams.<p>
It is not allowed to configure a local pool size after the socket was bound. However, multiple configuration calls are allowed prior to the binding; the last value set will be used.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>: the pool memory is obtained from the host allocator by the <a class="el" href="group__rtipc.html#g6f0c6f408fc0dee63c39393c42572d11">bind call</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="group__rtipc.html#sockopts_xddp">SOL_XDDP</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>XDDP_POOLSZ</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to a variable of type size_t, containing the required size of the local pool to reserve at binding time </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>sizeof(size_t)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT (Invalid data address given)</li><li>-EALREADY (socket already bound)</li><li>-EINVAL (<em>optlen</em> invalid or *<em>optval</em> is zero)</li></ul>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="xddp-echo_8c-example.html#a2">xddp-echo.c</a>.</dl>
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="gba01db17f4a2bfbc3db60dc172972a25"></a><!-- doxytag: member="rtipc.h::@15" ref="gba01db17f4a2bfbc3db60dc172972a25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggba01db17f4a2bfbc3db60dc172972a259a5b551f46faa3b63b002fdde789e2ba"></a><!-- doxytag: member="IPCPROTO_IPC" ref="ggba01db17f4a2bfbc3db60dc172972a259a5b551f46faa3b63b002fdde789e2ba" args="" -->IPCPROTO_IPC</em>&nbsp;</td><td>
Default protocol (IDDP). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggba01db17f4a2bfbc3db60dc172972a2528a488c3e7fc47dee4d5757f215f62e9"></a><!-- doxytag: member="IPCPROTO_XDDP" ref="ggba01db17f4a2bfbc3db60dc172972a2528a488c3e7fc47dee4d5757f215f62e9" args="" -->IPCPROTO_XDDP</em>&nbsp;</td><td>
Cross-domain datagram protocol (RT &lt;-&gt; non-RT). 
<p>
Real-time Xenomai threads and regular Linux threads may want to exchange data in a way that does not require the former to leave the real-time domain (i.e. secondary mode). The RTDM-based XDDP protocol is available for this purpose.<p>
On the Linux domain side, pseudo-device files named /dev/rtp<em>&lt;minor&gt;</em> give regular POSIX threads access to non real-time communication endpoints, via the standard character-based I/O interface. On the Xenomai domain side, sockets may be bound to XDDP ports, which act as proxies to send and receive data to/from the associated pseudo-device files. Ports and pseudo-device minor numbers are paired, meaning that e.g. port 7 will proxy the traffic to/from /dev/rtp7.<p>
All data sent through a bound/connected XDDP socket via <code>sendto(2)</code> or <code>write(2)</code> will be passed to the peer endpoint in the Linux domain, and made available for reading via the standard <code>read(2)</code> system call. Conversely, all data sent using <code>write(2)</code> through the non real-time endpoint will be conveyed to the real-time socket endpoint, and made available to the <code>recvfrom(2)</code> or <code>read(2)</code> system calls. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggba01db17f4a2bfbc3db60dc172972a257f1e80711306177a6f5d48031efe0080"></a><!-- doxytag: member="IPCPROTO_IDDP" ref="ggba01db17f4a2bfbc3db60dc172972a257f1e80711306177a6f5d48031efe0080" args="" -->IPCPROTO_IDDP</em>&nbsp;</td><td>
Intra-domain datagram protocol (RT &lt;-&gt; RT). 
<p>
The RTDM-based IDDP protocol enables real-time threads to exchange datagrams within the Xenomai domain, via socket endpoints. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggba01db17f4a2bfbc3db60dc172972a25fb2400ca0886ef0a4eff1328afd92c18"></a><!-- doxytag: member="IPCPROTO_BUFP" ref="ggba01db17f4a2bfbc3db60dc172972a25fb2400ca0886ef0a4eff1328afd92c18" args="" -->IPCPROTO_BUFP</em>&nbsp;</td><td>
Buffer protocol (RT &lt;-&gt; RT, byte-oriented). 
<p>
The RTDM-based BUFP protocol implements a lightweight, byte-oriented, one-way Producer-Consumer data path. All messages written are buffered into a single memory area in strict FIFO order, until read by the consumer.<p>
This protocol always prevents short writes, and only allows short reads when a potential deadlock situation arises (i.e. readers and writers waiting for each other indefinitely). </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g6f0c6f408fc0dee63c39393c42572d11"></a><!-- doxytag: member="rtipc.h::bind__AF_RTIPC" ref="g6f0c6f408fc0dee63c39393c42572d11" args="(int sockfd, const struct sockaddr_ipc *addr, socklen_t addrlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bind__AF_RTIPC           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsockaddr__ipc.html">sockaddr_ipc</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&nbsp;</td>
          <td class="paramname"> <em>addrlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind a RTIPC socket to a port. 
<p>
Bind the socket to a destination port.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>The address to bind the socket to (see struct <a class="el" href="structsockaddr__ipc.html" title="Socket address structure for the RTIPC address family.">sockaddr_ipc</a>). The meaning of such address depends on the RTIPC protocol in use for the socket:</td></tr>
  </table>
</dl>
<ul>
<li>IPCPROTO_XDDP</li></ul>
<p>
This action creates an endpoint for channelling traffic between the Xenomai and Linux domains.<p>
<em>sipc_family</em> must be AF_RTIPC, <em>sipc_port</em> is either -1, or a valid free port number between 0 and CONFIG_XENO_OPT_PIPE_NRDEV-1.<p>
If <em>sipc_port</em> is -1, a free port will be assigned automatically.<p>
Upon success, the pseudo-device /dev/rtp<em>N</em> will be reserved for this communication channel, where <em>N</em> is the assigned port number. The non real-time side shall open this device to exchange data over the bound socket.<p>
<a class="anchor" name="xddp_label_binding"></a> If a label was assigned (see <a class="el" href="group__rtipc.html#gf8b123d7b54c95dd655b8a3b02d2759f">XDDP_LABEL</a>) prior to binding the socket to a port, a registry link referring to the created pseudo-device will be automatically set up as <code>/proc/xenomai/registry/rtipc/xddp/<em>label</em>,</code> where <em>label</em> is the label string passed to setsockopt() for the <a class="el" href="group__rtipc.html#gf8b123d7b54c95dd655b8a3b02d2759f">XDDP_LABEL</a> option.<p>
<ul>
<li>IPCPROTO_IDDP</li></ul>
<p>
This action creates an endpoint for exchanging datagrams within the Xenomai domain.<p>
<em>sipc_family</em> must be AF_RTIPC, <em>sipc_port</em> is either -1, or a valid free port number between 0 and CONFIG_XENO_OPT_IDDP_NRPORT-1.<p>
If <em>sipc_port</em> is -1, a free port will be assigned automatically. The real-time peer shall connect to the same port for exchanging data over the bound socket.<p>
<a class="anchor" name="iddp_label_binding"></a> If a label was assigned (see <a class="el" href="group__rtipc.html#gc62cba4b02621f8536f5d4d3f9d993bd">IDDP_LABEL</a>) prior to binding the socket to a port, a registry link referring to the assigned port number will be automatically set up as <code>/proc/xenomai/registry/rtipc/iddp/<em>label</em>,</code> where <em>label</em> is the label string passed to setsockopt() for the <a class="el" href="group__rtipc.html#gc62cba4b02621f8536f5d4d3f9d993bd">IDDP_LABEL</a> option.<p>
<ul>
<li>IPCPROTO_BUFP</li></ul>
<p>
This action creates an endpoint for a one-way byte stream within the Xenomai domain.<p>
<em>sipc_family</em> must be AF_RTIPC, <em>sipc_port</em> is either -1, or a valid free port number between 0 and CONFIG_XENO_OPT_BUFP_NRPORT-1.<p>
If <em>sipc_port</em> is -1, an available port will be assigned automatically. The real-time peer shall connect to the same port for exchanging data over the bound socket.<p>
<a class="anchor" name="bufp_label_binding"></a> If a label was assigned (see <a class="el" href="group__rtipc.html#g0ff681be80a29ba24d5d591ca5dd6fca">BUFP_LABEL</a>) prior to binding the socket to a port, a registry link referring to the assigned port number will be automatically set up as <code>/proc/xenomai/registry/rtipc/bufp/<em>label</em>,</code> where <em>label</em> is the label string passed to setsockopt() for the <em>BUFP_LABEL</em> option.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>In addition to the standard error codes for <code>bind(2)</code>, the following specific error code may be returned:<ul>
<li>-EFAULT (Invalid data address given)</li><li>-ENOMEM (Not enough memory)</li><li>-EINVAL (Invalid parameter)</li><li>-EADDRINUSE (Socket already bound to a port, or no port available)</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>non-RT </dd></dl>

</div>
</div><p>
<a class="anchor" name="g446307f82b9d1e3464a852984bc875bc"></a><!-- doxytag: member="rtipc.h::close__AF_RTIPC" ref="g446307f82b9d1e3464a852984bc875bc" args="(int sockfd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int close__AF_RTIPC           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sockfd</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close a RTIPC socket descriptor. 
<p>
Blocking calls to any of the <a class="el" href="group__rtipc.html#gb77f8a835dd741535882e2e50126b0af">sendmsg</a> or <a class="el" href="group__rtipc.html#g69ad5e9d75282d13e69ba2c472ea4ed0">recvmsg</a> functions will be unblocked when the socket is closed and return with an error.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>In addition to the standard error codes for <code>close(2)</code>, the following specific error code may be returned: none</dd></dl>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>non-RT </dd></dl>

</div>
</div><p>
<a class="anchor" name="g61bb0c8ac9896f5b8d56b18163fa5bf0"></a><!-- doxytag: member="rtipc.h::connect__AF_RTIPC" ref="g61bb0c8ac9896f5b8d56b18163fa5bf0" args="(int sockfd, const struct sockaddr_ipc *addr, socklen_t addrlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connect__AF_RTIPC           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsockaddr__ipc.html">sockaddr_ipc</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&nbsp;</td>
          <td class="paramname"> <em>addrlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initiate a connection on a RTIPC socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>The address to connect the socket to (see struct <a class="el" href="structsockaddr__ipc.html" title="Socket address structure for the RTIPC address family.">sockaddr_ipc</a>).</td></tr>
  </table>
</dl>
<ul>
<li>If sipc_port is a valid port for the protocol, it is used verbatim and the connection succeeds immediately, regardless of whether the destination is bound at the time of the call.</li></ul>
<p>
<ul>
<li>If sipc_port is -1 and a label was assigned to the socket, connect() blocks for the requested amount of time (see <a class="el" href="group__rtipc.html#gf2d1ed6a34336a6f3df80fb518325846">SO_RCVTIMEO</a>) until a socket is bound to the same label via <code>bind(2)</code> (see <a class="el" href="group__rtipc.html#gf8b123d7b54c95dd655b8a3b02d2759f">XDDP_LABEL</a>, <a class="el" href="group__rtipc.html#gc62cba4b02621f8536f5d4d3f9d993bd">IDDP_LABEL</a>, <a class="el" href="group__rtipc.html#g0ff681be80a29ba24d5d591ca5dd6fca">BUFP_LABEL</a>), in which case a connection is established between both endpoints.</li></ul>
<p>
<ul>
<li>If sipc_port is -1 and no label was assigned to the socket, the default destination address is cleared, meaning that any subsequent write to the socket will return -EDESTADDRREQ, until a valid destination address is set via <code>connect(2)</code> or <code>bind(2)</code>.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>In addition to the standard error codes for <code>connect(2)</code>, the following specific error code may be returned: none.</dd></dl>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT </dd></dl>

</div>
</div><p>
<a class="anchor" name="g620af595b33bbc2284f86ee25b8759dd"></a><!-- doxytag: member="rtipc.h::getpeername__AF_RTIPC" ref="g620af595b33bbc2284f86ee25b8759dd" args="(int sockfd, struct sockaddr_ipc *addr, socklen_t *addrlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getpeername__AF_RTIPC           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsockaddr__ipc.html">sockaddr_ipc</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&nbsp;</td>
          <td class="paramname"> <em>addrlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get socket peer. 
<p>
The name of the remote endpoint for the socket is copied back (see struct <a class="el" href="structsockaddr__ipc.html" title="Socket address structure for the RTIPC address family.">sockaddr_ipc</a>). This is the default destination address for messages sent on the socket. It can be set either explicitly via <code>connect(2)</code>, or implicitly via <code>bind(2)</code> if no <code>connect(2)</code> was called prior to binding the socket to a port, in which case both the local and remote names are equal.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>In addition to the standard error codes for <code>getpeername(2)</code>, the following specific error code may be returned: none.</dd></dl>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd24c6013d32d57b90c392993a1118385"></a><!-- doxytag: member="rtipc.h::getsockname__AF_RTIPC" ref="gd24c6013d32d57b90c392993a1118385" args="(int sockfd, struct sockaddr_ipc *addr, socklen_t *addrlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getsockname__AF_RTIPC           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsockaddr__ipc.html">sockaddr_ipc</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&nbsp;</td>
          <td class="paramname"> <em>addrlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get socket name. 
<p>
The name of the local endpoint for the socket is copied back (see struct <a class="el" href="structsockaddr__ipc.html" title="Socket address structure for the RTIPC address family.">sockaddr_ipc</a>).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>In addition to the standard error codes for <code>getsockname(2)</code>, the following specific error code may be returned: none.</dd></dl>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT </dd></dl>

</div>
</div><p>
<a class="anchor" name="g26876fedfc5b831c9d49c630650f5bc6"></a><!-- doxytag: member="rtipc.h::getsockopt__AF_RTIPC" ref="g26876fedfc5b831c9d49c630650f5bc6" args="(int sockfd, int level, int optname, void *optval, socklen_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getsockopt__AF_RTIPC           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get options on RTIPC sockets. 
<p>
These functions allow to get various socket options. Supported Levels and Options:<p>
<ul>
<li>Level <a class="el" href="group__rtipc.html#sockopts_socket">SOL_SOCKET</a></li><li>Level <a class="el" href="group__rtipc.html#sockopts_xddp">SOL_XDDP</a></li><li>Level <a class="el" href="group__rtipc.html#sockopts_iddp">SOL_IDDP</a></li><li>Level <a class="el" href="group__rtipc.html#sockopts_bufp">SOL_BUFP</a></li></ul>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>In addition to the standard error codes for <code>getsockopt(2)</code>, the following specific error code may be returned: follow the option links above.</dd></dl>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT/non-RT </dd></dl>

</div>
</div><p>
<a class="anchor" name="g69ad5e9d75282d13e69ba2c472ea4ed0"></a><!-- doxytag: member="rtipc.h::recvmsg__AF_RTIPC" ref="g69ad5e9d75282d13e69ba2c472ea4ed0" args="(int sockfd, struct msghdr *msg, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t recvmsg__AF_RTIPC           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct msghdr *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a message from a RTIPC socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Operation flags:</td></tr>
  </table>
</dl>
<ul>
<li>MSG_DONTWAIT Non-blocking I/O operation. The caller will not be blocked whenever no message is immediately available for receipt at the time of the call, but will rather return with -EWOULDBLOCK.</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a25fb2400ca0886ef0a4eff1328afd92c18">IPCPROTO_BUFP</a> does not allow for short reads and always returns the requested amount of bytes, except in one situation: whenever some writer is waiting for sending data upon a buffer full condition, while the caller would have to wait for receiving a complete message. This is usually the sign of a pathological use of the BUFP socket, like defining an incorrect buffer size via <a class="el" href="group__rtipc.html#g5bbbae934f8a7f982e94ed310ed9a364">BUFP_BUFSZ</a>. In that case, a short read is allowed to prevent a deadlock.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>In addition to the standard error codes for <code>recvmsg(2)</code>, the following specific error code may be returned: none.</dd></dl>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb77f8a835dd741535882e2e50126b0af"></a><!-- doxytag: member="rtipc.h::sendmsg__AF_RTIPC" ref="gb77f8a835dd741535882e2e50126b0af" args="(int sockfd, const struct msghdr *msg, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sendmsg__AF_RTIPC           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct msghdr *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a message on a RTIPC socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Operation flags:</td></tr>
  </table>
</dl>
<ul>
<li>MSG_OOB Send out-of-band message. For all RTIPC protocols except <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a25fb2400ca0886ef0a4eff1328afd92c18">IPCPROTO_BUFP</a>, sending out-of-band data actually means pushing them to the head of the receiving queue, so that the reader will always receive them before normal messages. <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a25fb2400ca0886ef0a4eff1328afd92c18">IPCPROTO_BUFP</a> does not support out-of-band sending.</li></ul>
<p>
<ul>
<li>MSG_DONTWAIT Non-blocking I/O operation. The caller will not be blocked whenever the message cannot be sent immediately at the time of the call (e.g. memory shortage), but will rather return with -EWOULDBLOCK. Unlike other RTIPC protocols, <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a2528a488c3e7fc47dee4d5757f215f62e9">IPCPROTO_XDDP</a> accepts but never considers MSG_DONTWAIT since writing to a real-time XDDP endpoint is inherently a non-blocking operation.</li></ul>
<p>
<ul>
<li>MSG_MORE Accumulate data before sending. This flag is accepted by the <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a2528a488c3e7fc47dee4d5757f215f62e9">IPCPROTO_XDDP</a> protocol only, and tells the send service to accumulate the outgoing data into an internal streaming buffer, instead of issuing a datagram immediately for it. See <a class="el" href="group__rtipc.html#g61a2c99e1588e761aff890c27df6e5bd">XDDP_BUFSZ</a> for more.</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>No RTIPC protocol allows for short writes, and only complete messages are sent to the peer.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>In addition to the standard error codes for <code>sendmsg(2)</code>, the following specific error code may be returned: none.</dd></dl>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>RT </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd529c20d5d8d9660703759f0eb109a67"></a><!-- doxytag: member="rtipc.h::setsockopt__AF_RTIPC" ref="gd529c20d5d8d9660703759f0eb109a67" args="(int sockfd, int level, int optname, const void *optval, socklen_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setsockopt__AF_RTIPC           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set options on RTIPC sockets. 
<p>
These functions allow to set various socket options. Supported Levels and Options:<p>
<ul>
<li>Level <a class="el" href="group__rtipc.html#sockopts_socket">SOL_SOCKET</a></li><li>Level <a class="el" href="group__rtipc.html#sockopts_xddp">SOL_XDDP</a></li><li>Level <a class="el" href="group__rtipc.html#sockopts_iddp">SOL_IDDP</a></li><li>Level <a class="el" href="group__rtipc.html#sockopts_bufp">SOL_BUFP</a></li></ul>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>In addition to the standard error codes for <code>setsockopt(2)</code>, the following specific error code may be returned: follow the option links above.</dd></dl>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>non-RT </dd></dl>

</div>
</div><p>
<a class="anchor" name="g77d456500c719b5ac81b051cb957f581"></a><!-- doxytag: member="rtipc.h::socket__AF_RTIPC" ref="g77d456500c719b5ac81b051cb957f581" args="(int domain=AF_RTIPC, int type=SOCK_DGRAM, int protocol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int socket__AF_RTIPC           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>domain</em> = <code>AF_RTIPC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>SOCK_DGRAM</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>protocol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an endpoint for communication in the AF_RTIPC domain. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>protocol</em>&nbsp;</td><td>Any of <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a2528a488c3e7fc47dee4d5757f215f62e9">IPCPROTO_XDDP</a>, <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a257f1e80711306177a6f5d48031efe0080">IPCPROTO_IDDP</a>, or <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a25fb2400ca0886ef0a4eff1328afd92c18">IPCPROTO_BUFP</a>. <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a259a5b551f46faa3b63b002fdde789e2ba">IPCPROTO_IPC</a> is also valid, and refers to the default RTIPC protocol, namely <a class="el" href="group__rtipc.html#ggba01db17f4a2bfbc3db60dc172972a257f1e80711306177a6f5d48031efe0080">IPCPROTO_IDDP</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>In addition to the standard error codes for <code>socket(2)</code>, the following specific error code may be returned:<ul>
<li>-ENOPROTOOPT (Protocol is known, but not compiled in the RTIPC driver). See <a class="el" href="group__rtipc.html#RTIPC_PROTO">RTIPC protocols</a> for available protocols.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Calling context:</b></dt><dd>non-RT </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Sep 2 20:38:46 2010 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
