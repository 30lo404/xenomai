<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Xenomai: Thread management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">2.99.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cobalt__thread.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Thread management<div class="ingroups"><a class="el" href="group__cobalt.html">Cobalt/POSIX real-time API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Cobalt/POSIX thread management services.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Thread management:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__cobalt__thread.png" border="0" alt="" usemap="#group____cobalt____thread"/>
<map name="group____cobalt____thread" id="group____cobalt____thread">
<area shape="rect" id="node2" href="group__cobalt.html" title="The Cobalt interface is an implementation of a small subset of the Single Unix specification over the..." alt="" coords="6,5,191,32"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga405020019f5df8c7e74d30fd457384ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#ga405020019f5df8c7e74d30fd457384ed">pthread_setschedparam_ex</a> (pthread_t thread, int policy, const struct sched_param_ex *param_ex)</td></tr>
<tr class="memdesc:ga405020019f5df8c7e74d30fd457384ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set extended scheduling policy of thread.  <a href="#ga405020019f5df8c7e74d30fd457384ed">More...</a><br/></td></tr>
<tr class="separator:ga405020019f5df8c7e74d30fd457384ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga889551a09dbb57727ea733dd79cc2e36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#ga889551a09dbb57727ea733dd79cc2e36">pthread_getschedparam_ex</a> (pthread_t thread, int *__restrict__ policy_r, struct sched_param_ex *__restrict__ param_ex)</td></tr>
<tr class="memdesc:ga889551a09dbb57727ea733dd79cc2e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get extended scheduling policy of thread.  <a href="#ga889551a09dbb57727ea733dd79cc2e36">More...</a><br/></td></tr>
<tr class="separator:ga889551a09dbb57727ea733dd79cc2e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a96424296ef872696c7fb90a8ae9aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#gae1a96424296ef872696c7fb90a8ae9aa">pthread_create</a> (pthread_t *ptid_r, const pthread_attr_t *attr, void *(*start)(void *), void *arg)</td></tr>
<tr class="memdesc:gae1a96424296ef872696c7fb90a8ae9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread.  <a href="#gae1a96424296ef872696c7fb90a8ae9aa">More...</a><br/></td></tr>
<tr class="separator:gae1a96424296ef872696c7fb90a8ae9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4f4c1f668e3494be684d8630104f80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#gaae4f4c1f668e3494be684d8630104f80">pthread_make_periodic_np</a> (pthread_t thread, clockid_t clk_id, const struct timespec *__restrict__ starttp, const struct timespec *__restrict__ periodtp)</td></tr>
<tr class="memdesc:gaae4f4c1f668e3494be684d8630104f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a thread periodic.  <a href="#gaae4f4c1f668e3494be684d8630104f80">More...</a><br/></td></tr>
<tr class="separator:gaae4f4c1f668e3494be684d8630104f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c23276876e1e9374d4cad841390eedc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__thread.html#ga8c23276876e1e9374d4cad841390eedc">pthread_set_mode_np</a> (int clrmask, int setmask, int *mode_r)</td></tr>
<tr class="memdesc:ga8c23276876e1e9374d4cad841390eedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mode of the current thread.  <a href="#ga8c23276876e1e9374d4cad841390eedc">More...</a><br/></td></tr>
<tr class="separator:ga8c23276876e1e9374d4cad841390eedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Cobalt/POSIX thread management services. </p>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_09.html#tag_02_09">Specification.</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae1a96424296ef872696c7fb90a8ae9aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_create </td>
          <td>(</td>
          <td class="paramtype">pthread_t *&#160;</td>
          <td class="paramname"><em>ptid_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pthread_attr_t *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new thread. </p>
<p>This service creates a thread managed by the Xenomai nucleus in dual kernel configuration.</p>
<p>The new thread signal mask is inherited from the current thread, if it was also created with <a class="el" href="group__cobalt__thread.html#gae1a96424296ef872696c7fb90a8ae9aa" title="Create a new thread. ">pthread_create()</a>, otherwise the new thread signal mask is empty.</p>
<p>Other attributes of the new thread depend on the <em>attr</em> argument. If <em>attr</em> is NULL, default values for these attributes are used.</p>
<p>Returning from the <em>start</em> routine has the same effect as calling pthread_exit() with the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptid_r</td><td>address where the identifier of the new thread will be stored on success;</td></tr>
    <tr><td class="paramname">attr</td><td>thread attributes;</td></tr>
    <tr><td class="paramname">start</td><td>thread start routine;</td></tr>
    <tr><td class="paramname">arg</td><td>opaque user-supplied argument passed to <em>start</em>;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>EINVAL, <em>attr</em> is invalid;</li>
<li>EAGAIN, insufficient memory exists in the system heap to create a new thread, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li>
<li>EINVAL, thread attribute <em>inheritsched</em> is set to PTHREAD_INHERIT_SCHED and the calling thread does not belong to the Cobalt interface;</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_create.html">Specification.</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>When creating or shadowing a Xenomai thread for the first time in user-space, Xenomai installs a handler for the SIGSHADOW signal. If you had installed a handler before that, it will be automatically called by Xenomai for SIGSHADOW signals that it has not sent.</p>
<p>If, however, you install a signal handler for SIGSHADOW after creating or shadowing the first Xenomai thread, you have to explicitly call the function cobalt_sigshadow_handler at the beginning of your signal handler, using its return to know if the signal was in fact an internal signal of Xenomai (in which case it returns 1), or if you should handle the signal (in which case it returns 0). cobalt_sigshadow_handler prototype is:</p>
<p><b>int cobalt_sigshadow_handler(int sig, struct siginfo *si, void *ctxt);</b></p>
<p>Which means that you should register your handler with sigaction, using the SA_SIGINFO flag, and pass all the arguments you received to cobalt_sigshadow_handler. </p>

</div>
</div>
<a class="anchor" id="ga889551a09dbb57727ea733dd79cc2e36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_getschedparam_ex </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *__restrict__&#160;</td>
          <td class="paramname"><em>policy_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sched_param_ex *__restrict__&#160;</td>
          <td class="paramname"><em>param_ex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get extended scheduling policy of thread. </p>
<p>This service is an extended version of the regular pthread_getschedparam() service, which also supports Xenomai-specific or additional POSIX scheduling policies, not available with the host Linux environment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>target thread;</td></tr>
    <tr><td class="paramname">policy_r</td><td>address where the scheduling policy of <em>thread</em> is stored on success;</td></tr>
    <tr><td class="paramname">param_ex</td><td>address where the scheduling parameters of <em>thread</em> are stored on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_getschedparam.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaae4f4c1f668e3494be684d8630104f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_make_periodic_np </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clockid_t&#160;</td>
          <td class="paramname"><em>clk_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *__restrict__&#160;</td>
          <td class="paramname"><em>starttp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *__restrict__&#160;</td>
          <td class="paramname"><em>periodtp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a thread periodic. </p>
<p>This service make the Cobalt interface <em>thread</em> periodic.</p>
<p>This service is a non-portable extension of the POSIX interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>thread identifier.</td></tr>
    <tr><td class="paramname">clk_id</td><td>clock identifier, either CLOCK_REALTIME, CLOCK_MONOTONIC or CLOCK_MONOTONIC_RAW.</td></tr>
    <tr><td class="paramname">starttp</td><td>start time, expressed as an absolute value of the clock <em>clock_id</em>. The affected thread will be delayed until this point is reached.</td></tr>
    <tr><td class="paramname">periodtp</td><td>period, expressed as a time interval.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li>
<li>ETIMEDOUT, the start time has already passed.</li>
<li>EINVAL, the specified clock is unsupported; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8c23276876e1e9374d4cad841390eedc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_set_mode_np </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>setmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>mode_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the mode of the current thread. </p>
<p>This service sets the mode of the calling thread. <em>clrmask</em> and <em>setmask</em> are two bit masks which are respectively cleared and set in the calling thread status. They are a bitwise OR of the following values:</p>
<ul>
<li>PTHREAD_LOCK_SCHED, when set, locks the scheduler, which prevents the current thread from being switched out until the scheduler is unlocked;</li>
<li>PTHREAD_WARNSW, when set, causes the signal SIGXCPU to be sent to the current thread, whenever it involontary switches to secondary mode;</li>
<li>PTHREAD_CONFORMING can be passed in <em>setmask</em> to switch the current user-space task to its preferred runtime mode. The only meaningful use of this switch is to force a real-time shadow back to primary mode. Any other use leads to a nop.</li>
<li>PTHREAD_DISABLE_LOCKBREAK disallows breaking the scheduler lock. In the default case, a thread which holds the scheduler lock is allowed to drop it temporarily for sleeping. If this mode bit is set, such thread would return with EINTR immediately from any blocking call.</li>
</ul>
<p>PTHREAD_LOCK_SCHED and PTHREAD_DISABLE_LOCKBREAK are valid for any Xenomai thread, other bits are valid for Xenomai user-space threads only.</p>
<p>This service is a non-portable extension of the POSIX interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clrmask</td><td>set of bits to be cleared;</td></tr>
    <tr><td class="paramname">setmask</td><td>set of bits to be set.</td></tr>
    <tr><td class="paramname">mode_r</td><td>If non-NULL, <em>mode_r</em> must be a pointer to a memory location which will be written upon success with the previous set of active mode bits. If NULL, the previous set of active mode bits will not be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>EINVAL, some bit in <em>clrmask</em> or <em>setmask</em> is invalid.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Setting <em>clrmask</em> and <em>setmask</em> to zero leads to a nop, only returning the previous mode if <em>mode_r</em> is a valid address. </dd></dl>

</div>
</div>
<a class="anchor" id="ga405020019f5df8c7e74d30fd457384ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_setschedparam_ex </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sched_param_ex *&#160;</td>
          <td class="paramname"><em>param_ex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set extended scheduling policy of thread. </p>
<p>This service is an extended version of the regular pthread_setschedparam() service, which supports Xenomai-specific or additional scheduling policies, not available with the host Linux environment.</p>
<p>This service set the scheduling policy of the Xenomai thread <em>thread</em> to the value <em>policy</em>, and its scheduling parameters (e.g. its priority) to the value pointed to by <em>param_ex</em>.</p>
<p>If <em>thread</em> does not match the identifier of a Xenomai thread, this action falls back to the regular pthread_setschedparam() service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>target Cobalt thread;</td></tr>
    <tr><td class="paramname">policy</td><td>scheduling policy, one of SCHED_WEAK, SCHED_FIFO, SCHED_COBALT, SCHED_RR, SCHED_SPORADIC, SCHED_TP, SCHED_QUOTA or SCHED_NORMAL;</td></tr>
    <tr><td class="paramname">param_ex</td><td>scheduling parameters address. As a special exception, a negative sched_priority value is interpreted as if SCHED_WEAK was given in <em>policy</em>, using the absolute value of this parameter as the weak priority level.</td></tr>
  </table>
  </dd>
</dl>
<p>When CONFIG_XENO_OPT_SCHED_WEAK is enabled, SCHED_WEAK exhibits priority levels in the [0..99] range (inclusive). Otherwise, sched_priority must be zero for the SCHED_WEAK policy.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li>
<li>EINVAL, <em>policy</em> or <em>param_ex-&gt;sched_priority</em> is invalid;</li>
<li>EAGAIN, in user-space, insufficient memory exists in the system heap, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li>
<li>EFAULT, in user-space, <em>param_ex</em> is an invalid address;</li>
<li>EPERM, in user-space, the calling process does not have superuser permissions.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_setschedparam.html">Specification.</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>When creating or shadowing a Xenomai thread for the first time in user-space, Xenomai installs a handler for the SIGSHADOW signal. If you had installed a handler before that, it will be automatically called by Xenomai for SIGSHADOW signals that it has not sent.</p>
<p>If, however, you install a signal handler for SIGSHADOW after creating or shadowing the first Xenomai thread, you have to explicitly call the function cobalt_sigshadow_handler at the beginning of your signal handler, using its return to know if the signal was in fact an internal signal of Xenomai (in which case it returns 1), or if you should handle the signal (in which case it returns 0). cobalt_sigshadow_handler prototype is:</p>
<p><b>int cobalt_sigshadow_handler(int sig, struct siginfo *si, void *ctxt);</b></p>
<p>Which means that you should register your handler with sigaction, using the SA_SIGINFO flag, and pass all the arguments you received to cobalt_sigshadow_handler.</p>
<p><a class="el" href="group__cobalt__thread.html#ga405020019f5df8c7e74d30fd457384ed" title="Set extended scheduling policy of thread. ">pthread_setschedparam_ex()</a> may switch the caller to secondary mode. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
