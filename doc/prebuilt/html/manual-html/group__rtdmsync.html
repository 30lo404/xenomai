<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Xenomai: Rtdmsync</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">2.99.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__rtdmsync.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Rtdmsync<div class="ingroups"><a class="el" href="group__rtdm__device__register.html">Device Registration Services</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Rtdmsync:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__rtdmsync.png" border="0" alt="" usemap="#group____rtdmsync"/>
<map name="group____rtdmsync" id="group____rtdmsync">
<area shape="rect" id="node2" href="group__rtdm__device__register.html" title="Device Registration\l Services" alt="" coords="6,5,143,46"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RTDM_SELECTTYPE_xxx</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe7c56e23b943533d601cd08637a81e10"></a><a class="anchor" id="RTDM_SELECTTYPE_xxx"></a>Event types select can bind to </p>
</td></tr>
<tr class="memitem:gae18228df8c70c9da1f90f61b01e92501"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> { <a class="el" href="group__rtdmsync.html#ggae18228df8c70c9da1f90f61b01e92501a3ddb0fbad9f52ad3646be2e5a6ba8b2b">RTDM_SELECTTYPE_READ</a> = XNSELECT_READ, 
<a class="el" href="group__rtdmsync.html#ggae18228df8c70c9da1f90f61b01e92501a37819f609dee2b20852001e9b7ecd462">RTDM_SELECTTYPE_WRITE</a> = XNSELECT_WRITE, 
<a class="el" href="group__rtdmsync.html#ggae18228df8c70c9da1f90f61b01e92501a2dd10c612a9e3c7e5134ee122ee3de74">RTDM_SELECTTYPE_EXCEPT</a> = XNSELECT_EXCEPT
 }</td></tr>
<tr class="separator:gae18228df8c70c9da1f90f61b01e92501"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Global Lock across Scheduler Invocation</h2></td></tr>
<tr class="memitem:gabbaf52632d5dde7fa66e0b70d887493b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gabbaf52632d5dde7fa66e0b70d887493b">RTDM_EXECUTE_ATOMICALLY</a>(code_block)</td></tr>
<tr class="memdesc:gabbaf52632d5dde7fa66e0b70d887493b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute code block atomically (DEPRECATED)  <a href="#gabbaf52632d5dde7fa66e0b70d887493b">More...</a><br/></td></tr>
<tr class="separator:gabbaf52632d5dde7fa66e0b70d887493b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Spinlock with Preemption Deactivation</h2></td></tr>
<tr class="memitem:gacbc89e880b42154cb65aa8317195dc03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacbc89e880b42154cb65aa8317195dc03"></a>
typedef ipipe_spinlock_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a></td></tr>
<tr class="memdesc:gacbc89e880b42154cb65aa8317195dc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock variable. <br/></td></tr>
<tr class="separator:gacbc89e880b42154cb65aa8317195dc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7584217487c323356414e21200a57e63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7584217487c323356414e21200a57e63"></a>
typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga7584217487c323356414e21200a57e63">rtdm_lockctx_t</a></td></tr>
<tr class="memdesc:ga7584217487c323356414e21200a57e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable to save the context while holding a lock. <br/></td></tr>
<tr class="separator:ga7584217487c323356414e21200a57e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0fa498c3141c5f05e072e9af35eaeb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga8b0fa498c3141c5f05e072e9af35eaeb">rtdm_lock_init</a> (<a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a> *lock)</td></tr>
<tr class="memdesc:ga8b0fa498c3141c5f05e072e9af35eaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic lock initialisation.  <a href="#ga8b0fa498c3141c5f05e072e9af35eaeb">More...</a><br/></td></tr>
<tr class="separator:ga8b0fa498c3141c5f05e072e9af35eaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77fe54d2ce88096711e8cc4e48d45a28"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga77fe54d2ce88096711e8cc4e48d45a28">rtdm_lock_get</a> (<a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a> *lock)</td></tr>
<tr class="memdesc:ga77fe54d2ce88096711e8cc4e48d45a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire lock from non-preemptible contexts.  <a href="#ga77fe54d2ce88096711e8cc4e48d45a28">More...</a><br/></td></tr>
<tr class="separator:ga77fe54d2ce88096711e8cc4e48d45a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f7c052e195b4936941cf67f50c006e7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga9f7c052e195b4936941cf67f50c006e7">rtdm_lock_put</a> (<a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a> *lock)</td></tr>
<tr class="memdesc:ga9f7c052e195b4936941cf67f50c006e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release lock without preemption restoration.  <a href="#ga9f7c052e195b4936941cf67f50c006e7">More...</a><br/></td></tr>
<tr class="separator:ga9f7c052e195b4936941cf67f50c006e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebcf9945def75c805f63db30d5f9e521"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__rtdmsync.html#ga7584217487c323356414e21200a57e63">rtdm_lockctx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gaebcf9945def75c805f63db30d5f9e521">__rtdm_lock_get_irqsave</a> (<a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a> *lock)</td></tr>
<tr class="memdesc:gaebcf9945def75c805f63db30d5f9e521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire lock and disable preemption, by stalling the head domain.  <a href="#gaebcf9945def75c805f63db30d5f9e521">More...</a><br/></td></tr>
<tr class="separator:gaebcf9945def75c805f63db30d5f9e521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9892fad6532c2022229d30234196d44b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga9892fad6532c2022229d30234196d44b">rtdm_lock_put_irqrestore</a> (<a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a> *lock, <a class="el" href="group__rtdmsync.html#ga7584217487c323356414e21200a57e63">rtdm_lockctx_t</a> s)</td></tr>
<tr class="memdesc:ga9892fad6532c2022229d30234196d44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release lock and restore preemption state.  <a href="#ga9892fad6532c2022229d30234196d44b">More...</a><br/></td></tr>
<tr class="separator:ga9892fad6532c2022229d30234196d44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad122b937f723fade24e729dcf1374ac6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad122b937f723fade24e729dcf1374ac6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gad122b937f723fade24e729dcf1374ac6">RTDM_LOCK_UNLOCKED</a>(__name)&#160;&#160;&#160;IPIPE_SPIN_LOCK_UNLOCKED</td></tr>
<tr class="memdesc:gad122b937f723fade24e729dcf1374ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static lock initialisation. <br/></td></tr>
<tr class="separator:gad122b937f723fade24e729dcf1374ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34bb54b06465dfe08b920011df14ac5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga34bb54b06465dfe08b920011df14ac5d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga34bb54b06465dfe08b920011df14ac5d">DEFINE_RTDM_LOCK</a>(__name)&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a> __name = <a class="el" href="group__rtdmsync.html#gad122b937f723fade24e729dcf1374ac6">RTDM_LOCK_UNLOCKED</a>(__name)</td></tr>
<tr class="memdesc:ga34bb54b06465dfe08b920011df14ac5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static lock initialisation. <br/></td></tr>
<tr class="separator:ga34bb54b06465dfe08b920011df14ac5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7567086445ca9299e7caa659b566fe37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7567086445ca9299e7caa659b566fe37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga7567086445ca9299e7caa659b566fe37">rtdm_lock_get_irqsave</a>(__lock, __s)&#160;&#160;&#160;((__s) = <a class="el" href="group__rtdmsync.html#gaebcf9945def75c805f63db30d5f9e521">__rtdm_lock_get_irqsave</a>(__lock))</td></tr>
<tr class="memdesc:ga7567086445ca9299e7caa659b566fe37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static lock initialisation. <br/></td></tr>
<tr class="separator:ga7567086445ca9299e7caa659b566fe37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d563fc5def018f743c55c452e061758"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga3d563fc5def018f743c55c452e061758">rtdm_lock_irqsave</a>(context)&#160;&#160;&#160;splhigh(context)</td></tr>
<tr class="memdesc:ga3d563fc5def018f743c55c452e061758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable preemption locally.  <a href="#ga3d563fc5def018f743c55c452e061758">More...</a><br/></td></tr>
<tr class="separator:ga3d563fc5def018f743c55c452e061758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae03c387fcae8a55105dd31d7c008bbb4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gae03c387fcae8a55105dd31d7c008bbb4">rtdm_lock_irqrestore</a>(context)&#160;&#160;&#160;splexit(context)</td></tr>
<tr class="memdesc:gae03c387fcae8a55105dd31d7c008bbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore preemption state.  <a href="#gae03c387fcae8a55105dd31d7c008bbb4">More...</a><br/></td></tr>
<tr class="separator:gae03c387fcae8a55105dd31d7c008bbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632e377a9ec9f08e191dcd86f567925b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga632e377a9ec9f08e191dcd86f567925b">cobalt_atomic_enter</a>(context)</td></tr>
<tr class="memdesc:ga632e377a9ec9f08e191dcd86f567925b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter atomic section (dual kernel only)  <a href="#ga632e377a9ec9f08e191dcd86f567925b">More...</a><br/></td></tr>
<tr class="separator:ga632e377a9ec9f08e191dcd86f567925b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64a86eb4e60d52143482c4665efbafc6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga64a86eb4e60d52143482c4665efbafc6">cobalt_atomic_leave</a>(context)</td></tr>
<tr class="memdesc:ga64a86eb4e60d52143482c4665efbafc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave atomic section (dual kernel only)  <a href="#ga64a86eb4e60d52143482c4665efbafc6">More...</a><br/></td></tr>
<tr class="separator:ga64a86eb4e60d52143482c4665efbafc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Signal, test and wait for a condition atomically</h2></td></tr>
<tr class="memitem:ga0bbb1e7c98ac3a3968aba970f99709ed"><td class="memItemLeft" align="right" valign="top">typedef struct rtdm_waitqueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga0bbb1e7c98ac3a3968aba970f99709ed">rtdm_waitqueue_t</a></td></tr>
<tr class="memdesc:ga0bbb1e7c98ac3a3968aba970f99709ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a locked waitqueue until a condition gets true.  <a href="#ga0bbb1e7c98ac3a3968aba970f99709ed">More...</a><br/></td></tr>
<tr class="separator:ga0bbb1e7c98ac3a3968aba970f99709ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5bf4fbd58e352d50e99fb7c2f95bfa0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gae5bf4fbd58e352d50e99fb7c2f95bfa0">rtdm_waitqueue_init</a> (struct rtdm_waitqueue *wq)</td></tr>
<tr class="memdesc:gae5bf4fbd58e352d50e99fb7c2f95bfa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a RTDM wait queue.  <a href="#gae5bf4fbd58e352d50e99fb7c2f95bfa0">More...</a><br/></td></tr>
<tr class="separator:gae5bf4fbd58e352d50e99fb7c2f95bfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab63f5e06b9eb600cbbb026e19f56a648"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gab63f5e06b9eb600cbbb026e19f56a648">rtdm_waitqueue_destroy</a> (struct rtdm_waitqueue *wq)</td></tr>
<tr class="memdesc:gab63f5e06b9eb600cbbb026e19f56a648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a RTDM wait queue.  <a href="#gab63f5e06b9eb600cbbb026e19f56a648">More...</a><br/></td></tr>
<tr class="separator:gab63f5e06b9eb600cbbb026e19f56a648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dfee9d5f85ee80a79ce62663fbf6b82"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga2dfee9d5f85ee80a79ce62663fbf6b82">__rtdm_timedwait</a> (struct rtdm_waitqueue *wq, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *toseq)</td></tr>
<tr class="memdesc:ga2dfee9d5f85ee80a79ce62663fbf6b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a locked waitqueue until a condition gets true.  <a href="#ga2dfee9d5f85ee80a79ce62663fbf6b82">More...</a><br/></td></tr>
<tr class="separator:ga2dfee9d5f85ee80a79ce62663fbf6b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cf0c5158a6f12e0ad6a701013e72f20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga6cf0c5158a6f12e0ad6a701013e72f20">RTDM_WAITQUEUE_INITIALIZER</a>(__name)</td></tr>
<tr class="memdesc:ga6cf0c5158a6f12e0ad6a701013e72f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a locked waitqueue until a condition gets true.  <a href="#ga6cf0c5158a6f12e0ad6a701013e72f20">More...</a><br/></td></tr>
<tr class="separator:ga6cf0c5158a6f12e0ad6a701013e72f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ebe81e9d2f951d3da8b205de40b25f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga4ebe81e9d2f951d3da8b205de40b25f2">DEFINE_RTDM_WAITQUEUE</a>(__name)&#160;&#160;&#160;struct rtdm_waitqueue __name = <a class="el" href="group__rtdmsync.html#ga6cf0c5158a6f12e0ad6a701013e72f20">RTDM_WAITQUEUE_INITIALIZER</a>(__name)</td></tr>
<tr class="memdesc:ga4ebe81e9d2f951d3da8b205de40b25f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a locked waitqueue until a condition gets true.  <a href="#ga4ebe81e9d2f951d3da8b205de40b25f2">More...</a><br/></td></tr>
<tr class="separator:ga4ebe81e9d2f951d3da8b205de40b25f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2780830a9f4f0d0f401f2dae9b1cb6b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga2780830a9f4f0d0f401f2dae9b1cb6b5">DEFINE_RTDM_WAITQUEUE_ONSTACK</a>(__name)&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga4ebe81e9d2f951d3da8b205de40b25f2">DEFINE_RTDM_WAITQUEUE</a>(__name)</td></tr>
<tr class="memdesc:ga2780830a9f4f0d0f401f2dae9b1cb6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a locked waitqueue until a condition gets true.  <a href="#ga2780830a9f4f0d0f401f2dae9b1cb6b5">More...</a><br/></td></tr>
<tr class="separator:ga2780830a9f4f0d0f401f2dae9b1cb6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56718462f6db9173fd091572452a1193"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga56718462f6db9173fd091572452a1193">rtdm_timedwait_condition_locked</a>(__wq, __cond, __timeout, __toseq)</td></tr>
<tr class="memdesc:ga56718462f6db9173fd091572452a1193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a locked waitqueue until a condition gets true.  <a href="#ga56718462f6db9173fd091572452a1193">More...</a><br/></td></tr>
<tr class="separator:ga56718462f6db9173fd091572452a1193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3a609277c14def3f81da42fd4ea8ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga8b3a609277c14def3f81da42fd4ea8ed">rtdm_wait_condition_locked</a>(__wq, __cond)</td></tr>
<tr class="memdesc:ga8b3a609277c14def3f81da42fd4ea8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep on a locked waitqueue until a condition gets true.  <a href="#ga8b3a609277c14def3f81da42fd4ea8ed">More...</a><br/></td></tr>
<tr class="separator:ga8b3a609277c14def3f81da42fd4ea8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75d09187c34d7562dc7f84d1c4c1d3b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga75d09187c34d7562dc7f84d1c4c1d3b3">rtdm_timedwait_condition</a>(__wq, __cond, __timeout, __toseq)</td></tr>
<tr class="memdesc:ga75d09187c34d7562dc7f84d1c4c1d3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a waitqueue until a condition gets true.  <a href="#ga75d09187c34d7562dc7f84d1c4c1d3b3">More...</a><br/></td></tr>
<tr class="separator:ga75d09187c34d7562dc7f84d1c4c1d3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e6ca0e05c6cb30a6d1e0ce9b7eafbd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga60e6ca0e05c6cb30a6d1e0ce9b7eafbd">rtdm_timedwait</a>(__wq, __timeout, __toseq)&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga2dfee9d5f85ee80a79ce62663fbf6b82">__rtdm_timedwait</a>(__wq, __timeout, __toseq)</td></tr>
<tr class="memdesc:ga60e6ca0e05c6cb30a6d1e0ce9b7eafbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a waitqueue unconditionally.  <a href="#ga60e6ca0e05c6cb30a6d1e0ce9b7eafbd">More...</a><br/></td></tr>
<tr class="separator:ga60e6ca0e05c6cb30a6d1e0ce9b7eafbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e17872489255a832d36bcfe6130079c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga2e17872489255a832d36bcfe6130079c">rtdm_timedwait_locked</a>(__wq, __timeout, __toseq)&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga60e6ca0e05c6cb30a6d1e0ce9b7eafbd">rtdm_timedwait</a>(__wq, __timeout, __toseq)</td></tr>
<tr class="memdesc:ga2e17872489255a832d36bcfe6130079c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a locked waitqueue unconditionally.  <a href="#ga2e17872489255a832d36bcfe6130079c">More...</a><br/></td></tr>
<tr class="separator:ga2e17872489255a832d36bcfe6130079c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e0b2f39cbf0aeef224992f1dc8941a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga84e0b2f39cbf0aeef224992f1dc8941a">rtdm_wait_condition</a>(__wq, __cond)</td></tr>
<tr class="memdesc:ga84e0b2f39cbf0aeef224992f1dc8941a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep on a waitqueue until a condition gets true.  <a href="#ga84e0b2f39cbf0aeef224992f1dc8941a">More...</a><br/></td></tr>
<tr class="separator:ga84e0b2f39cbf0aeef224992f1dc8941a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1699da8fc9cd786226a78ca9dc45df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga8f1699da8fc9cd786226a78ca9dc45df">rtdm_wait</a>(__wq)&#160;&#160;&#160;xnsynch_sleep_on(&amp;(__wq)-&gt;wait,	XN_INFINITE, XN_RELATIVE)</td></tr>
<tr class="memdesc:ga8f1699da8fc9cd786226a78ca9dc45df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep on a waitqueue unconditionally.  <a href="#ga8f1699da8fc9cd786226a78ca9dc45df">More...</a><br/></td></tr>
<tr class="separator:ga8f1699da8fc9cd786226a78ca9dc45df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a9050ae82a8d04cb3c2e30f9e5a690f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga6a9050ae82a8d04cb3c2e30f9e5a690f">rtdm_wait_locked</a>(__wq)&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga8f1699da8fc9cd786226a78ca9dc45df">rtdm_wait</a>(__wq)</td></tr>
<tr class="memdesc:ga6a9050ae82a8d04cb3c2e30f9e5a690f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep on a locked waitqueue unconditionally.  <a href="#ga6a9050ae82a8d04cb3c2e30f9e5a690f">More...</a><br/></td></tr>
<tr class="separator:ga6a9050ae82a8d04cb3c2e30f9e5a690f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8787a0ed5be95c924afad0a4924f64c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8">rtdm_waitqueue_lock</a>(__wq, __context)&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga632e377a9ec9f08e191dcd86f567925b">cobalt_atomic_enter</a>(__context)</td></tr>
<tr class="memdesc:ga8787a0ed5be95c924afad0a4924f64c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a waitqueue.  <a href="#ga8787a0ed5be95c924afad0a4924f64c8">More...</a><br/></td></tr>
<tr class="separator:ga8787a0ed5be95c924afad0a4924f64c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa992132a4d2d5a1c24eac6f54a966fc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gaa992132a4d2d5a1c24eac6f54a966fc2">rtdm_waitqueue_unlock</a>(__wq, __context)&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga64a86eb4e60d52143482c4665efbafc6">cobalt_atomic_leave</a>(__context)</td></tr>
<tr class="memdesc:gaa992132a4d2d5a1c24eac6f54a966fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a waitqueue.  <a href="#gaa992132a4d2d5a1c24eac6f54a966fc2">More...</a><br/></td></tr>
<tr class="separator:gaa992132a4d2d5a1c24eac6f54a966fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c4263d3aead70a86852df6cb11da412"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412">rtdm_waitqueue_signal</a>(__wq)</td></tr>
<tr class="memdesc:ga0c4263d3aead70a86852df6cb11da412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a waitqueue.  <a href="#ga0c4263d3aead70a86852df6cb11da412">More...</a><br/></td></tr>
<tr class="separator:ga0c4263d3aead70a86852df6cb11da412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69d480bf6aabc7c5fdc4138bce1ef9bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga69d480bf6aabc7c5fdc4138bce1ef9bf">__rtdm_waitqueue_flush</a>(__wq, __reason)</td></tr>
<tr class="memdesc:ga69d480bf6aabc7c5fdc4138bce1ef9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a locked waitqueue until a condition gets true.  <a href="#ga69d480bf6aabc7c5fdc4138bce1ef9bf">More...</a><br/></td></tr>
<tr class="separator:ga69d480bf6aabc7c5fdc4138bce1ef9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d6feb7d3c8f79cd223dd295b3de9457"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga3d6feb7d3c8f79cd223dd295b3de9457">rtdm_waitqueue_broadcast</a>(__wq)&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga69d480bf6aabc7c5fdc4138bce1ef9bf">__rtdm_waitqueue_flush</a>(__wq, 0)</td></tr>
<tr class="memdesc:ga3d6feb7d3c8f79cd223dd295b3de9457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a waitqueue.  <a href="#ga3d6feb7d3c8f79cd223dd295b3de9457">More...</a><br/></td></tr>
<tr class="separator:ga3d6feb7d3c8f79cd223dd295b3de9457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc5c1f3f54225def8d76f794ad9e19e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga6dc5c1f3f54225def8d76f794ad9e19e">rtdm_waitqueue_flush</a>(__wq)&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga69d480bf6aabc7c5fdc4138bce1ef9bf">__rtdm_waitqueue_flush</a>(__wq, <a class="el" href="group__core__thread__info.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>)</td></tr>
<tr class="memdesc:ga6dc5c1f3f54225def8d76f794ad9e19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush a waitqueue.  <a href="#ga6dc5c1f3f54225def8d76f794ad9e19e">More...</a><br/></td></tr>
<tr class="separator:ga6dc5c1f3f54225def8d76f794ad9e19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e77ab2e99628b393ef291a5ad6a4de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga12e77ab2e99628b393ef291a5ad6a4de">rtdm_waitqueue_wakeup</a>(__wq, __waiter)</td></tr>
<tr class="memdesc:ga12e77ab2e99628b393ef291a5ad6a4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a particular waiter on a waitqueue.  <a href="#ga12e77ab2e99628b393ef291a5ad6a4de">More...</a><br/></td></tr>
<tr class="separator:ga12e77ab2e99628b393ef291a5ad6a4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab65affd2b1f9975a79c73fb9ee16d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga3ab65affd2b1f9975a79c73fb9ee16d9">rtdm_for_each_waiter</a>(__pos, __wq)&#160;&#160;&#160;xnsynch_for_each_sleeper(__pos, &amp;(__wq)-&gt;wait)</td></tr>
<tr class="memdesc:ga3ab65affd2b1f9975a79c73fb9ee16d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple iterator for waitqueues.  <a href="#ga3ab65affd2b1f9975a79c73fb9ee16d9">More...</a><br/></td></tr>
<tr class="separator:ga3ab65affd2b1f9975a79c73fb9ee16d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0757239f0378acf1cd2198290bf6c40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gae0757239f0378acf1cd2198290bf6c40">rtdm_for_each_waiter_safe</a>(__pos, __tmp, __wq)&#160;&#160;&#160;xnsynch_for_each_sleeper_safe(__pos, __tmp, &amp;(__wq)-&gt;wait)</td></tr>
<tr class="memdesc:gae0757239f0378acf1cd2198290bf6c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe iterator for waitqueues.  <a href="#gae0757239f0378acf1cd2198290bf6c40">More...</a><br/></td></tr>
<tr class="separator:gae0757239f0378acf1cd2198290bf6c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga69d480bf6aabc7c5fdc4138bce1ef9bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __rtdm_waitqueue_flush</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__reason&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({                                                              \</div>
<div class="line">                int __ret;                                              \</div>
<div class="line">                __ret = xnsynch_flush(&amp;(__wq)-&gt;wait, __reason);         <a class="code" href="group__sched.html#gab51b1711cd73d890278e3998c817cc3a">\</a></div>
<div class="line"><a class="code" href="group__sched.html#gab51b1711cd73d890278e3998c817cc3a">		xnsched_run</a>();                                                \</div>
<div class="line">                __ret == XNSYNCH_RESCHED;                               \</div>
<div class="line">        })</div>
<div class="ttc" id="group__sched_html_gab51b1711cd73d890278e3998c817cc3a"><div class="ttname"><a href="group__sched.html#gab51b1711cd73d890278e3998c817cc3a">xnsched_run</a></div><div class="ttdeci">static int xnsched_run(void)</div><div class="ttdoc">The rescheduling procedure. </div><div class="ttdef"><b>Definition:</b> sched.h:261</div></div>
</div><!-- fragment -->
<p>Timed sleep on a locked waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>__cond</em> evaluates to true or a timeout occurs. The condition is checked each time the waitqueue <em>__wq</em> is signaled.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">__wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__cond</td><td>C expression for the event to wait for.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">__toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd>
<dd>
Passing RTDM_TIMEOUT_NONE to <em>__timeout</em> makes no sense for such service, and might cause unexpected behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="ga632e377a9ec9f08e191dcd86f567925b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define cobalt_atomic_enter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                            \</div>
<div class="line">                xnlock_get_irqsave(&amp;nklock, (context)); \</div>
<div class="line">                __xnsched_lock();                       \</div>
<div class="line">        } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Enter atomic section (dual kernel only) </p>
<p>This call opens a fully atomic section, serializing execution with respect to all interrupt handlers (including for real-time IRQs) and Xenomai threads running on all CPUs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>name of local variable to store the context in. This variable updated by the real-time core will hold the information required to leave the atomic section properly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Atomic sections may be nested.</dd>
<dd>
Since the strongest lock is acquired by this service, it can be used to synchronize real-time and non-real-time contexts.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This service is not portable to the Mercury core, and should be restricted to Cobalt-specific use cases. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64a86eb4e60d52143482c4665efbafc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define cobalt_atomic_leave</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                    \</div>
<div class="line">                __xnsched_unlock();                             \</div>
<div class="line">                xnlock_put_irqrestore(&amp;nklock, (context));      \</div>
<div class="line">        } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Leave atomic section (dual kernel only) </p>
<p>This call closes an atomic section previously opened by a call to <a class="el" href="group__rtdmsync.html#ga632e377a9ec9f08e191dcd86f567925b" title="Enter atomic section (dual kernel only) ">cobalt_atomic_enter()</a>, restoring the preemption and interrupt state which prevailed prior to entering the exited section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>name of local variable which stored the context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This service is not portable to the Mercury core, and should be restricted to Cobalt-specific use cases. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ebe81e9d2f951d3da8b205de40b25f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_RTDM_WAITQUEUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__name</td><td>)</td>
          <td>&#160;&#160;&#160;struct rtdm_waitqueue __name = <a class="el" href="group__rtdmsync.html#ga6cf0c5158a6f12e0ad6a701013e72f20">RTDM_WAITQUEUE_INITIALIZER</a>(__name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed sleep on a locked waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>__cond</em> evaluates to true or a timeout occurs. The condition is checked each time the waitqueue <em>__wq</em> is signaled.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">__wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__cond</td><td>C expression for the event to wait for.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">__toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd>
<dd>
Passing RTDM_TIMEOUT_NONE to <em>__timeout</em> makes no sense for such service, and might cause unexpected behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2780830a9f4f0d0f401f2dae9b1cb6b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_RTDM_WAITQUEUE_ONSTACK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__name</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga4ebe81e9d2f951d3da8b205de40b25f2">DEFINE_RTDM_WAITQUEUE</a>(__name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed sleep on a locked waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>__cond</em> evaluates to true or a timeout occurs. The condition is checked each time the waitqueue <em>__wq</em> is signaled.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">__wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__cond</td><td>C expression for the event to wait for.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">__toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd>
<dd>
Passing RTDM_TIMEOUT_NONE to <em>__timeout</em> makes no sense for such service, and might cause unexpected behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbaf52632d5dde7fa66e0b70d887493b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_EXECUTE_ATOMICALLY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">code_block</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                               \</div>
<div class="line">        &lt;ENTER_ATOMIC_SECTION&gt;                  \</div>
<div class="line">        code_block;                             \</div>
<div class="line">        &lt;LEAVE_ATOMIC_SECTION&gt;                  \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Execute code block atomically (DEPRECATED) </p>
<p>Generally, it is illegal to suspend the current task by calling <a class="el" href="group__rtdm__task.html#gabfae53746165a83a75965b7b0f6710a0" title="Sleep a specified amount of time. ">rtdm_task_sleep()</a>, <a class="el" href="group__rtdm__sync.html#ga1c433b50c53d49d164b084751861e855" title="Wait on event occurrence. ">rtdm_event_wait()</a>, etc. while holding a spinlock. In contrast, this macro allows to combine several operations including a potentially rescheduling call to an atomic code block with respect to other <a class="el" href="group__rtdmsync.html#gabbaf52632d5dde7fa66e0b70d887493b" title="Execute code block atomically (DEPRECATED) ">RTDM_EXECUTE_ATOMICALLY()</a> blocks. The macro is a light-weight alternative for protecting code blocks via mutexes, and it can even be used to synchronise real-time and non-real-time contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_block</td><td>Commands to be executed atomically</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to leave the code block explicitly by using <code>break</code>, <code>return</code>, <code>goto</code>, etc. This would leave the global lock held during the code block execution in an inconsistent state. Moreover, do not embed complex operations into the code bock. Consider that they will be executed under preemption lock with interrupts switched-off. Also note that invocation of rescheduling calls may break the atomicity until the task gains the CPU again.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible, depends on functions called within <em>code_block</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This construct is deprecated and will be phased out in Xenomai 3.0. Please use rtdm_waitqueue services instead. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ab65affd2b1f9975a79c73fb9ee16d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_for_each_waiter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__pos, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xnsynch_for_each_sleeper(__pos, &amp;(__wq)-&gt;wait)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple iterator for waitqueues. </p>
<p>This construct traverses the wait list of a given waitqueue <em>__wq</em>, assigning each RTDM task pointer to the cursor variable <em>__pos</em>, which must be of type rtdm_task_t.</p>
<p><em>__wq</em> must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to traversing its wait list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>cursor variable holding a pointer to the RTDM task being fetched.</td></tr>
    <tr><td class="paramname">__wq</td><td>waitqueue to scan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The waitqueue should not be signaled, broadcast or flushed during the traversal, unless the loop is aborted immediately after. Should multiple waiters be readied while iterating, the safe form <a class="el" href="group__rtdmsync.html#gae0757239f0378acf1cd2198290bf6c40" title="Safe iterator for waitqueues. ">rtdm_for_each_waiter_safe()</a> must be used for traversal instead. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0757239f0378acf1cd2198290bf6c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_for_each_waiter_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__pos, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__tmp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xnsynch_for_each_sleeper_safe(__pos, __tmp, &amp;(__wq)-&gt;wait)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe iterator for waitqueues. </p>
<p>This construct traverses the wait list of a given waitqueue <em>__wq</em>, assigning each RTDM task pointer to the cursor variable <em>__pos</em>, which must be of type rtdm_task_t.</p>
<p>Unlike with <a class="el" href="group__rtdmsync.html#ga3ab65affd2b1f9975a79c73fb9ee16d9" title="Simple iterator for waitqueues. ">rtdm_for_each_waiter()</a>, the waitqueue may be signaled, broadcast or flushed during the traversal.</p>
<p><em>__wq</em> must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to traversing its wait list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>cursor variable holding a pointer to the RTDM task being fetched.</td></tr>
    <tr><td class="paramname">__tmp</td><td>temporary cursor variable.</td></tr>
    <tr><td class="paramname">__wq</td><td>waitqueue to scan. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae03c387fcae8a55105dd31d7c008bbb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_irqrestore</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context</td><td>)</td>
          <td>&#160;&#160;&#160;splexit(context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore preemption state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>name of local variable which stored the context</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="ga3d563fc5def018f743c55c452e061758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_irqsave</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context</td><td>)</td>
          <td>&#160;&#160;&#160;splhigh(context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable preemption locally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>name of local variable to store the context in</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga60e6ca0e05c6cb30a6d1e0ce9b7eafbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_timedwait</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__timeout, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__toseq&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga2dfee9d5f85ee80a79ce62663fbf6b82">__rtdm_timedwait</a>(__wq, __timeout, __toseq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed sleep on a waitqueue unconditionally. </p>
<p>The calling task is put to sleep until the waitqueue is signaled by either <a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> or <a class="el" href="group__rtdmsync.html#ga3d6feb7d3c8f79cd223dd295b3de9457" title="Broadcast a waitqueue. ">rtdm_waitqueue_broadcast()</a>, or flushed by a call to <a class="el" href="group__rtdmsync.html#ga6dc5c1f3f54225def8d76f794ad9e19e" title="Flush a waitqueue. ">rtdm_waitqueue_flush()</a>, or a timeout occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">__wq</td><td>waitqueue to wait on.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">__toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if the waitqueue has been flushed, or the calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Passing RTDM_TIMEOUT_NONE to <em>__timeout</em> makes no sense for such service, and might cause unexpected behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75d09187c34d7562dc7f84d1c4c1d3b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_timedwait_condition</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__cond, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__timeout, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__toseq&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({                                                              \</div>
<div class="line">                spl_t __s;                                              \</div>
<div class="line">                int __ret;                                              \</div>
<div class="line">                xnlock_get_irqsave(&amp;nklock, __s);                       \</div>
<div class="line">                __ret = <a class="code" href="group__rtdmsync.html#ga56718462f6db9173fd091572452a1193">rtdm_timedwait_condition_locked</a>(__wq, __cond,   \</div>
<div class="line">                                              __timeout, __toseq);      \</div>
<div class="line">                xnlock_put_irqrestore(&amp;nklock, __s);                    \</div>
<div class="line">                __ret;                                                  \</div>
<div class="line">        })</div>
<div class="ttc" id="group__rtdmsync_html_ga56718462f6db9173fd091572452a1193"><div class="ttname"><a href="group__rtdmsync.html#ga56718462f6db9173fd091572452a1193">rtdm_timedwait_condition_locked</a></div><div class="ttdeci">#define rtdm_timedwait_condition_locked(__wq, __cond, __timeout, __toseq)</div><div class="ttdoc">Timed sleep on a locked waitqueue until a condition gets true. </div><div class="ttdef"><b>Definition:</b> driver.h:777</div></div>
</div><!-- fragment -->
<p>Timed sleep on a waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>__cond</em> evaluates to true or a timeout occurs. The condition is checked each time the waitqueue <em>__wq</em> is signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">__wq</td><td>waitqueue to wait on.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__cond</td><td>C expression for the event to wait for.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">__toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd>
<dd>
Passing RTDM_TIMEOUT_NONE to <em>__timeout</em> makes no sense for such service, and might cause unexpected behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="ga56718462f6db9173fd091572452a1193"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_timedwait_condition_locked</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__cond, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__timeout, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__toseq&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({                                                              \</div>
<div class="line">                int __ret = 0;                                          \</div>
<div class="line">                while (__ret == 0 &amp;&amp; !(__cond))                         \</div>
<div class="line">                        __ret = <a class="code" href="group__rtdmsync.html#ga2dfee9d5f85ee80a79ce62663fbf6b82">__rtdm_timedwait</a>(__wq, __timeout, __toseq); \</div>
<div class="line">                __ret;                                                  \</div>
<div class="line">        })</div>
<div class="ttc" id="group__rtdmsync_html_ga2dfee9d5f85ee80a79ce62663fbf6b82"><div class="ttname"><a href="group__rtdmsync.html#ga2dfee9d5f85ee80a79ce62663fbf6b82">__rtdm_timedwait</a></div><div class="ttdeci">static int __rtdm_timedwait(struct rtdm_waitqueue *wq, nanosecs_rel_t timeout, rtdm_toseq_t *toseq)</div><div class="ttdoc">Timed sleep on a locked waitqueue until a condition gets true. </div><div class="ttdef"><b>Definition:</b> driver.h:732</div></div>
</div><!-- fragment -->
<p>Timed sleep on a locked waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>__cond</em> evaluates to true or a timeout occurs. The condition is checked each time the waitqueue <em>__wq</em> is signaled.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">__wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__cond</td><td>C expression for the event to wait for.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">__toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd>
<dd>
Passing RTDM_TIMEOUT_NONE to <em>__timeout</em> makes no sense for such service, and might cause unexpected behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e17872489255a832d36bcfe6130079c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_timedwait_locked</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__timeout, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__toseq&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga60e6ca0e05c6cb30a6d1e0ce9b7eafbd">rtdm_timedwait</a>(__wq, __timeout, __toseq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed sleep on a locked waitqueue unconditionally. </p>
<p>The calling task is put to sleep until the waitqueue is signaled by either <a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> or <a class="el" href="group__rtdmsync.html#ga3d6feb7d3c8f79cd223dd295b3de9457" title="Broadcast a waitqueue. ">rtdm_waitqueue_broadcast()</a>, or flushed by a call to <a class="el" href="group__rtdmsync.html#ga6dc5c1f3f54225def8d76f794ad9e19e" title="Flush a waitqueue. ">rtdm_waitqueue_flush()</a>, or a timeout occurs.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">__wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">__toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if the waitqueue has been flushed, or the calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Passing RTDM_TIMEOUT_NONE to <em>__timeout</em> makes no sense for such service, and might cause unexpected behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f1699da8fc9cd786226a78ca9dc45df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_wait</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq</td><td>)</td>
          <td>&#160;&#160;&#160;xnsynch_sleep_on(&amp;(__wq)-&gt;wait,	XN_INFINITE, XN_RELATIVE)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep on a waitqueue unconditionally. </p>
<p>The calling task is put to sleep until the waitqueue is signaled by either <a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> or <a class="el" href="group__rtdmsync.html#ga3d6feb7d3c8f79cd223dd295b3de9457" title="Broadcast a waitqueue. ">rtdm_waitqueue_broadcast()</a>, or flushed by a call to <a class="el" href="group__rtdmsync.html#ga6dc5c1f3f54225def8d76f794ad9e19e" title="Flush a waitqueue. ">rtdm_waitqueue_flush()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__wq</td><td>waitqueue to wait on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if the waitqueue has been flushed, or the calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga84e0b2f39cbf0aeef224992f1dc8941a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_wait_condition</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__cond&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({                                                              \</div>
<div class="line">                spl_t __s;                                              \</div>
<div class="line">                int __ret;                                              \</div>
<div class="line">                xnlock_get_irqsave(&amp;nklock, __s);                       \</div>
<div class="line">                __ret = <a class="code" href="group__rtdmsync.html#ga8b3a609277c14def3f81da42fd4ea8ed">rtdm_wait_condition_locked</a>(__wq, __cond);       \</div>
<div class="line">                xnlock_put_irqrestore(&amp;nklock, __s);                    \</div>
<div class="line">                __ret;                                                  \</div>
<div class="line">        })</div>
<div class="ttc" id="group__rtdmsync_html_ga8b3a609277c14def3f81da42fd4ea8ed"><div class="ttname"><a href="group__rtdmsync.html#ga8b3a609277c14def3f81da42fd4ea8ed">rtdm_wait_condition_locked</a></div><div class="ttdeci">#define rtdm_wait_condition_locked(__wq, __cond)</div><div class="ttdoc">Sleep on a locked waitqueue until a condition gets true. </div><div class="ttdef"><b>Definition:</b> driver.h:809</div></div>
</div><!-- fragment -->
<p>Sleep on a waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>__cond</em> evaluates to true. The condition is checked each time the waitqueue <em>__wq</em> is signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__wq</td><td>waitqueue to wait on</td></tr>
    <tr><td class="paramname">__cond</td><td>C expression for the event to wait for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b3a609277c14def3f81da42fd4ea8ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_wait_condition_locked</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__cond&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({                                                              \</div>
<div class="line">                int __ret = 0;                                          \</div>
<div class="line">                while (__ret == 0 &amp;&amp; !(__cond))                         \</div>
<div class="line">                        __ret = xnsynch_sleep_on(&amp;(__wq)-&gt;wait,         \</div>
<div class="line">                                                 XN_INFINITE, XN_RELATIVE); \</div>
<div class="line">                __ret;                                                  \</div>
<div class="line">        })</div>
</div><!-- fragment -->
<p>Sleep on a locked waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>__cond</em> evaluates to true. The condition is checked each time the waitqueue <em>__wq</em> is signaled.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramname">__cond</td><td>C expression for the event to wait for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a9050ae82a8d04cb3c2e30f9e5a690f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_wait_locked</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga8f1699da8fc9cd786226a78ca9dc45df">rtdm_wait</a>(__wq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep on a locked waitqueue unconditionally. </p>
<p>The calling task is put to sleep until the waitqueue is signaled by either <a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> or <a class="el" href="group__rtdmsync.html#ga3d6feb7d3c8f79cd223dd295b3de9457" title="Broadcast a waitqueue. ">rtdm_waitqueue_broadcast()</a>, or flushed by a call to <a class="el" href="group__rtdmsync.html#ga6dc5c1f3f54225def8d76f794ad9e19e" title="Flush a waitqueue. ">rtdm_waitqueue_flush()</a>.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if the waitqueue has been flushed, or the calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga3d6feb7d3c8f79cd223dd295b3de9457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_waitqueue_broadcast</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga69d480bf6aabc7c5fdc4138bce1ef9bf">__rtdm_waitqueue_flush</a>(__wq, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcast a waitqueue. </p>
<p>Broadcast the waitqueue <em>__wq</em>, waking up all waiters. Each readied task may assume to have received the wake up event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__wq</td><td>waitqueue to broadcast.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if at least one task has been readied as a result of this call, zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6dc5c1f3f54225def8d76f794ad9e19e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_waitqueue_flush</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga69d480bf6aabc7c5fdc4138bce1ef9bf">__rtdm_waitqueue_flush</a>(__wq, <a class="el" href="group__core__thread__info.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush a waitqueue. </p>
<p>Flushes the waitqueue <em>__wq</em>, unblocking all waiters with an error status (-EINTR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__wq</td><td>waitqueue to flush.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if at least one task has been readied as a result of this call, zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6cf0c5158a6f12e0ad6a701013e72f20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_WAITQUEUE_INITIALIZER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                \</div>
<div class="line">            .wait = XNSYNCH_WAITQUEUE_INITIALIZER((__name).wait), \</div>
<div class="line">        }</div>
</div><!-- fragment -->
<p>Timed sleep on a locked waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>__cond</em> evaluates to true or a timeout occurs. The condition is checked each time the waitqueue <em>__wq</em> is signaled.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">__wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__cond</td><td>C expression for the event to wait for.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">__toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd>
<dd>
Passing RTDM_TIMEOUT_NONE to <em>__timeout</em> makes no sense for such service, and might cause unexpected behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8787a0ed5be95c924afad0a4924f64c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_waitqueue_lock</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__context&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga632e377a9ec9f08e191dcd86f567925b">cobalt_atomic_enter</a>(__context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a waitqueue. </p>
<p>Acquires the lock on the waitqueue <em>__wq</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__wq</td><td>waitqueue to lock.</td></tr>
    <tr><td class="paramname">context</td><td>name of local variable to store the context in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Recursive locking might lead to unexpected behavior, including lock up. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c4263d3aead70a86852df6cb11da412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_waitqueue_signal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({                                                              \</div>
<div class="line">                struct xnthread *__waiter;                              \</div>
<div class="line">                __waiter = xnsynch_wakeup_one_sleeper(&amp;(__wq)-&gt;wait);   <a class="code" href="group__sched.html#gab51b1711cd73d890278e3998c817cc3a">\</a></div>
<div class="line"><a class="code" href="group__sched.html#gab51b1711cd73d890278e3998c817cc3a">		xnsched_run</a>();                                                \</div>
<div class="line">                __waiter != NULL;                                       \</div>
<div class="line">        })</div>
<div class="ttc" id="group__sched_html_gab51b1711cd73d890278e3998c817cc3a"><div class="ttname"><a href="group__sched.html#gab51b1711cd73d890278e3998c817cc3a">xnsched_run</a></div><div class="ttdeci">static int xnsched_run(void)</div><div class="ttdoc">The rescheduling procedure. </div><div class="ttdef"><b>Definition:</b> sched.h:261</div></div>
</div><!-- fragment -->
<p>Signal a waitqueue. </p>
<p>Signals the waitqueue <em>__wq</em>, waking up a single waiter (if any).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__wq</td><td>waitqueue to signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if a task has been readied as a result of this call, zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa992132a4d2d5a1c24eac6f54a966fc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_waitqueue_unlock</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__context&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__rtdmsync.html#ga64a86eb4e60d52143482c4665efbafc6">cobalt_atomic_leave</a>(__context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a waitqueue. </p>
<p>Releases the lock on the waitqueue <em>__wq</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__wq</td><td>waitqueue to unlock.</td></tr>
    <tr><td class="paramname">context</td><td>name of local variable to store the context in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12e77ab2e99628b393ef291a5ad6a4de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_waitqueue_wakeup</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__waiter&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                            \</div>
<div class="line">                xnsynch_wakeup_this_sleeper(&amp;(__wq)-&gt;wait, __waiter);   <a class="code" href="group__sched.html#gab51b1711cd73d890278e3998c817cc3a">\</a></div>
<div class="line"><a class="code" href="group__sched.html#gab51b1711cd73d890278e3998c817cc3a">		xnsched_run</a>();                                                \</div>
<div class="line">        } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="group__sched_html_gab51b1711cd73d890278e3998c817cc3a"><div class="ttname"><a href="group__sched.html#gab51b1711cd73d890278e3998c817cc3a">xnsched_run</a></div><div class="ttdeci">static int xnsched_run(void)</div><div class="ttdoc">The rescheduling procedure. </div><div class="ttdef"><b>Definition:</b> sched.h:261</div></div>
</div><!-- fragment -->
<p>Signal a particular waiter on a waitqueue. </p>
<p>Signals the waitqueue <em>__wq</em>, waking up waiter <em>__waiter</em> only, which must be currently sleeping on the waitqueue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__wq</td><td>waitqueue to signal.</td></tr>
    <tr><td class="paramname">__waiter</td><td>RTDM task to wake up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga0bbb1e7c98ac3a3968aba970f99709ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct rtdm_waitqueue <a class="el" href="group__rtdmsync.html#ga0bbb1e7c98ac3a3968aba970f99709ed">rtdm_waitqueue_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed sleep on a locked waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>__cond</em> evaluates to true or a timeout occurs. The condition is checked each time the waitqueue <em>__wq</em> is signaled.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">__wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__cond</td><td>C expression for the event to wait for.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">__toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd>
<dd>
Passing RTDM_TIMEOUT_NONE to <em>__timeout</em> makes no sense for such service, and might cause unexpected behavior. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gae18228df8c70c9da1f90f61b01e92501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a3ddb0fbad9f52ad3646be2e5a6ba8b2b"></a>RTDM_SELECTTYPE_READ</em>&#160;</td><td class="fielddoc">
<p>Select input data availability events. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a37819f609dee2b20852001e9b7ecd462"></a>RTDM_SELECTTYPE_WRITE</em>&#160;</td><td class="fielddoc">
<p>Select ouput buffer availability events. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a2dd10c612a9e3c7e5134ee122ee3de74"></a>RTDM_SELECTTYPE_EXCEPT</em>&#160;</td><td class="fielddoc">
<p>Select exceptional events. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaebcf9945def75c805f63db30d5f9e521"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__rtdmsync.html#ga7584217487c323356414e21200a57e63">rtdm_lockctx_t</a> __rtdm_lock_get_irqsave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire lock and disable preemption, by stalling the head domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Address of lock variable </td></tr>
    <tr><td class="paramname">context</td><td>name of local variable to store the context in</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga2dfee9d5f85ee80a79ce62663fbf6b82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int __rtdm_timedwait </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_waitqueue *&#160;</td>
          <td class="paramname"><em>wq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&#160;</td>
          <td class="paramname"><em>toseq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timed sleep on a locked waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>__cond</em> evaluates to true or a timeout occurs. The condition is checked each time the waitqueue <em>__wq</em> is signaled.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdmsync.html#ga8787a0ed5be95c924afad0a4924f64c8" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">__wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__cond</td><td>C expression for the event to wait for.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">__timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">__toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdmsync.html#ga0c4263d3aead70a86852df6cb11da412" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd>
<dd>
Passing RTDM_TIMEOUT_NONE to <em>__timeout</em> makes no sense for such service, and might cause unexpected behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="ga77fe54d2ce88096711e8cc4e48d45a28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rtdm_lock_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire lock from non-preemptible contexts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Address of lock variable</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga8b0fa498c3141c5f05e072e9af35eaeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rtdm_lock_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic lock initialisation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Address of lock variable</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga9f7c052e195b4936941cf67f50c006e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rtdm_lock_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release lock without preemption restoration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Address of lock variable</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga9892fad6532c2022229d30234196d44b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rtdm_lock_put_irqrestore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#gacbc89e880b42154cb65aa8317195dc03">rtdm_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga7584217487c323356414e21200a57e63">rtdm_lockctx_t</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release lock and restore preemption state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Address of lock variable </td></tr>
    <tr><td class="paramname">context</td><td>name of local variable which stored the context</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>Referenced by <a class="el" href="group__rtdm__util.html#gab0b2db892afe1bd77a80f6b8367eb0c9">rtdm_ratelimit()</a>.</p>

</div>
</div>
<a class="anchor" id="gab63f5e06b9eb600cbbb026e19f56a648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rtdm_waitqueue_destroy </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_waitqueue *&#160;</td>
          <td class="paramname"><em>wq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes a RTDM wait queue. </p>
<p>Dismantles a wait queue structure, releasing all resources attached to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae5bf4fbd58e352d50e99fb7c2f95bfa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rtdm_waitqueue_init </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_waitqueue *&#160;</td>
          <td class="paramname"><em>wq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a RTDM wait queue. </p>
<p>Sets up a wait queue structure for further use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
