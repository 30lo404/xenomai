<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Xenomai: Real-time shadow services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">2.99.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__shadow.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Real-time shadow services.</div>  </div>
</div><!--header-->
<div class="contents">

<p>Copyright (C) 2001-2013 Philippe Gerum <a href="#" onclick="location.href='mai'+'lto:'+'rpm'+'@x'+'eno'+'ma'+'i.o'+'rg'; return false;">rpm@x<span style="display: none;">.nosp@m.</span>enom<span style="display: none;">.nosp@m.</span>ai.or<span style="display: none;">.nosp@m.</span>g</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5f631762c7381866d70177afb2ba123b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shadow.html#ga5f631762c7381866d70177afb2ba123b">xnshadow_harden</a> (void)</td></tr>
<tr class="memdesc:ga5f631762c7381866d70177afb2ba123b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate a Linux task to the Xenomai domain.  <a href="#ga5f631762c7381866d70177afb2ba123b">More...</a><br/></td></tr>
<tr class="separator:ga5f631762c7381866d70177afb2ba123b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de86a334ac2c5aeeebccf88fcee03ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shadow.html#ga8de86a334ac2c5aeeebccf88fcee03ab">xnshadow_relax</a> (int notify, int reason)</td></tr>
<tr class="memdesc:ga8de86a334ac2c5aeeebccf88fcee03ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch a shadow thread back to the Linux domain.  <a href="#ga8de86a334ac2c5aeeebccf88fcee03ab">More...</a><br/></td></tr>
<tr class="separator:ga8de86a334ac2c5aeeebccf88fcee03ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5406a4aa8f22383274b72e7b97a95db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shadow.html#gaa5406a4aa8f22383274b72e7b97a95db">xnshadow_map_user</a> (struct xnthread *thread, unsigned long __user *u_window_offset)</td></tr>
<tr class="memdesc:gaa5406a4aa8f22383274b72e7b97a95db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shadow thread context over a user task.  <a href="#gaa5406a4aa8f22383274b72e7b97a95db">More...</a><br/></td></tr>
<tr class="separator:gaa5406a4aa8f22383274b72e7b97a95db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba63f9344c05367feec840a3189d274"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shadow.html#gaeba63f9344c05367feec840a3189d274">xnshadow_map_kernel</a> (struct xnthread *thread, struct completion *done)</td></tr>
<tr class="memdesc:gaeba63f9344c05367feec840a3189d274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shadow thread context over a kernel task.  <a href="#gaeba63f9344c05367feec840a3189d274">More...</a><br/></td></tr>
<tr class="separator:gaeba63f9344c05367feec840a3189d274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2600cb0433d0fd7b02fa5e610ab43b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shadow.html#gaf2600cb0433d0fd7b02fa5e610ab43b3">xnshadow_register_personality</a> (struct xnpersonality *personality)</td></tr>
<tr class="memdesc:gaf2600cb0433d0fd7b02fa5e610ab43b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new interface personality.  <a href="#gaf2600cb0433d0fd7b02fa5e610ab43b3">More...</a><br/></td></tr>
<tr class="separator:gaf2600cb0433d0fd7b02fa5e610ab43b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134589ff53c1ec5535220b57904e0745"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shadow.html#ga134589ff53c1ec5535220b57904e0745">xnshadow_get_context</a> (unsigned int muxid)</td></tr>
<tr class="memdesc:ga134589ff53c1ec5535220b57904e0745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the per-process data attached to the calling process.  <a href="#ga134589ff53c1ec5535220b57904e0745">More...</a><br/></td></tr>
<tr class="separator:ga134589ff53c1ec5535220b57904e0745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b47e5e52bbe73d484651473e850933"><td class="memItemLeft" align="right" valign="top">struct xnpersonality *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shadow.html#ga53b47e5e52bbe73d484651473e850933">xnshadow_push_personality</a> (int muxid)</td></tr>
<tr class="memdesc:ga53b47e5e52bbe73d484651473e850933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack a new personality over the current thread.  <a href="#ga53b47e5e52bbe73d484651473e850933">More...</a><br/></td></tr>
<tr class="separator:ga53b47e5e52bbe73d484651473e850933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59536b179e4c94a61e348f2a848f220"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shadow.html#gad59536b179e4c94a61e348f2a848f220">xnshadow_pop_personality</a> (struct xnpersonality *prev)</td></tr>
<tr class="memdesc:gad59536b179e4c94a61e348f2a848f220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the topmost personality from the current thread.  <a href="#gad59536b179e4c94a61e348f2a848f220">More...</a><br/></td></tr>
<tr class="separator:gad59536b179e4c94a61e348f2a848f220"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Copyright (C) 2001-2013 Philippe Gerum <a href="#" onclick="location.href='mai'+'lto:'+'rpm'+'@x'+'eno'+'ma'+'i.o'+'rg'; return false;">rpm@x<span style="display: none;">.nosp@m.</span>enom<span style="display: none;">.nosp@m.</span>ai.or<span style="display: none;">.nosp@m.</span>g</a>. </p>
<p>Copyright (C) 2001-2013 The Xenomai project <a href="http://www.xenomai.org">http://www.xenomai.org</a> Copyright (C) 2006 Gilles Chanteperdrix <a href="#" onclick="location.href='mai'+'lto:'+'gil'+'le'+'s.c'+'ha'+'nte'+'pe'+'rdr'+'ix'+'@xe'+'no'+'mai'+'.o'+'rg'; return false;">gille<span style="display: none;">.nosp@m.</span>s.ch<span style="display: none;">.nosp@m.</span>antep<span style="display: none;">.nosp@m.</span>erdr<span style="display: none;">.nosp@m.</span>ix@xe<span style="display: none;">.nosp@m.</span>noma<span style="display: none;">.nosp@m.</span>i.org</a></p>
<p>SMP support Copyright (C) 2004 The HYADES project <a href="http://www.hyades-itea.org">http://www.hyades-itea.org</a> RTAI/fusion Copyright (C) 2004 The RTAI project <a href="http://www.rtai.org">http://www.rtai.org</a></p>
<p>Xenomai is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>
<p>Xenomai is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with Xenomai; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</p>
<p>Real-time shadow services. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga134589ff53c1ec5535220b57904e0745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* xnshadow_get_context </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>muxid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the per-process data attached to the calling process. </p>
<p>This service returns the per-process data attached to the calling process for the personality whose muxid is <em>muxid</em>. It must be called with nklock locked, irqs off.</p>
<p>See <a class="el" href="group__shadow.html#gaf2600cb0433d0fd7b02fa5e610ab43b3" title="Register a new interface personality. ">xnshadow_register_personality()</a> documentation for information on the way to attach a per-process data to a process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">muxid</td><td>the personality muxid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the per-process data if the current context is a user-space process; </dd>
<dd>
NULL otherwise.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Tags: atomic-entry. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f631762c7381866d70177afb2ba123b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnshadow_harden </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate a Linux task to the Xenomai domain. </p>
<p>This service causes the transition of "current" from the Linux domain to Xenomai. The shadow will resume in the Xenomai domain as returning from schedule().</p>
<dl class="section remark"><dt>Remarks</dt><dd>Tags: secondary-only, might-switch. </dd></dl>

<p>References <a class="el" href="group__shadow.html#ga8de86a334ac2c5aeeebccf88fcee03ab">xnshadow_relax()</a>.</p>

<p>Referenced by <a class="el" href="group__shadow.html#gaeba63f9344c05367feec840a3189d274">xnshadow_map_kernel()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeba63f9344c05367feec840a3189d274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnshadow_map_kernel </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct completion *&#160;</td>
          <td class="paramname"><em>done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a shadow thread context over a kernel task. </p>
<p>This call maps a nucleus thread to the "current" Linux task running in kernel space. The priority and scheduling class of the underlying Linux task are not affected; it is assumed that the caller did set them appropriately before issuing the shadow mapping request.</p>
<p>This call immediately moves the calling kernel thread to the Xenomai domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the new shadow thread to be mapped to "current". This descriptor must have been previously initialized by a call to <a class="el" href="group__thread.html#ga75a7e56d8c8ea2c7462db4d7a35f228e" title="Initialize a new thread. ">xnthread_init()</a>.</td></tr>
    <tr><td class="paramname">done</td><td>A completion object to be signaled when <em>thread</em> is fully mapped over the current Linux context, waiting for <a class="el" href="group__thread.html#gabedfb90d24b08db04e49b168d290e032" title="Start a newly created thread. ">xnthread_start()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ERESTARTSYS is returned if the current Linux task has received a signal, thus preventing the final migration to the Xenomai domain (i.e. in order to process the signal in the Linux domain). This error should not be considered as fatal.</li>
<li>-EPERM is returned if the shadow thread has been killed before the current task had a chance to return to the caller. In such a case, the real-time mapping operation has failed globally, and no Xenomai resource remains attached to it.</li>
<li>-EINVAL is returned if the thread control block bears the XNUSER bit.</li>
<li>-EBUSY is returned if either the current Linux task or the associated shadow thread is already involved in a shadow mapping.</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>Tags: secondary-only, might-switch. </dd></dl>

<p>References <a class="el" href="group__shadow.html#ga5f631762c7381866d70177afb2ba123b">xnshadow_harden()</a>, <a class="el" href="group__thread.html#ga9321320f5f883f20a4cb411ce585f115">xnthread_resume()</a>, and <a class="el" href="group__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc">xnthread_suspend()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa5406a4aa8f22383274b72e7b97a95db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnshadow_map_user </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long __user *&#160;</td>
          <td class="paramname"><em>u_window_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a shadow thread context over a user task. </p>
<p>This call maps a nucleus thread to the "current" Linux task running in userland. The priority and scheduling class of the underlying Linux task are not affected; it is assumed that the interface library did set them appropriately before issuing the shadow mapping request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the new shadow thread to be mapped to "current". This descriptor must have been previously initialized by a call to <a class="el" href="group__thread.html#ga75a7e56d8c8ea2c7462db4d7a35f228e" title="Initialize a new thread. ">xnthread_init()</a>.</td></tr>
    <tr><td class="paramname">u_window_offset</td><td>will receive the offset of the per-thread "u_window" structure in the process shared heap associated to <em>thread</em>. This structure reflects thread state information visible from userland through a shared memory window.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if the thread control block does not bear the XNUSER bit.</li>
<li>-EBUSY is returned if either the current Linux task or the associated shadow thread is already involved in a shadow mapping.</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>Tags: secondary-only. </dd></dl>

<p>References <a class="el" href="group__heap.html#ga8364a6c83d8de2107698e37e1094f23d">xnheap_alloc()</a>, <a class="el" href="group__thread.html#gabedfb90d24b08db04e49b168d290e032">xnthread_start()</a>, and <a class="el" href="group__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc">xnthread_suspend()</a>.</p>

</div>
</div>
<a class="anchor" id="gad59536b179e4c94a61e348f2a848f220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnshadow_pop_personality </td>
          <td>(</td>
          <td class="paramtype">struct xnpersonality *&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop the topmost personality from the current thread. </p>
<p>This service pops the topmost personality off the current thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>the previous personality which was returned by the latest call to <a class="el" href="group__shadow.html#ga53b47e5e52bbe73d484651473e850933" title="Stack a new personality over the current thread. ">xnshadow_push_personality()</a> for the current thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Tags: secondary-only. </dd></dl>

</div>
</div>
<a class="anchor" id="ga53b47e5e52bbe73d484651473e850933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnpersonality* xnshadow_push_personality </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>muxid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack a new personality over the current thread. </p>
<p>This service registers the current thread as a member of the additional personality identified by <em>muxid</em>. If the current thread is already assigned this personality, the call returns successfully with no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">muxid</td><td>the identifier of the additional personality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the previous personality. The caller should save this handle for unstacking <em>muxid</em> when applicable via a call to <a class="el" href="group__shadow.html#gad59536b179e4c94a61e348f2a848f220" title="Pop the topmost personality from the current thread. ">xnshadow_pop_personality()</a>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Tags: secondary-only. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2600cb0433d0fd7b02fa5e610ab43b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnshadow_register_personality </td>
          <td>(</td>
          <td class="paramtype">struct xnpersonality *&#160;</td>
          <td class="paramname"><em>personality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a new interface personality. </p>
<ul>
<li><p class="startli">personality-&gt;ops.attach_process() is called when a user-space process binds to the personality, on behalf of one of its threads. The attach_process() handler may return:</p>
<p class="startli">. an opaque pointer, representing the context of the calling process for this personality;</p>
<p class="startli">. a NULL pointer, meaning that no per-process structure should be attached to this process for this personality;</p>
<p class="startli">. ERR_PTR(negative value) indicating an error, the binding process will then abort.</p>
</li>
<li>personality-&gt;ops.detach() is called on behalf of an exiting user-space process which has previously attached to the personality. This handler is passed a pointer to the per-process data received earlier from the ops-&gt;attach_process() handler.</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>Tags: none. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8de86a334ac2c5aeeebccf88fcee03ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnshadow_relax </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>notify</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch a shadow thread back to the Linux domain. </p>
<p>This service yields the control of the running shadow back to Linux. This is obtained by suspending the shadow and scheduling a wake up call for the mated user task inside the Linux domain. The Linux task will resume on return from <a class="el" href="group__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc" title="Suspend a thread. ">xnthread_suspend()</a> on behalf of the root thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notify</td><td>A boolean flag indicating whether threads monitored from secondary mode switches should be sent a SIGDEBUG signal. For instance, some internal operations like task exit should not trigger such signal.</td></tr>
    <tr><td class="paramname">reason</td><td>The reason to report along with the SIGDEBUG signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Tags: primary-only, might-switch.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>"current" is valid here since the shadow runs with the properties of the Linux task. </dd></dl>

<p>References <a class="el" href="group__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc">xnthread_suspend()</a>.</p>

<p>Referenced by <a class="el" href="group__shadow.html#ga5f631762c7381866d70177afb2ba123b">xnshadow_harden()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
