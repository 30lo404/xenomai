<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Xenomai: Interrupt management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">2.99.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cobalt__core__irq.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Interrupt management<div class="ingroups"><a class="el" href="group__cobalt__core.html">Cobalt kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Interrupt management:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__cobalt__core__irq.png" border="0" alt="" usemap="#group____cobalt____core____irq"/>
<map name="group____cobalt____core____irq" id="group____cobalt____core____irq">
<area shape="rect" id="node2" href="group__cobalt__core.html" title="The Cobalt core is a co&#45;kernel which supplements the Linux kernel for delivering real&#45;time services w..." alt="" coords="5,5,104,32"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2f4d355b8f1e30ac47eb6cdf5b15052a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#ga2f4d355b8f1e30ac47eb6cdf5b15052a">xnintr_destroy</a> (struct xnintr *intr)</td></tr>
<tr class="memdesc:ga2f4d355b8f1e30ac47eb6cdf5b15052a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an interrupt object.  <a href="#ga2f4d355b8f1e30ac47eb6cdf5b15052a">More...</a><br/></td></tr>
<tr class="separator:ga2f4d355b8f1e30ac47eb6cdf5b15052a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3daaec8f96ae24a57e390c2bb52a7dd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#ga3daaec8f96ae24a57e390c2bb52a7dd8">xnintr_attach</a> (struct xnintr *intr, void *cookie)</td></tr>
<tr class="memdesc:ga3daaec8f96ae24a57e390c2bb52a7dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach an interrupt object.  <a href="#ga3daaec8f96ae24a57e390c2bb52a7dd8">More...</a><br/></td></tr>
<tr class="separator:ga3daaec8f96ae24a57e390c2bb52a7dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d82d8a287980c1075d70b8e5df6a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#ga40d82d8a287980c1075d70b8e5df6a77">xnintr_detach</a> (struct xnintr *intr)</td></tr>
<tr class="memdesc:ga40d82d8a287980c1075d70b8e5df6a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach an interrupt object.  <a href="#ga40d82d8a287980c1075d70b8e5df6a77">More...</a><br/></td></tr>
<tr class="separator:ga40d82d8a287980c1075d70b8e5df6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb629c2fda5f3400a86c7139100eebff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#gacb629c2fda5f3400a86c7139100eebff">xnintr_enable</a> (struct xnintr *intr)</td></tr>
<tr class="memdesc:gacb629c2fda5f3400a86c7139100eebff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable an interrupt object.  <a href="#gacb629c2fda5f3400a86c7139100eebff">More...</a><br/></td></tr>
<tr class="separator:gacb629c2fda5f3400a86c7139100eebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd483fe4979b3250d2f4ef830ec704ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#gadd483fe4979b3250d2f4ef830ec704ac">xnintr_disable</a> (struct xnintr *intr)</td></tr>
<tr class="memdesc:gadd483fe4979b3250d2f4ef830ec704ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable an interrupt object.  <a href="#gadd483fe4979b3250d2f4ef830ec704ac">More...</a><br/></td></tr>
<tr class="separator:gadd483fe4979b3250d2f4ef830ec704ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f60c3d81107d58d52e3c44d9f8e8a97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#ga1f60c3d81107d58d52e3c44d9f8e8a97">xnintr_affinity</a> (struct xnintr *intr, cpumask_t cpumask)</td></tr>
<tr class="memdesc:ga1f60c3d81107d58d52e3c44d9f8e8a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt's processor affinity.  <a href="#ga1f60c3d81107d58d52e3c44d9f8e8a97">More...</a><br/></td></tr>
<tr class="separator:ga1f60c3d81107d58d52e3c44d9f8e8a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bcb3882ee1fc8f5580db7f66b2730b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#ga2bcb3882ee1fc8f5580db7f66b2730b9">xnintr_init</a> (struct xnintr *intr, const char *name, unsigned int irq, xnisr_t isr, xniack_t iack, int flags)</td></tr>
<tr class="memdesc:ga2bcb3882ee1fc8f5580db7f66b2730b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an interrupt object.  <a href="#ga2bcb3882ee1fc8f5580db7f66b2730b9">More...</a><br/></td></tr>
<tr class="separator:ga2bcb3882ee1fc8f5580db7f66b2730b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1f60c3d81107d58d52e3c44d9f8e8a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnintr_affinity </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpumask_t&#160;</td>
          <td class="paramname"><em>cpumask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt's processor affinity. </p>
<p>Restricts the IRQ associated with the interrupt object <em>intr</em> to be received only on processors which bits are set in <em>cpumask</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The descriptor address of the interrupt object which affinity is to be changed.</td></tr>
    <tr><td class="paramname">cpumask</td><td>The new processor affinity of the interrupt object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Depending on architectures, setting more than one bit in <em>cpumask</em> could be meaningless.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3daaec8f96ae24a57e390c2bb52a7dd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnintr_attach </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach an interrupt object. </p>
<p>Attach an interrupt object previously initialized by <a class="el" href="group__cobalt__core__irq.html#ga2bcb3882ee1fc8f5580db7f66b2730b9" title="Initialize an interrupt object. ">xnintr_init()</a>. After this operation is completed, all IRQs received from the corresponding interrupt channel are directed to the object's ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The descriptor address of the interrupt object to attach.</td></tr>
    <tr><td class="paramname">cookie</td><td>A user-defined opaque value which is stored into the interrupt object descriptor for further retrieval by the ISR/ISR handlers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if a low-level error occurred while attaching the interrupt.</li>
<li>-EBUSY is returned if the interrupt object was already attached.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The caller <b>must not</b> hold nklock when invoking this service, this would cause deadlocks.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Attaching an interrupt resets the tracked number of receipts to zero. </dd></dl>

<p>Referenced by <a class="el" href="group__rtdm__irq.html#ga9bb3d95218ac5261e4033fb0bf695073">rtdm_irq_request()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2f4d355b8f1e30ac47eb6cdf5b15052a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnintr_destroy </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an interrupt object. </p>
<p>Destroys an interrupt object previously initialized by <a class="el" href="group__cobalt__core__irq.html#ga2bcb3882ee1fc8f5580db7f66b2730b9" title="Initialize an interrupt object. ">xnintr_init()</a>. The interrupt object is automatically detached by a call to <a class="el" href="group__cobalt__core__irq.html#ga40d82d8a287980c1075d70b8e5df6a77" title="Detach an interrupt object. ">xnintr_detach()</a>. No more IRQs will be dispatched by this object after this service has returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The descriptor address of the interrupt object to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__irq.html#ga40d82d8a287980c1075d70b8e5df6a77">xnintr_detach()</a>.</p>

</div>
</div>
<a class="anchor" id="ga40d82d8a287980c1075d70b8e5df6a77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnintr_detach </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach an interrupt object. </p>
<p>Detach an interrupt object previously attached by <a class="el" href="group__cobalt__core__irq.html#ga3daaec8f96ae24a57e390c2bb52a7dd8" title="Attach an interrupt object. ">xnintr_attach()</a>. After this operation is completed, no more IRQs are directed to the object's ISR, but the interrupt object itself remains valid. A detached interrupt object can be attached again by a subsequent call to <a class="el" href="group__cobalt__core__irq.html#ga3daaec8f96ae24a57e390c2bb52a7dd8" title="Attach an interrupt object. ">xnintr_attach()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The descriptor address of the interrupt object to detach.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller <b>must not</b> hold nklock when invoking this service, this would cause deadlocks.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p>Referenced by <a class="el" href="group__cobalt__core__irq.html#ga2f4d355b8f1e30ac47eb6cdf5b15052a">xnintr_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="gadd483fe4979b3250d2f4ef830ec704ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnintr_disable </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable an interrupt object. </p>
<p>Disables the hardware interrupt line associated with an interrupt object. This operation invalidates further interrupt requests from the given source until the IRQ line is re-enabled anew.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The descriptor address of the interrupt object to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacb629c2fda5f3400a86c7139100eebff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnintr_enable </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable an interrupt object. </p>
<p>Enables the hardware interrupt line associated with an interrupt object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The descriptor address of the interrupt object to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p>Referenced by <a class="el" href="group__rtdm__irq.html#ga9bb3d95218ac5261e4033fb0bf695073">rtdm_irq_request()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2bcb3882ee1fc8f5580db7f66b2730b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnintr_init </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnisr_t&#160;</td>
          <td class="paramname"><em>isr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xniack_t&#160;</td>
          <td class="paramname"><em>iack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an interrupt object. </p>
<p>Associates an interrupt object with an IRQ line.</p>
<p>When an interrupt occurs on the given <em>irq</em> line, the ISR is fired in order to deal with the hardware event. The interrupt service code may call any non-blocking service from the nucleus.</p>
<p>Upon receipt of an IRQ, the ISR is immediately called on behalf of the interrupted stack context, the rescheduling procedure is locked, and the interrupt source is masked at hardware level. The status value returned by the ISR is then checked for the following values:</p>
<ul>
<li>XN_ISR_HANDLED indicates that the interrupt request has been fulfilled by the ISR.</li>
<li>XN_ISR_NONE indicates the opposite to XN_ISR_HANDLED. The ISR must always return this value when it determines that the interrupt request has not been issued by the dedicated hardware device.</li>
</ul>
<p>In addition, one of the following bits may be set by the ISR :</p>
<dl class="section warning"><dt>Warning</dt><dd>Use these bits with care and only when you do understand their effect on the system. The ISR is not encouraged to use these bits in case it shares the IRQ line with other ISRs in the real-time domain.</dd></dl>
<ul>
<li>XN_ISR_NOENABLE prevents the IRQ line from being re-enabled after the ISR has returned.</li>
<li>XN_ISR_PROPAGATE causes the IRQ event to be propagated down the pipeline to Linux. This is the regular way to share interrupts between the nucleus and the regular Linux kernel. In effect, XN_ISR_PROPAGATE implies XN_ISR_NOENABLE since it would make no sense to re-enable the IRQ line before the Linux kernel had a chance to process the propagated interrupt.</li>
</ul>
<p>A count of interrupt receipts is tracked into the interrupt descriptor, and reset to zero each time the interrupt object is attached. Since this count could wrap around, it should be used as an indication of interrupt activity only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The address of a interrupt object descriptor the nucleus will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the interrupt object or NULL.</td></tr>
    <tr><td class="paramname">irq</td><td>The hardware interrupt channel associated with the interrupt object. This value is architecture-dependent. An interrupt object must then be attached to the hardware interrupt vector using the <a class="el" href="group__cobalt__core__irq.html#ga3daaec8f96ae24a57e390c2bb52a7dd8" title="Attach an interrupt object. ">xnintr_attach()</a> service for the associated IRQs to be directed to this object.</td></tr>
    <tr><td class="paramname">isr</td><td>The address of a valid low-level interrupt service routine if this parameter is non-zero. This handler will be called each time the corresponding IRQ is delivered on behalf of an interrupt context. When called, the ISR is passed the descriptor address of the interrupt object.</td></tr>
    <tr><td class="paramname">iack</td><td>The address of an optional interrupt acknowledge routine, aimed at replacing the default one. Only very specific situations actually require to override the default setting for this parameter, like having to acknowledge non-standard PIC hardware. <em>iack</em> should return a non-zero value to indicate that the interrupt has been properly acknowledged. If <em>iack</em> is NULL, the default routine will be used instead.</td></tr>
    <tr><td class="paramname">flags</td><td>A set of creation flags affecting the operation. The valid flags are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XN_ISR_SHARED enables IRQ-sharing with other interrupt objects.</li>
<li>XN_ISR_EDGE is an additional flag need to be set together with XN_ISR_SHARED to enable IRQ-sharing of edge-triggered interrupts.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if <em>irq</em> is not a valid interrupt number.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p>Referenced by <a class="el" href="group__rtdm__irq.html#ga9bb3d95218ac5261e4033fb0bf695073">rtdm_irq_request()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
