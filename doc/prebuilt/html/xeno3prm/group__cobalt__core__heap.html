<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Xenomai: Dynamic memory allocation services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">2.99.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cobalt__core__heap.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dynamic memory allocation services<div class="ingroups"><a class="el" href="group__cobalt__core.html">Cobalt kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The implementation of the memory allocator follows the algorithm described in a USENIX 1988 paper called "Design of a General
   Purpose Memory Allocator for the 4.3BSD Unix Kernel" by Marshall K.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Dynamic memory allocation services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__cobalt__core__heap.png" border="0" alt="" usemap="#group____cobalt____core____heap"/>
<map name="group____cobalt____core____heap" id="group____cobalt____core____heap">
<area shape="rect" id="node2" href="group__cobalt__core.html" title="The Cobalt core is a co&#45;kernel which supplements the Linux kernel for delivering real&#45;time services w..." alt="" coords="5,12,104,39"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga46ec3f0391885e558897d3d6247371d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__heap.html#ga46ec3f0391885e558897d3d6247371d2">xnheap_init</a> (struct xnheap *heap, void *heapaddr, unsigned long heapsize, unsigned long pagesize)</td></tr>
<tr class="memdesc:ga46ec3f0391885e558897d3d6247371d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a memory heap.  <a href="#ga46ec3f0391885e558897d3d6247371d2">More...</a><br/></td></tr>
<tr class="separator:ga46ec3f0391885e558897d3d6247371d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485ed258772616fd14c0103a6a878bad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__heap.html#ga485ed258772616fd14c0103a6a878bad">xnheap_set_label</a> (struct xnheap *heap, const char *name,...)</td></tr>
<tr class="memdesc:ga485ed258772616fd14c0103a6a878bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the heap's label string.  <a href="#ga485ed258772616fd14c0103a6a878bad">More...</a><br/></td></tr>
<tr class="separator:ga485ed258772616fd14c0103a6a878bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac07ec12e4bdb1f1ff63f2727fb430748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__heap.html#gac07ec12e4bdb1f1ff63f2727fb430748">xnheap_destroy</a> (struct xnheap *heap, void(*flushfn)(struct xnheap *heap, void *extaddr, unsigned long extsize, void *cookie), void *cookie)</td></tr>
<tr class="memdesc:gac07ec12e4bdb1f1ff63f2727fb430748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a memory heap.  <a href="#gac07ec12e4bdb1f1ff63f2727fb430748">More...</a><br/></td></tr>
<tr class="separator:gac07ec12e4bdb1f1ff63f2727fb430748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080f13d224800f54fc0382f401ca17bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__heap.html#ga080f13d224800f54fc0382f401ca17bf">xnheap_extend</a> (struct xnheap *heap, void *extaddr, unsigned long extsize)</td></tr>
<tr class="memdesc:ga080f13d224800f54fc0382f401ca17bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend a memory heap.  <a href="#ga080f13d224800f54fc0382f401ca17bf">More...</a><br/></td></tr>
<tr class="separator:ga080f13d224800f54fc0382f401ca17bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82304bf6434465e7591b6b774028c1de"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__heap.html#ga82304bf6434465e7591b6b774028c1de">xnheap_alloc</a> (struct xnheap *heap, unsigned long size)</td></tr>
<tr class="memdesc:ga82304bf6434465e7591b6b774028c1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory heap.  <a href="#ga82304bf6434465e7591b6b774028c1de">More...</a><br/></td></tr>
<tr class="separator:ga82304bf6434465e7591b6b774028c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7f31608030ac6a38b2e8840903293f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__heap.html#gaa7f31608030ac6a38b2e8840903293f2">xnheap_test_and_free</a> (struct xnheap *heap, void *block, int(*ckfn)(void *block))</td></tr>
<tr class="memdesc:gaa7f31608030ac6a38b2e8840903293f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test and release a memory block to a memory heap.  <a href="#gaa7f31608030ac6a38b2e8840903293f2">More...</a><br/></td></tr>
<tr class="separator:gaa7f31608030ac6a38b2e8840903293f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f8f9ad974282669efcfe4e71d859173"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__heap.html#ga3f8f9ad974282669efcfe4e71d859173">xnheap_free</a> (struct xnheap *heap, void *block)</td></tr>
<tr class="memdesc:ga3f8f9ad974282669efcfe4e71d859173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a memory block to a memory heap.  <a href="#ga3f8f9ad974282669efcfe4e71d859173">More...</a><br/></td></tr>
<tr class="separator:ga3f8f9ad974282669efcfe4e71d859173"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The implementation of the memory allocator follows the algorithm described in a USENIX 1988 paper called "Design of a General
   Purpose Memory Allocator for the 4.3BSD Unix Kernel" by Marshall K. </p>
<p>McKusick and Michael J. Karels. You can find it at various locations on the net, including <a href="http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf">http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf</a>. A minor variation allows this implementation to have 'extendable' heaps when needed, with multiple memory extents providing autonomous page address spaces.</p>
<p>The data structures hierarchy is as follows:</p>
<p><code></p>
<pre class="fragment">HEAP {
     block_buckets[]
     extent_queue -------+
}                        |
                         V
                      EXTENT #1 {
                             {static header}
                             page_map[npages]
                             page_array[npages][pagesize]
                      } -+
                         |
                         |
                         V
                      EXTENT #n {
                             {static header}
                             page_map[npages]
                             page_array[npages][pagesize]
                      }
</pre><p> </code></p>
<dl class="section user"><dt>Implementation constraints</dt><dd></dd></dl>
<ul>
<li>Minimum page size is 2 ** XNHEAP_MINLOG2 (must be large enough to hold a pointer).</li>
<li>Maximum page size is 2 ** XNHEAP_MAXLOG2.</li>
<li>Minimum block size equals the minimum page size.</li>
<li>Requested block size smaller than the minimum block size is rounded to the minimum block size.</li>
<li>Requested block size larger than 2 times the page size is rounded to the next page boundary and obtained from the free page list. So we need a bucket for each power of two between XNHEAP_MINLOG2 and XNHEAP_MAXLOG2 inclusive, plus one to honor requests ranging from the maximum page size to twice this size. </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga82304bf6434465e7591b6b774028c1de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * xnheap_alloc </td>
          <td>(</td>
          <td class="paramtype">struct xnheap *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory heap. </p>
<p>Allocates a contiguous region of memory from an active memory heap. Such allocation is guaranteed to be time-bounded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The descriptor address of the heap to get memory from.</td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the requested block. Sizes lower or equal to the page size are rounded either to the minimum allocation size if lower than this value, or to the minimum alignment size if greater or equal to this value. In the current implementation, with MINALLOC = 8 and MINALIGN = 16, a 7 bytes request will be rounded to 8 bytes, and a 17 bytes request will be rounded to 32.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the allocated region upon success, or NULL if no memory is available from the specified heap.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

<p>Referenced by <a class="el" href="group__cobalt__core__shadow.html#gaa5406a4aa8f22383274b72e7b97a95db">xnshadow_map_user()</a>.</p>

</div>
</div>
<a class="anchor" id="gac07ec12e4bdb1f1ff63f2727fb430748"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnheap_destroy </td>
          <td>(</td>
          <td class="paramtype">struct xnheap *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct xnheap *heap, void *extaddr, unsigned long extsize, void *cookie)&#160;</td>
          <td class="paramname"><em>flushfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a memory heap. </p>
<p>Destroys a memory heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The descriptor address of the destroyed heap.</td></tr>
    <tr><td class="paramname">flushfn</td><td>If non-NULL, the address of a flush routine which will be called for each extent attached to the heap. This routine can be used by the calling code to further release the heap memory.</td></tr>
    <tr><td class="paramname">cookie</td><td>If <em>flushfn</em> is non-NULL, <em>cookie</em> is an opaque pointer which will be passed unmodified to <em>flushfn</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga080f13d224800f54fc0382f401ca17bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnheap_extend </td>
          <td>(</td>
          <td class="paramtype">struct xnheap *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>extaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>extsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend a memory heap. </p>
<p>Add a new extent to an existing memory heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The descriptor address of the heap to add an extent to.</td></tr>
    <tr><td class="paramname">extaddr</td><td>The address of the extent memory.</td></tr>
    <tr><td class="paramname">extsize</td><td>The size of the extent memory (in bytes). In the current implementation, this size must match the one of the initial extent passed to <a class="el" href="group__cobalt__core__heap.html#ga46ec3f0391885e558897d3d6247371d2" title="Initialize a memory heap. ">xnheap_init()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success, or -EINVAL is returned if <em>extsize</em> differs from the initial extent's size.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f8f9ad974282669efcfe4e71d859173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnheap_free </td>
          <td>(</td>
          <td class="paramtype">struct xnheap *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a memory block to a memory heap. </p>
<p>Releases a memory region to the memory heap it was previously allocated from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The descriptor address of the heap to release memory to.</td></tr>
    <tr><td class="paramname">block</td><td>The address of the region to be returned to the heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success, or one of the following error codes:</dd></dl>
<ul>
<li>-EFAULT is returned whenever the memory address is outside the heap address space.</li>
<li>-EINVAL is returned whenever the memory address does not represent a valid block.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__heap.html#gaa7f31608030ac6a38b2e8840903293f2">xnheap_test_and_free()</a>.</p>

</div>
</div>
<a class="anchor" id="ga46ec3f0391885e558897d3d6247371d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnheap_init </td>
          <td>(</td>
          <td class="paramtype">struct xnheap *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>heapaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>heapsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a memory heap. </p>
<p>Initializes a memory heap suitable for time-bounded allocation requests of dynamic memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The address of a heap descriptor which will be used to store the allocation data. This descriptor must always be valid while the heap is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td class="paramname">heapaddr</td><td>The address of the heap storage area. All allocations will be made from the given area in time-bounded mode. Since additional extents can be added to a heap, this parameter is also known as the "initial extent".</td></tr>
    <tr><td class="paramname">heapsize</td><td>The size in bytes of the initial extent pointed at by <em>heapaddr</em>. <em>heapsize</em> must be a multiple of pagesize and lower than 16 Mbytes. <em>heapsize</em> must be large enough to contain a dynamically-sized internal header. The following formula gives the size of this header:<br/>
 H = heapsize, P=pagesize, M=sizeof(struct pagemap), E=sizeof(struct xnextent)<br/>
hdrsize = ((H - E) * M) / (M + 1)<br/>
 This value is then aligned on the next 16-byte boundary. The routine xnheap_overhead() computes the corrected heap size according to the previous formula.</td></tr>
    <tr><td class="paramname">pagesize</td><td>The size in bytes of the fundamental memory page which will be used to subdivide the heap internally. Choosing the right page size is important regarding performance and memory fragmentation issues, so it might be a good idea to take a look at <a href="http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf">http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf</a> to pick the best one for your needs. In the current implementation, pagesize must be a power of two in the range [ 8 .. 32768 ] inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success, or one of the following error codes:</dd></dl>
<ul>
<li>-EINVAL is returned whenever a parameter is invalid.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga485ed258772616fd14c0103a6a878bad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnheap_set_label </td>
          <td>(</td>
          <td class="paramtype">struct xnheap *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the heap's label string. </p>
<p>Set the heap label that will be used in statistic outputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The address of a heap descriptor.</td></tr>
    <tr><td class="paramname">label</td><td>Label string displayed in statistic outputs. This parameter can be a format string, in which case succeeding parameters will be used to resolve the final label.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7f31608030ac6a38b2e8840903293f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnheap_test_and_free </td>
          <td>(</td>
          <td class="paramtype">struct xnheap *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *block)&#160;</td>
          <td class="paramname"><em>ckfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test and release a memory block to a memory heap. </p>
<p>Releases a memory region to the memory heap it was previously allocated from. Before the actual release is performed, an optional user-defined can be invoked to check for additional criteria with respect to the request consistency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The descriptor address of the heap to release memory to.</td></tr>
    <tr><td class="paramname">block</td><td>The address of the region to be returned to the heap.</td></tr>
    <tr><td class="paramname">ckfn</td><td>The address of a user-supplied verification routine which is to be called after the memory address specified by <em>block</em> has been checked for validity. The routine is expected to proceed to further consistency checks, and either return zero upon success, or non-zero upon error. In the latter case, the release process is aborted, and <em>ckfn's</em> return value is passed back to the caller of this service as its error return code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><em>ckfn</em> must not reschedule either directly or indirectly.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success, or -EINVAL is returned whenever the block is not a valid region of the specified heap. Additional return codes can also be defined locally by the <em>ckfn</em> routine.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

<p>Referenced by <a class="el" href="group__cobalt__core__heap.html#ga3f8f9ad974282669efcfe4e71d859173">xnheap_free()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
