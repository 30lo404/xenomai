<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.8" />
<title>Migrating from Xenomai 2.x to 3.x</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}


#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(3);
/*]]>*/
</script>
</head>
<body class="article" style="max-width:55em">
<div id="header">
<h1>Migrating from Xenomai 2.x to 3.x</h1>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_configuration">1. Configuration</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_user_programs_and_libraries">1.1. User programs and libraries</h3>
<div class="ulist"><ul>
<li>
<p>
As with Xenomai 2.x, <code>xeno-config</code> is available for retrieving the
compilation and link flags for building Xenomai 3.x applications. This
script will work for both the Cobalt and Mercury environments
indifferently.
</p>
<div class="ulist"><ul>
<li>
<p>
Each <code>--skin=&lt;api&gt;</code> option specifier can be abbreviated as
 --&lt;api&gt;. For instance, <code>--psos</code> is a shorthand for <code>--skin=psos</code> on
 the command line.
</p>
</li>
<li>
<p>
Specifying <code>--[skin=]cobalt</code> or <code>--[skin=]posix</code> on the command line
  is strictly equivalent. However, this does not make sense with
  <em>Mercury</em> which does not define these switches.
</p>
</li>
<li>
<p>
<code>--[skin=]alchemy</code> replaces the former <code>--skin=native</code> switch.
</p>
</li>
<li>
<p>
<code>--core</code> can be used to retrieve the name of the Xenomai core system
  for which <code>xeno-config</code> was generated. Possible output values are
  <code>cobalt</code> and <code>mercury</code>.
</p>
</li>
<li>
<p>
<code>--ccld</code> retrieves a C compiler command suitable for linking a
   Xenomai 3.x application.
</p>
</li>
<li>
<p>
<code>--no-auto-init</code> can be passed to disable automatic initialization
  of the Copperplate library when the application process enters the
  <code>main()</code> routine. In such a case, the application code using any API
  based on the Copperplate layer, shall call the <code>copperplate_init()</code>
  routine manually, as part of its initialization process, <em>before</em>
  any real-time service is invoked.
</p>
<div class="literalblock" id="auto-init">
<div class="content">
<pre><code>+xeno-config+ enables the Copperplate auto-init feature by default.</code></pre>
</div></div>
</li>
</ul></div>
</li>
<li>
<p>
<code>--enable-x86-sep</code> was renamed to <code>--enable-x86-vsyscall</code> to fix a
  misnomer. This option should be left enabled (default), unless
  <strong>linuxthreads</strong> are used instead of <strong>NPTL</strong>.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_kernel_parameters_cobalt">1.2. Kernel parameters (Cobalt)</h3>
<div class="ulist"><ul>
<li>
<p>
System parameters have been renamed:
</p>
</li>
</ul></div>
<div class="paragraph"><p>xeno_hal.supported_cpus &#8594; xenomai.supported_cpus</p></div>
<div class="paragraph"><p>xeno_hal.clockfreq &#8594; xenomai.clockfreq</p></div>
<div class="paragraph"><p>xeno_hal.disable &#8594; xenomai.disable</p></div>
<div class="paragraph"><p>xeno_hal.timerfreq &#8594; xenomai.timerfreq</p></div>
<div class="paragraph"><p>xeno_hal.cpufreq &#8594; xenomai.cpufreq</p></div>
<div class="paragraph"><p>xeno_nucleus.watchdog_timeout &#8594; xenomai.watchdog_timeout</p></div>
<div class="paragraph"><p>xeno_nucleus.xenomai_gid &#8594; xenomai.xenomai_gid</p></div>
<div class="paragraph"><p>xeno_nucleus.sysheap_size &#8594; xenomai.sysheap_size</p></div>
<div class="paragraph"><p>xeno_hal.smi (x86 only) &#8594; xeno_machine.smi</p></div>
<div class="paragraph"><p>xeno_hal.smi_mask (x86 only) &#8594; xeno_machine.smi_mask</p></div>
<div class="paragraph"><p>xeno_rtdm.devname_hashtab_size &#8594; rtdm.devname_hashtab_size</p></div>
<div class="paragraph"><p>xeno_rtdm.protocol_hashtab_size &#8594; rtdm.protocol_hashtab_size</p></div>
<div class="ulist"><ul>
<li>
<p>
The following parameters have been dropped
</p>
</li>
</ul></div>
<div class="paragraph"><p>xeno_rtdm.tick_arg.
.Rationale</p></div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph"><p>Periodic timing is directly handled from the API layer in
user-space. Cobalt kernel timing is tickless.</p></div>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_the_system_state">2. Getting the system state</h2>
<div class="sectionbody">
<div class="paragraph"><p>Querying the state of the real-time system should be done via the new
Xenomai registery interface available with Xenomai 3.x, which is
turned on when <code>--enable-registry</code> is passed to the configuration
script for building the Xenomai libraries and programs.</p></div>
<div class="paragraph"><p>The new registry support is common to the Cobalt and Mercury cores,
with only marginal differences due to the presence (or lack of) co-
kernel in the system.</p></div>
<div class="sect2">
<h3 id="_new_fuse_based_registry_interface">2.1. New FUSE-based registry interface</h3>
<div class="paragraph"><p>The Xenomai system state is now fully exported via a FUSE-based
filesystem.  The hierarchy of the Xenomai registry is organized as
follows:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    /mount-point            /* registry fs root, defaults to /mnt/xenomai */
        /session            /* shared session name or "anon" */
            /pid            /* application (main) pid */
               /skin        /* API name: alchemy/vxworks/psos/... */
                  /family   /* object class (task, semaphore, ...) */
                     { exported objects... }
            /system         /* session-wide information */</code></pre>
</div></div>
<div class="paragraph"><p>Each leaf entry under a session hierarchy is normally viewable, for
retrieving the information attached to the corresponding object, such
as its state, and/or value. There can be multiple sessions hosted
under a single registry mount point. Session-less application
processes are grouped under the special "anon" hierarchy.</p></div>
<div class="paragraph"><p>The /system hierarchy provides information about the current state of
the Xenomai core, aggregating data from all processes which belong to
the parent session. Typically, the status of all threads and heaps
created by the session can be retrieved.</p></div>
<div class="paragraph"><p>The registry daemon is a companion tool managing exactly one registry
mount point, which is specified by the --root option on the command
line. This daemon is automatically spawned by the registry support
code as required. There is normally no action required from users for
managing it.</p></div>
</div>
<div class="sect2">
<h3 id="_legacy_proc_xenomai_interface">2.2. Legacy /proc/xenomai interface</h3>
<div class="paragraph"><p>The legacy /proc/xenomai interface is still available when running
over the Cobalt core. The following changes compared to Xenomai 2.x
took place though:</p></div>
<div class="ulist"><ul>
<li>
<p>
Thread status
</p>
</li>
</ul></div>
<div class="paragraph"><p>All pseudo-files reporting the various thread states moved under the
new <code>sched/</code> hierarchy, i.e.</p></div>
<div class="paragraph"><p><code>{sched, stat, acct}</code> &#8594; <code>sched/{threads, stat, acct}</code></p></div>
<div class="ulist"><ul>
<li>
<p>
Clocks
</p>
</li>
</ul></div>
<div class="paragraph"><p>With the introduction of dynamic clock registration in the Cobalt
core, the <code>clock/</code> hierarchy was added, to reflect the current state
of all timers from the registered Xenomai clocks.</p></div>
<div class="paragraph"><p>There is no kernel-based time base management anymore with Xenomai
2.99.6. Functionally speaking, only the former <em>master</em> time base
remains, periodic timing is now controlled locally from the Xenomai
libraries in user-space.</p></div>
<div class="paragraph"><p>Xenomai 2.99.6 defines a built-in clock named <em>coreclk</em>, which has
the same properties than the former <em>master</em> time base available with
Xenomai 2.x (i.e. tickless with nanosecond resolution).</p></div>
<div class="paragraph"><p>The settings of existing clocks can be read from entries under the new
clock/ hierarchy. Active timers for each clock can be read from
entries under the new timer/ hierarchy.</p></div>
<div class="paragraph"><p>As a consequence of these changes:</p></div>
<div class="ulist"><ul>
<li>
<p>
the information previously available from the <code>timer</code> entry is now
obtained by reading <code>clock/coreclk</code>.
</p>
</li>
<li>
<p>
the information previously available from <code>timerstat/master</code> is now
obtained by reading +timer/coreclk.
</p>
</li>
<li>
<p>
Core clock gravity
</p>
</li>
</ul></div>
<div class="paragraph"><p>The gravity value for a Xenomai clock gives the amount of time by
which the next timer shot should be anticipated.</p></div>
<div class="paragraph"><p>This is a static adjustment value, to account for the basic latency of
the target system for responding to external events. Such latency may
be introduced by hardware effects (e.g. bus or cache latency), or
software issues (e.g. code running with interrupts disabled).</p></div>
<div class="paragraph"><p>The clock gravity management departs from Xenomai 2.x as follows:</p></div>
<div class="ulist"><ul>
<li>
<p>
different gravity values are applied, depending on which context a
  timer activates. This may be a real-time IRQ handler (<em>irq</em>), a RTDM
  driver task (<em>kernel</em>), or a Xenomai application thread running in
  user-space (<em>user</em>). Xenomai 2.x does not differentiate, only
  applying a global gravity value regardless of the activated context.
</p>
</li>
<li>
<p>
in addition to the legacy <code>latency</code> file which now reports the
  <em>user</em> timer gravity (in nanoseconds), i.e. used for timers
  activating user-space threads, the full gravity triplet applied to
  timers running on the core clock can be accessed by reading
  clock/coreclk (also in nanoseconds).
</p>
</li>
<li>
<p>
at reset, the <em>user</em> gravity for the core clock now represents the
sum of the scheduling <strong>and</strong> hardware timer reprogramming time as a
count of nanoseconds. This departs from Xenomai 2.x for which only the
former was accounted for as a global gravity value, regardless of the
target context for the timer.
</p>
</li>
</ul></div>
<div class="paragraph"><p>The following command reports the current gravity triplet for the
target system, along with the setup information for the core timer:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># cat xenomai/clock/coreclk
gravity: irq=848 kernel=8272 user=35303
devices: timer=decrementer, clock=timebase
 status: on+watchdog
  setup: 151
  ticks: 220862243033</code></pre>
</div></div>
<div class="paragraph"><p>Conversely, writing to this file manually changes the gravity values
of the Xenomai core clock:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    /* change the user gravity (default) */
# echo 3000 &gt; /proc/xenomai/clock/coreclck
    /* change the IRQ gravity */
# echo 1000i &gt; /proc/xenomai/clock/coreclck
    /* change the user and kernel gravities */
# echo "2000u 1000k" &gt; /proc/xenomai/clock/coreclck</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
<code>interfaces</code> was removed
</p>
</li>
</ul></div>
<div class="paragraph"><p>Only the POSIX and RTDM APIs remain implemented directly in kernel
space, and are always present when the Cobalt core enabled in the
configuration. All other APIs are implemented in user-space over the
Copperplate layer. This makes the former <code>interfaces</code> contents
basically useless, since the corresponding information for the
POSIX/RTDM interfaces can be obtained via <code>sched/threads</code>
unconditionally.</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>registry/usage</code> changed format
</p>
</li>
</ul></div>
<div class="paragraph"><p>The new print out is %&lt;used slot count&gt;/%&lt;total slot count&gt;.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_binary_object_features">3. Binary object features</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_loading_xenomai_libraries_dynamically">3.1. Loading Xenomai libraries dynamically</h3>
<div class="paragraph"><p>The new <code>--enable-dlopen-libs</code> configuration switch must be turned on
to allow Xenomai libaries to be dynamically loaded via dlopen(3).</p></div>
<div class="paragraph"><p>This replaces the former <code>--enable-dlopen-skins</code> switch. Unlike the
latter, <code>--enable-dlopen-libs</code> does not implicitly disable support for
thread local storage, but rather selects a suitable TLS model
(i.e. <em>global-dynamic</em>).</p></div>
</div>
<div class="sect2">
<h3 id="_thread_local_storage">3.2. Thread local storage</h3>
<div class="paragraph"><p>The former <code>--with-__thread</code> configuration switch was renamed
<code>--enable-tls</code>.</p></div>
<div class="paragraph"><p>As mentioned earlier, TLS is now available to dynamically loaded
Xenomai libraries, e.g. <code>--enable-tls --enable-dlopen-libs</code> on a
configuration line is valid. This would select the <em>global-dynamic</em>
TLS model instead of <em>initial-exec</em>, to make sure all thread-local
variables may be accessed from any code module.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_process_level_management">4. Process-level management</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_main_thread_shadowing">4.1. Main thread shadowing</h3>
<div class="paragraph"><p>By default, any application linking against <code>libcobalt</code> has its main
thread attached to the real-time system automatically, this process is
called <em>auto-shadowing</em>.</p></div>
<div class="paragraph"><p>This behavior may be disabled at runtime, by setting the XENO_NOSHADOW
variable in the application process environment, before the
<code>libcobalt</code> library constructors are executed.</p></div>
<div class="paragraph"><p>This replaces the former static mechanism available with Xenomai 2.x,
based on turning on <code>--enable-dlopen-skins</code> when configuring. Starting
with Xenomai 3.x, applications should set the XENO_NOSHADOW variable
using putenv(3), before loading <code>libcolbalt</code> using dlopen(3).</p></div>
<div class="paragraph"><p>When auto-shadowing is enabled, global memory locking is also
performed, and remains in effect afterwards
(i.e. mlockall(MCL_CURRENT|MCL_FUTURE)).</p></div>
</div>
<div class="sect2">
<h3 id="_shadow_signal_handler">4.2. Shadow signal handler</h3>
<div class="paragraph"><p>Xenomai&#8217;s <code>libcobalt</code> installs a handler for the SIGWINCH (aka
<em>SIGSHADOW</em>) signal. This signal may be sent by the Cobalt core to any
real-time application, for handling internal duties.</p></div>
<div class="paragraph"><p>Applications are allowed to interpose on the SIGSHADOW handler,
provided they first forward all signal notifications to this routine,
then eventually handle all events the Xenomai handler won&#8217;t process.</p></div>
<div class="paragraph"><p>This handler was renamed from <code>xeno_sigwinch_handler()</code> (Xenomai 2.x)
to <code>cobalt_sigshadow_handler()</code> in Xenomai 3.x. The function prototype
did not change though, i.e.:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>int cobalt_sigshadow_handler(int sig, siginfo_t *si, void *ctxt)</code></pre>
</div></div>
<div class="paragraph"><p>A non-zero value is returned whenever the event was handled internally
by the Xenomai system.</p></div>
</div>
<div class="sect2">
<h3 id="_debug_signal_handler">4.3. Debug signal handler</h3>
<div class="paragraph"><p>Xenomai&#8217;s <code>libcobalt</code> installs a handler for the SIGXCPU (aka
<em>SIGDEBUG</em>) signal. This signal may be sent by the Cobalt core to any
real-time application, for notifying various debug events.</p></div>
<div class="paragraph"><p>Applications are allowed to interpose on the SIGDEBUG handler,
provided they eventually forward all signal notifications they won&#8217;t
process to the Xenomai handler.</p></div>
<div class="paragraph"><p>This handler was renamed from <code>xeno_handle_mlock_alert()</code> (Xenomai
2.x) to <code>cobalt_sigdebug_handler()</code> in Xenomai 3.x. The function
prototype did not change though, i.e.:</p></div>
<div class="paragraph"><p><code>void cobalt_sigdebug_handler(int sig, siginfo_t *si, void *ctxt)</code></p></div>
</div>
<div class="sect2">
<h3 id="_copperplate_auto_initialization">4.4. Copperplate auto-initialization</h3>
<div class="paragraph"><p>Copperplate is a library layer which mediates between the real-time
core services available on the platform, and the API exposed to the
application. It provides typical programming abstractions for
emulating real-time APIs. All non-POSIX APIs are based on Copperplate
services (e.g. <em>alchemy</em>, <em>psos</em>, <em>vxworks</em>).</p></div>
<div class="paragraph"><p>When Copperplate is built for running over the Cobalt core, it sits on
top of the <code>libcobalt</code> library. Conversely, it is directly stacked on
top of the <strong>glibc</strong> when built for running over the Mercury core.</p></div>
<div class="paragraph"><p>Normally, Copperplate should initialize from a call issued by the
<code>main()</code> application routine. To make this process transparent for the
user, the <code>xeno-config</code> script emits link flags which temporarily
overrides the <code>main()</code> routine with a Copperplate-based replacement,
running the proper initialization code as required, before branching
back to the user-defined application entry point.</p></div>
<div class="paragraph"><p>This behavior may be disabled by passing the
<a href="#auto-init"><code>--no-auto-init</code></a> option.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rtdm_interface_changes">5. RTDM interface changes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_files_renamed">5.1. Files renamed</h3>
<div class="ulist"><ul>
<li>
<p>
Redundant prefixes were removed from the following files:
</p>
</li>
</ul></div>
<div class="paragraph"><p>rtdm/rtdm_driver.h &#8594; rtdm/driver.h</p></div>
<div class="paragraph"><p>rtdm/rtcan.h &#8594; rtdm/can.h</p></div>
<div class="paragraph"><p>rtdm/rtserial.h &#8594; rtdm/serial.h</p></div>
<div class="paragraph"><p>rtdm/rttesting.h &#8594; rtdm/testing.h</p></div>
<div class="paragraph"><p>rtdm/rtipc.h &#8594; rtdm/ipc.h</p></div>
</div>
<div class="sect2">
<h3 id="_driver_api">5.2. Driver API</h3>
<div class="ulist"><ul>
<li>
<p>
rtdm_task_init() shall be called from secondary mode.
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>Since Xenomai 3, rtdm_task_init() involves creating a regular kernel
thread, which will be given real-time capabilities, such as running
under the control of the Cobalt kernel. In order to invoke standard
kernel services, rtdm_task_init() must be called from a regular Linux
kernel context.</p></div>
</div></div>
<div class="ulist"><ul>
<li>
<p>
rtdm_task_join() has been introduced to wait for termination of a
  RTDM task regardless of the caller&#8217;s execution mode, which may be
  primary or secondary. In addition, rtdm_task_join() does not need to
  poll for such event unlike rtdm_task_join_nrt().
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>rtdm_task_join() supersedes rtdm_task_join_nrt() feature-wise with
less usage restrictions, therefore the latter has become pointless. It
is therefore deprecated and will be phased out in the next release.</p></div>
</div></div>
<div class="ulist"><ul>
<li>
<p>
A RTDM task cannot be forcibly removed from the scheduler by another
  thread for immediate deletion. Instead, the RTDM task is notified
  about a pending cancellation request, which it should act upon when
  detected. To this end, RTDM driver tasks should call the new
  <code>rtdm_task_should_stop()</code> service to detect such notification from
  their work loop, and exit accordingly.
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>Since Xenomai 3, a RTDM task is based on a regular kernel thread with
real-time capabilities when controlled by the Cobalt kernel. The Linux
kernel requires kernel threads to exit at their earliest convenience
upon notification, which therefore applies to RTDM tasks as well.</p></div>
</div></div>
<div class="ulist"><ul>
<li>
<p>
<code>rtdm_task_set_period()</code> does not suspend the target task until the
first release point is reached. If a start date is specified, then
<code>rtdm_task_wait_period()</code> will apply the initial delay.
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>A periodic RTDM task has to call <code>rtdm_task_wait_period()</code> from within
its work loop for sleeping until the next release point is
reached. Since waiting for the initial and subsequent release points
will most often happen at the same code location in the driver, the
semantics of <code>rtdm_task_set_period()</code> can be simplified so that only
<code>rtdm_task_wait_period()</code> may block the caller.</p></div>
</div></div>
<div class="ulist"><ul>
<li>
<p>
RTDM_EXECUTE_ATOMICALLY() is deprecated and will be phased out in
  the next release. Drivers should prefer the newly introduced RTDM
  wait queues, or switch to the Cobalt-specific
  cobalt_atomic_enter/leave() call pair, depending on the use case.
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>This construct is not portable to a native implementation of RTDM, and
may be replaced by other means. The usage patterns of
RTDM_EXECUTE_ATOMICALLY() used to be:</p></div>
<div class="ulist"><ul>
<li>
<p>
somewhat abusing the big nucleus lock (i.e. nklock) grabbed by
  RTDM_EXECUTE_ATOMICALLY(), for serializing access to a section that
  should be given its own lock instead, improving concurrency in the
  same move. Such section does not call services from the Xenomai
  core, and does NOT specifically require the nucleus lock to be
  held. In this case, a RTDM lock (rtdm_lock_t) should be used to
  protect the section instead of RTDM_EXECUTE_ATOMICALLY().
</p>
</li>
<li>
<p>
protecting a section which calls into the Xenomai core, which
  exhibits one or more of the following characteristics:
</p>
<div class="ulist"><ul>
<li>
<p>
Some callee within the section may require the nucleus lock to
      be held on entry (e.g. Cobalt registry lookup). In what has to
      be a Cobalt-specific case, the new cobalt_atomic_enter/leave()
      call pair can replace RTDM_EXECUTE_ATOMICALLY(). However, this
      construct remains by definition non-portable to Mercury.
</p>
</li>
<li>
<p>
A set-condition-and-wakeup pattern has to be carried out
      atomically. In this case, RTDM_EXECUTE_ATOMICALLY() can be
      replaced by the wakeup side of a RTDM wait queue introduced in
      Xenomai 3 (e.g. rtdm_waitqueue_signal/broadcast()).
</p>
</li>
<li>
<p>
A test-condition-and-wait pattern has to be carried out
      atomically. In this case, RTDM_EXECUTE_ATOMICALLY() can be
      replaced by the wait side of a RTDM wait queue introduced in
      Xenomai 3 (e.g. rtdm_wait_condition()).
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="paragraph"><p>Refer to kernel/drivers/ipc/iddp.c for an illustration of the RTDM
wait queue usage.</p></div>
</div></div>
<div class="ulist"><ul>
<li>
<p>
rtdm_irq_request/free() and rtdm_irq_enable/disable() call pairs
  must be called from a Linux task context, which is a restriction
  that did not exist previously with Xenomai 2.x.
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>Recent evolutions of the Linux kernel with respect to IRQ management
involve complex processing for basic operations
(e.g. enabling/disabling the interrupt line) with some interrupt types
like MSI. Such processing cannot be made dual-kernel safe at a
reasonable cost, without encurring measurable latency or significant
code rewrites.</p></div>
<div class="paragraph"><p>Since allocating, releasing, enabling or disabling real-time
interrupts is most commonly done from driver initialization/cleanup
context already, the Cobalt core has simply inherited those
requirements from the Linux kernel.</p></div>
</div></div>
<div class="ulist"><ul>
<li>
<p>
The leading <em>user_info</em> argument to rtdm_munmap() has been
  removed.
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>With the introduction of RTDM file descriptors (see below) replacing
all <em>user_info</em> context pointers, this argument has become irrelevant,
since this operation is not related to any file descriptor, but rather
to the current address space.</p></div>
</div></div>
<div class="paragraph"><p>The new prototype for this routine is therefore</p></div>
<div class="listingblock">
<div class="content">
<pre><code>int rtdm_munmap(void *ptr, size_t len);</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_file_descriptors">5.3. File descriptors</h3>
<div class="paragraph"><p>Xenomai 3 introduces a file descriptor abstraction for RTDM
drivers. For this reason, all RTDM driver handlers and services which
used to receive a <code>user_info</code> opaque argument describing the calling
context, now receive a <code>rtdm_fd</code> pointer standing for the target file
descriptor for the operation.</p></div>
<div class="paragraph"><p>As a consequence of this:</p></div>
<div class="ulist"><ul>
<li>
<p>
The rtdm_context_get/put() call pair has been replaced by
  rtdm_fd_get/put().
</p>
</li>
<li>
<p>
Likewise, the rtdm_context_lock/unlock() call pair has been replaced
  by rtdm_fd_lock/unlock().
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="../asciidoc-icons/caution.png" alt="Caution" />
</td>
<td class="content">Because RTDM file descriptors may be released and destroyed
asynchronously, rtdm_fd_get() and rtdm_fd_lock() may return -EIDRM if
a file descriptor fetched from some driver-private registry becomes
stale prior to calling these services. Typically, this may happen if
the descriptor is released from the &#8594;close() handler implemented by
the driver. Therefore, make sure to always carefully check the return
value of these services.</td>
</tr></table>
</div>
<div class="ulist"><ul>
<li>
<p>
rtdm_fd_to_private() is available to fetch the context-private
  memory allocated by the driver for a particular RTDM file
  descriptor. Conversely, rtdm_private_to_fd() returns the file
  descriptor owning a particular context-private memory area.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_adaptive_syscalls">5.4. Adaptive syscalls</h3>
<div class="paragraph"><p><code>ioctl()</code>, <code>read()</code>, <code>write()</code>, <code>recvmsg()</code> and <code>sendmsg()</code> have
become context-adaptive RTDM calls, which means that Xenomai threads
running over the Cobalt core will be automatically switched to primary
mode prior to running the driver handler for the corresponding
request.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>Real-time handlers from RTDM drivers serve time-critical requests by
definition, which makes them preferred targets of adaptive calls over
non real-time handlers.</p></div>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="../asciidoc-icons/note.png" alt="Note" />
</td>
<td class="content">This behavior departs from Xenomai 2.x, which would run the call from
the originating context instead (e.g. <code>ioctl_nrt()</code> would be fired for
a caller running in secondary mode, and conversely <code>ioctl_rt()</code> would
be called for a request issued from primary mode).</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="../asciidoc-icons/tip.png" alt="Tip" />
</td>
<td class="content">RTDM drivers implementing differentiated <code>ioctl()</code> support for both
domains should serve all real-time only requests from <code>ioctl_rt()</code>,
returning <code>-ENOSYS</code> for any unrecognized request, which will cause the
adaptive switch to take place automatically to the <code>ioctl_nrt()</code>
handler. The <code>ioctl_nrt()</code> should then implement all requests which
may be valid from the regular Linux domain exclusively.</td>
</tr></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_analogy_interface_changes">6. Analogy interface changes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_files_renamed_2">6.1. Files renamed</h3>
<div class="ulist"><ul>
<li>
<p>
DAQ drivers in kernel space now pull all Analogy core header files
  from &lt;rtdm/analogy/*.h&gt;. In addition:
</p>
</li>
</ul></div>
<div class="paragraph"><p>analogy/analogy_driver.h &#8594; rtdm/analogy/driver.h</p></div>
<div class="paragraph"><p>analogy/driver.h &#8594; rtdm/analogy/driver.h</p></div>
<div class="paragraph"><p>analogy/analogy.h &#8594; rtdm/analogy.h</p></div>
<div class="ulist"><ul>
<li>
<p>
DAQ drivers in kernel space should include &lt;rtdm/analogy/device.h&gt;
  instead of &lt;rtdm/analogy/driver.h&gt;.
</p>
</li>
<li>
<p>
Applications need to include only a single file for pulling all
  routine declarations and constant definitions required for invoking
  the Analogy services from user-space, namely &lt;rtdm/analogy.h&gt;, i.e.
</p>
</li>
</ul></div>
<div class="paragraph"><p>analogy/types.h
analogy/command.h
analogy/device.h
analogy/subdevice.h
analogy/instruction.h
analogy/ioctl.h &#8594; all files merged into rtdm/analogy.h</p></div>
<div class="paragraph"><p>As a consequence of these changes, the former include/analogy/ file
tree has been entirely removed.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_posix_interface_changes">7. POSIX interface changes</h2>
<div class="sectionbody">
<div class="paragraph"><p>As mentioned earlier, the former <strong>POSIX skin</strong> is known as the <strong>Cobalt
API</strong> in Xenomai 3.x, available as <code>libcobalt.{so,a}</code>. The Cobalt API
also includes the code of the former <code>libxenomai</code>, which is no longer
a standalone library.</p></div>
<div class="paragraph"><p><code>libcobalt</code> exposes the set of POSIX and ISO/C standard features
specifically implemented by Xenomai to honor real-time requirements
using the Cobalt core.</p></div>
<div class="sect2">
<h3 id="_interrupt_management">7.1. Interrupt management</h3>
<div class="ulist"><ul>
<li>
<p>
The former <code>pthread_intr</code> API once provided by Xenomai 2.x is gone.
</p>
</li>
</ul></div>
<div class="sidebarblock" id="irqhandling">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>Handling real-time interrupt events from user-space can be done safely
only if some top-half code exists for acknowledging the issuing device
request from kernel space, particularly when the interrupt line is
shared. This should be done via a RTDM driver, exposing a <code>read(2)</code> or
<code>ioctl(2)</code> interface, for waiting for interrupt events from
applications running in user-space.</p></div>
</div></div>
<div class="paragraph"><p>Failing this, the low-level interrupt service code in user-space
would be sensitive to external thread management actions, such as
being stopped because of GDB/ptrace(2) interaction. Unfortunately,
preventing the device acknowledge code from running upon interrupt
request may cause unfixable breakage to happen (e.g. IRQ storm
typically).</p></div>
<div class="paragraph"><p>Since the application should provide proper top-half code in a
dedicated RTDM driver for synchronizing on IRQ receipt, the RTDM API
available in user-space is sufficient.</p></div>
<div class="paragraph"><p>Removing the <code>pthread_intr</code> API should be considered as a
strong hint for keeping the top-half interrupt handling code in
kernel space.</p></div>
<div class="admonitionblock" id="userirqtip">
<table><tr>
<td class="icon">
<img src="../asciidoc-icons/tip.png" alt="Tip" />
</td>
<td class="content">For receiving interrupt notifications within your application, you
should create a small RTDM driver handling the corresponding IRQ
(see <code>rtdm_irq_request()</code>). The IRQ handler should wake a thread up
in your application by posting some event (see <code>rtdm_sem_up()</code>,
<code>rtdm_sem_timeddown()</code>). The application should sleep on this event
by calling into the RTDM driver, either via a <code>read(2)</code> or
<code>ioctl(2)</code> request, handled by a dedicated operation handler (see
<code>rtdm_dev_register()</code>).</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="_scheduling">7.2. Scheduling</h3>
<div class="ulist"><ul>
<li>
<p>
The <code>SCHED_FIFO</code>, <code>SCHED_RR</code>, <code>SCHED_SPORADIC</code> and <code>SCHED_TP</code>
  classes now support up to 256 priority levels, instead of 99 as
  previously with Xenomai 2.x. However, <code>sched_get_priority_max()</code>
  still returns 99. Only the Cobalt extended call forms
  (e.g. <code>pthread_attr_setschedparam_ex()</code>, <code>pthread_create_ex()</code>)
  recognize these additional levels.
</p>
</li>
<li>
<p>
<code>sched_get_priority_min_ex()</code> and <code>sched_get_priority_max_ex()</code>
  should be used for querying the static priority range of Cobalt
  policies.
</p>
</li>
<li>
<p>
<code>pthread_setschedparam()</code> may cause a secondary mode switch for the
  caller, but will not cause any mode switch for the target thread
  unlike with Xenomai 2.x.
</p>
<div class="paragraph"><p>This is a requirement for maintaining both the <strong>glibc</strong> and the
Xenomai scheduler in sync, with respect to thread priorities, since
the former maintains a process-local priority cache for the threads
it knows about. Therefore, an explicit call to the the regular
<code>pthread_setschedparam()</code> shall be issued upon each priority change
Xenomai-wise, for maintaining consistency.</p></div>
<div class="paragraph"><p>In the Xenomai 2.x implementation, the thread being set a new
priority would receive a SIGSHADOW signal, eventually handled as a
request to call <strong>glibc</strong>'s <code>pthread_setschedparam()</code> immediately.</p></div>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>The target Xenomai thread may hold a mutex or any resource which may
only be held in primary mode, in which case switching to secondary
mode for applying the priority change at any random location over a
signal handler may create a pathological issue. In addition, <strong>glibc</strong>'s
<code>pthread_setschedparam()</code> is not async-safe, which makes the former
method fragile.</p></div>
</div></div>
<div class="paragraph"><p>Conversely, a thread which calls <code>pthread_setschedparam()</code> does know
unambiguously whether the current calling context is safe for the
incurred migration.</p></div>
<div class="ulist"><ul>
<li>
<p>
A new SCHED_WEAK class is available to POSIX threads, which may be
  optionally turned on using the <code>CONFIG_XENO_OPT_SCHED_WEAK</code> kernel
  configuration switch.
</p>
<div class="paragraph"><p>By this feature, Xenomai now accepts Linux real-time scheduling
policies (SCHED_FIFO, SCHED_RR) to be weakly scheduled by the Cobalt
core, within a low priority scheduling class (i.e. below the Xenomai
real-time classes, but still above the idle class).</p></div>
<div class="paragraph"><p>Xenomai 2.x already had a limited form of such policy, based on
scheduling SCHED_OTHER threads at the special SCHED_FIFO,0 priority
level in the Xenomai core. SCHED_WEAK is a generalization of such
policy, which provides for 99 priority levels, to cope with the full
extent of the regular Linux SCHED_FIFO/RR priority range.</p></div>
<div class="paragraph"><p>For instance, a (non real-time) Xenomai thread within the SCHED_WEAK
class at priority level 20 in the Cobalt core, may be scheduled with
policy SCHED_FIFO/RR at priority 20, by the Linux kernel. The code
fragment below would set the scheduling parameters accordingly,
assuming the Cobalt version of <code>pthread_setschedparam()</code> is invoked:</p></div>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>        struct sched_param param = {
               .sched_priority = -20,
        };

        pthread_setschedparam(tid, SCHED_FIFO, &amp;param);</code></pre>
</div></div>
<div class="paragraph"><p>Switching a thread to the SCHED_WEAK class can be done by negating
the priority level in the scheduling parameters sent to the Cobalt
core. For instance, SCHED_FIFO, prio=-7 would be scheduled as
SCHED_WEAK, prio=7 by the Cobalt core.</p></div>
<div class="paragraph"><p>SCHED_OTHER for a Xenomai-enabled thread is scheduled as
SCHED_WEAK,0 by the Cobalt core. When the SCHED_WEAK support is
disabled in the kernel configuration, only SCHED_OTHER is available
for weak scheduling of threads by the Cobalt core.</p></div>
<div class="ulist"><ul>
<li>
<p>
A new SCHED_QUOTA class is available to POSIX threads, which may be
  optionally turned on using the <code>CONFIG_XENO_OPT_SCHED_QUOTA</code> kernel
  configuration switch.
</p>
<div class="paragraph"><p>This policy enforces a limitation on the CPU consumption of
threads over a globally defined period, known as the quota
interval. This is done by pooling threads with common requirements
in groups, and giving each group a share of the global period (see
CONFIG_XENO_OPT_SCHED_QUOTA_PERIOD).</p></div>
<div class="paragraph"><p>When threads have entirely consumed the quota allotted to the group
they belong to, the latter is suspended as a whole, until the next
quota interval starts. At this point, a new runtime budget is given
to each group, in accordance with its share.</p></div>
</li>
<li>
<p>
When called from primary mode, sched_yield() now delays the caller
  for a short while <strong>only in case</strong> no context switch happened as a
  result of the manual round-robin. The delay ends next time the
  regular Linux kernel switches tasks, or a kernel (virtual) tick has
  elapsed (TICK_NSEC), whichever comes first.
</p>
<div class="paragraph"><p>Typically, a Xenomai thread undergoing the SCHED_FIFO or SCHED_RR
policy with no contender at the same priority level would still be
delayed for a while.</p></div>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>In most case, it is unwanted that sched_yield() does not cause any
context switch, since this service is commonly used for implementing a
poor man&#8217;s cooperative scheduling. A typical use case involves a
Xenomai thread running in primary mode which needs to yield the CPU to
another thread running in secondary mode. By waiting for a context
switch to happen in the regular kernel, we guarantee that the manual
round-robin takes place between both threads, despite the execution
mode mismatch. By limiting the incurred delay, we prevent a regular
high priority SCHED_FIFO thread stuck in a tight loop, from locking
out the delayed Xenomai thread indefinitely.</p></div>
</div></div>
</div>
<div class="sect2">
<h3 id="_thread_management">7.3. Thread management</h3>
<div class="ulist"><ul>
<li>
<p>
The default POSIX thread stack size was raised to
  <code>PTHREAD_STACK_MIN * 4</code>. The minimum stack size enforced by the
  <code>libcobalt</code> library is <code>PTHREAD_STACK_MIN + getpagesize()</code>.
</p>
</li>
<li>
<p>
pthread_set_name_np() has been renamed to pthread_setname_np() with
  the same arguments, to conform with the GNU extension equivalent.
</p>
</li>
<li>
<p>
pthread_set_mode_np() has been renamed to pthread_setmode_np() for
  naming consistency with pthread_setname_np(). In addition, the call
  introduces the PTHREAD_DISABLE_LOCKBREAK mode flag, which disallows
  breaking the scheduler lock.
</p>
<div class="paragraph"><p>When unset (default case), a thread which holds the scheduler lock
drops it temporarily while sleeping.  When set, any attempt to block
while holding the scheduler lock will cause a break condition to be
immediately raised, with the caller receiving EINTR.</p></div>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="../asciidoc-icons/warning.png" alt="Warning" />
</td>
<td class="content">A Xenomai thread running with PTHREAD_DISABLE_LOCKBREAK and
PTHREAD_LOCK_SCHED both set may enter a runaway loop when attempting
to sleep on a resource or synchronization object (e.g. mutex or
condition variable).</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="_semaphores">7.4. Semaphores</h3>
<div class="ulist"><ul>
<li>
<p>
With Cobalt, sem_wait(), sem_trywait(), sem_timedwait(), and
  sem_post() have gained fast acquisition/release operations not
  requiring any system call, unless a contention exists on the
  resource. As a consequence, those services may not systematically
  switch callers executing in relaxed mode to real-time mode, unlike
  with Xenomai 2.x.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_process_management">7.5. Process management</h3>
<div class="ulist"><ul>
<li>
<p>
In a <code>fork()</code> &#8594; <code>exec()</code> sequence, all Cobalt API objects created
  by the child process before it calls <code>exec()</code> are automatically
  flushed by the Xenomai core.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="real-time-signals">7.6. Real-time signals</h3>
<div class="ulist"><ul>
<li>
<p>
Support for Xenomai real-time signals is available.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Cobalt replacements for <code>sigwait()</code>, <code>sigwaitinfo()</code>,
<code>sigtimedwait()</code>, <code>sigqueue()</code> and <code>kill()</code> are
available. <code>pthread_kill()</code> was changed to send thread-directed
Xenomai signals (instead of regular Linux signals).</p></div>
<div class="paragraph"><p>Cobalt-based signals are stricly real-time. Both the sender and
receiver sides work exclusively from the primary domain. However, only
synchronous handling is available, with a thread waiting explicitly
for a set of signals, using one of the <code>sigwait</code> calls. There is no
support for asynchronous delivery of signals to handlers. For this
reason, there is no provision in the Cobalt API for masking signals,
as Cobalt signals are implicitly blocked for a thread until the latter
invokes one of the <code>sigwait</code> calls.</p></div>
<div class="paragraph"><p>Signals from SIGRTMIN..SIGRTMAX are queued.</p></div>
<div class="paragraph"><p>COBALT_DELAYMAX is defined as the maximum number of overruns which can
be reported by the Cobalt core in the siginfo.si_overrun field, for
any signal.</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>kill()</code> supports group signaling.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Cobalt&#8217;s implementation of kill() behaves identically to the regular
system call for non thread-directed signals (i.e. pid &#8656; 0). In this
case, the caller switches to secondary mode.</p></div>
<div class="paragraph"><p>Otherwise, Cobalt first attempts to deliver a thread-directed signal
to the thread whose kernel TID matches the given process id. If this
thread is not waiting for signals at the time of the call, kill() then
attempts to deliver the signal to a thread from the same process,
which currently waits for a signal.</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>pthread_kill()</code> is a conforming call.
</p>
</li>
</ul></div>
<div class="paragraph"><p>When Cobalt&#8217;s replacement for <code>pthread_kill()</code> is invoked, a
Xenomai-enabled caller is automatically switched to primary mode on
its way to sending the signal, under the control of the real-time
co-kernel. Otherwise, the caller keeps running under the control of
the regular Linux kernel.</p></div>
<div class="paragraph"><p>This behavior also applies to the new Cobalt-based replacement for the
<code>kill()</code> system call.</p></div>
</div>
<div class="sect2">
<h3 id="_timers">7.7. Timers</h3>
<div class="ulist"><ul>
<li>
<p>
POSIX timers are no longer dropped when the creator thread
  exits. However, they are dropped when the container process exits.
</p>
</li>
<li>
<p>
If the thread signaled by a POSIX timer exits, the timer is
  automatically stopped at the first subsequent timeout which fails
  sending the notification. The timer lingers until it is deleted by a
  call to <code>timer_delete()</code> or when the process exits, whichever comes
  first.
</p>
</li>
<li>
<p>
timer_settime() may be called from a regular thread (i.e. which is
  not Xenomai-enabled).
</p>
</li>
<li>
<p>
EPERM is not returned anymore by POSIX timer calls. EINVAL is
  substituted in the corresponding situation.
</p>
</li>
<li>
<p>
Cobalt replacements for <code>timerfd_create()</code>, <code>timerfd_settime()</code> and
<code>timerfd_gettime()</code> have been introduced. The implementation delivers
I/O notifications to RTDM file descriptors upon Cobalt-originated
real-time signals.
</p>
</li>
<li>
<p>
<code>pthread_make_periodic_np()</code> and <code>pthread_wait_np()</code> have been
removed from the API.
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>With the introduction of services to support real-time signals, those
two non-portable calls have become redundant. Instead, Cobalt-based
applications should set up a periodic timer using the
<code>timer_create()</code>+<code>timer_settime()</code> call pair, then wait for release
points via <code>sigwaitinfo()</code>. Overruns can be detected by looking at the
siginfo.si_overrun field.</p></div>
<div class="paragraph"><p>Alternatively, applications may obtain a file descriptor referring to
a Cobalt timer via the <code>timerfd()</code> call, and <code>read()</code> from it to wait
for timeouts.</p></div>
<div class="paragraph"><p>In addition, applications may include a timer in a synchronous
multiplexing operation involving other event sources, by passing a
file descriptor returned by the <code>timerfd()</code> service to a <code>select()</code>
call.</p></div>
</div></div>
</div>
<div class="sect2">
<h3 id="_message_queues">7.8. Message queues</h3>
<div class="ulist"><ul>
<li>
<p>
<code>mq_open()</code> default attributes align on the regular kernel values,
  i.e. 10 msg x 8192 bytes (instead of 128 x 128).
</p>
</li>
<li>
<p>
<code>mq_send()</code> now enforces a maximum priority value for messages
  (32768).
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_posix_i_o_services">7.9. POSIX I/O services</h3>
<div class="ulist"><ul>
<li>
<p>
Cobalt&#8217;s select(2) service is not automatically restarted anymore
  upon Linux signal receipt, conforming to the POSIX standard (see man
  signal(7)). In such an event, -1 is returned and errno is set to
  EINTR.
</p>
</li>
<li>
<p>
The former <code>include/rtdk.h</code> header is gone in Xenomai
3.x. Applications should include <code>include/stdio.h</code> instead.
Similarly, the real-time suitable STDIO routines are now part of
<code>libcobalt</code>.
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_alchemy_interface_formerly_em_native_api_em">8. Alchemy interface (formerly <em>native API</em>)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general">8.1. General</h3>
<div class="ulist"><ul>
<li>
<p>
The API calls supporting a wait operation may return the -EIDRM
error code only when the target object was deleted while
pending. Otherwise, passing a deleted object identifier to an API call
will result in -EINVAL being returned.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_interrupt_management_2">8.2. Interrupt management</h3>
<div class="ulist"><ul>
<li>
<p>
The <code>RT_INTR</code> API is gone. Please see the <a href="#irqhandling">rationale</a>
  for not handling low-level interrupt service code from user-space.
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="../asciidoc-icons/tip.png" alt="Tip" />
</td>
<td class="content">It is still possible to have the application wait for interrupt
receipts, as explained <a href="#userirqtip">here</a>.</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="_i_o_regions">8.3. I/O regions</h3>
<div class="ulist"><ul>
<li>
<p>
The RT_IOREGION API is gone. I/O memory resources should
  be controlled from a RTDM driver instead.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_timing_services">8.4. Timing services</h3>
<div class="ulist"><ul>
<li>
<p>
<code>rt_timer_set_mode()</code> is obsolete. The clock resolution has become a
per-process setting, which should be set using the
<code>--alchemy-clock-resolution</code> switch on the command line.
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="../asciidoc-icons/tip.png" alt="Tip" />
</td>
<td class="content">Tick-based timing can be obtained by setting the resolution of the
Alchemy clock for the application, here to one millisecond (the
argument expresses a count nanoseconds per tick).  As a result of
this, all timeout and date values passed to Alchemy API calls will be
interpreted as counts of milliseconds.</td>
</tr></table>
</div>
<div class="listingblock">
<div class="content">
<pre><code># xenomai-application --alchemy-clock-resolution=1000000</code></pre>
</div></div>
<div class="paragraph"><p>By default, the Alchemy API sets the clock resolution for the new
process to one nanosecond (i.e. tickless, highest resolution).</p></div>
<div class="ulist"><ul>
<li>
<p>
TM_INFINITE also means infinite wait with all <code>rt_*_until()</code> call
  forms.
</p>
</li>
<li>
<p>
<code>rt_task_set_periodic()</code> does not suspend the target task anymore.
If a start date is specified, then <code>rt_task_wait_period()</code> will apply
the initial delay.
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>A periodic Alchemy task has to call <code>rt_task_wait_period()</code> from
within its work loop for sleeping until the next release point is
reached. Since waiting for the initial and subsequent release points
will most often happen at the same code location in the application,
the semantics of rt_task_set_periodic() can be simplified so that only
rt_task_wait_period() may block the caller.</p></div>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="../asciidoc-icons/tip.png" alt="Tip" />
</td>
<td class="content">In the unusual case where you do need to have the current task wait
for the initial release point outside of its periodic work loop, you
can issue a call to <code>rt_task_wait_period()</code> separately, exclusively
for this purpose, i.e.</td>
</tr></table>
</div>
<div class="listingblock">
<div class="content">
<pre><code>              /* wait for the initial release point. */
              ret = rt_task_wait_period(&amp;overruns);
              /* ...more preparation work... */
              for (;;) {
                       /* wait for the next release point. */
                       ret = rt_task_wait_period(&amp;overruns);
                       /* ...do periodic work... */
              }</code></pre>
</div></div>
<div class="paragraph"><p>However, this work around won&#8217;t work if the caller is not the target
task of rt_task_set_periodic(), which is fortunately unusual for most
applications.</p></div>
<div class="paragraph"><p><code>rt_task_set_periodic()</code> still switches to primary as previously over
Cobalt. However, it does not return -EWOULDBLOCK anymore.</p></div>
<div class="ulist"><ul>
<li>
<p>
TM_ONESHOT was dropped, because the operation mode of the hardware
  timer has no meaning for the application. The core Xenomai system
  always operates the available timer chip in oneshot mode anyway.
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="../asciidoc-icons/tip.png" alt="Tip" />
</td>
<td class="content">A tickless clock has a period of one nanosecond.</td>
</tr></table>
</div>
<div class="ulist"><ul>
<li>
<p>
Unlike with Xenomai 2.x, the target task to <code>rt_task_set_periodic()</code>
  must be local to the current process.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_mutexes">8.5. Mutexes</h3>
<div class="ulist"><ul>
<li>
<p>
For consistency with the standard glibc implementation, deleting a
  RT_MUTEX object in locked state is no longer a valid operation.
</p>
</li>
<li>
<p>
<code>rt_mutex_inquire()</code> does not return the count of waiters anymore.
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>Obtaining the current count of waiters only makes sense for debugging
purpose. Keeping it in the API would introduce a significant overhead
to maintain internal consistency.</p></div>
</div></div>
<div class="paragraph"><p>The <code>owner</code> field of a RT_MUTEX_INFO structure now reports the owner&#8217;s
task handle, instead of its name. When the mutex is unlocked, a NULL
handle is returned, which has the same meaning as a zero value in the
former <code>locked</code> field.</p></div>
</div>
<div class="sect2">
<h3 id="_condition_variables">8.6. Condition variables</h3>
<div class="ulist"><ul>
<li>
<p>
For consistency with the standard glibc implementation, deleting a
  RT_COND object currently pended by other tasks is no longer a valid
  operation.
</p>
</li>
<li>
<p>
Like <code>rt_mutex_inquire()</code>, <code>rt_cond_inquire()</code> does not return the
count of waiting tasks anymore.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_task_management">8.7. Task management</h3>
<div class="ulist"><ul>
<li>
<p>
<code>rt_task_notify()</code> and <code>rt_task_catch()</code> have been removed. They are
  meaningless in a userland-only context.
</p>
</li>
<li>
<p>
As a consequence of the previous change, the T_NOSIG flag to
  <code>rt_task_set_mode()</code> was dropped in the same move.
</p>
</li>
<li>
<p>
T_SUSP cannot be passed to rt_task_create() or rt_task_spawn()
  anymore.
</p>
</li>
<li>
<p>
T_FPU is obsolete. FPU management is automatically enabled for
  Alchemy tasks if the hardware supports it, disabled otherwise.
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>This behavior can be achieved by not calling <code>rt_task_start()</code>
immediately after <code>rt_task_create()</code>, or by calling
<code>rt_task_suspend()</code> before <code>rt_task_start()</code>.</p></div>
</div></div>
<div class="ulist"><ul>
<li>
<p>
<code>rt_task_shadow()</code> now accepts T_LOCK, T_WARNSW.
</p>
</li>
<li>
<p>
<code>rt_task_create()</code> now accepts T_LOCK, T_WARNSW and T_JOINABLE.
</p>
</li>
<li>
<p>
The RT_TASK_INFO structure returned by <code>rt_task_inquire()</code> has
  changed:
</p>
<div class="ulist"><ul>
<li>
<p>
fields <code>relpoint</code> and <code>cprio</code> have been removed, since the
     corresponding information is too short-lived to be valuable to
     the caller. The task&#8217;s base priority is still available from
     the <code>prio</code> field.
</p>
</li>
<li>
<p>
new field <code>pid</code> represents the Linux kernel task identifier for
     the Alchemy task, as obtained from syscall(__NR_gettid).
</p>
</li>
<li>
<p>
other fields which represent runtime statistics are now avail
     from a core-specific <code>stat</code> field sub-structure.
</p>
</li>
</ul></div>
</li>
<li>
<p>
New <code>rt_task_send_until()</code>, <code>rt_task_receive_until()</code> calls are
  available, as variants of <code>rt_task_send()</code> and <code>rt_task_receive()</code>
  respectively, with absolute timeout specification.
</p>
</li>
<li>
<p>
rt_task_receive() does not inherit the priority of the sender,
although the requests will be queued by sender priority.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Instead, the application decides about the server priority instead of
the real-time core applying implicit dynamic boosts.</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>rt_task_slice()</code> now returns -EINVAL if the caller currently holds
  the scheduler lock, or attempts to change the round-robin settings
  of a thread which does not belong to the current process.
</p>
</li>
<li>
<p>
T_CPU disappears from the <code>rt_task_create()</code> mode flags. The new
  <code>rt_task_set_affinity()</code> service is available for setting the CPU
  affinity of a task.
</p>
</li>
<li>
<p>
<code>rt_task_sleep_until()</code> does not return -ETIMEDOUT anymore. Waiting
  for a date in the past blocks the caller indefinitely.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_message_queues_2">8.8. Message queues</h3>
<div class="ulist"><ul>
<li>
<p>
As Alchemy-based applications run in user-space, the following
  <code>rt_queue_create()</code> mode bits from the former <em>native</em> API are
  obsolete:
</p>
<div class="ulist"><ul>
<li>
<p>
Q_SHARED
</p>
</li>
<li>
<p>
Q_DMA
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_heaps">8.9. Heaps</h3>
<div class="ulist"><ul>
<li>
<p>
As Alchemy-based applications run in user-space, the following
  <code>rt_heap_create()</code> mode bits from the former <em>native</em> API are
  obsolete:
</p>
<div class="ulist"><ul>
<li>
<p>
H_MAPPABLE
</p>
</li>
<li>
<p>
H_SHARED
</p>
</li>
<li>
<p>
H_NONCACHED
</p>
</li>
<li>
<p>
H_DMA
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="../asciidoc-icons/tip.png" alt="Tip" />
</td>
<td class="content">If you need to allocate a chunk of DMA-suitable memory, then you
should create a RTDM driver for this purpose.</td>
</tr></table>
</div>
<div class="ulist"><ul>
<li>
<p>
<code>rt_heap_alloc_until()</code> is a new call for waiting for a memory
  chunk, specifying an absolute timeout date.
</p>
</li>
<li>
<p>
with the removal of H_DMA, returning a physical address (phys_addr)
  in <code>rt_heap_inquire()</code> does not apply anymore.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_alarms">8.10. Alarms</h3>
<div class="ulist"><ul>
<li>
<p>
<code>rt_alarm_wait()</code> has been removed.
</p>
</li>
</ul></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Rationale</div>
<div class="paragraph"><p>An alarm handler can be passed to <code>rt_alarm_create()</code> instead.</p></div>
</div></div>
<div class="ulist"><ul>
<li>
<p>
The RT_ALARM_INFO structure returned by <code>rt_alarm_inquire()</code> has
  changed:
</p>
<div class="ulist"><ul>
<li>
<p>
field <code>expiration</code> has been removed, since the corresponding
     information is too short-lived to be valuable to the caller.
</p>
</li>
<li>
<p>
field <code>active</code> has been added, to reflect the current state of
     the alarm object. If non-zero, the alarm is enabled
     (i.e. started).
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_message_pipes">8.11. Message pipes</h3>
<div class="ulist"><ul>
<li>
<p>
Writing to a message pipe is allowed from all contexts, including
  from alarm handlers.
</p>
</li>
<li>
<p>
<code>rt_pipe_read_until()</code> is a new call for waiting for input from a
  pipe, specifying an absolute timeout date.
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_psos_interface_changes">9. pSOS interface changes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_memory_regions">9.1. Memory regions</h3>
<div class="ulist"><ul>
<li>
<p>
<code>rn_create()</code> may return ERR_NOSEG if the region control block
  cannot be allocated internally.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_scheduling_2">9.2. Scheduling</h3>
<div class="ulist"><ul>
<li>
<p>
The emulator converts priority levels between the core POSIX and
  pSOS scales using normalization (pSOS &#8594; POSIX) and denormalization
  (POSIX &#8594; pSOS) handlers.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Applications may override the default priority
normalization/denormalization handlers, by implementing the following
routines.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>int psos_task_normalize_priority(unsigned long psos_prio);

unsigned long psos_task_denormalize_priority(int core_prio);</code></pre>
</div></div>
<div class="paragraph"><p>Over Cobalt, the POSIX scale is extended to 257 levels, which allows
to map pSOS over the POSIX scale 1:1, leaving
normalization/denormalization handlers as no-ops by default.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_vxworks_interface_changes">10. VxWorks interface changes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_task_management_2">10.1. Task management</h3>
<div class="ulist"><ul>
<li>
<p>
<code>WIND_*</code> status bits are synced to the user-visible TCB only as a
result of a call to <code>taskTcb()</code> or <code>taskGetInfo()</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>As a consequence of this change, any reference to a user-visible TCB
should be refreshed by calling <code>taskTcb()</code> anew, each time reading the
<code>status</code> field is required.</p></div>
</div>
<div class="sect2">
<h3 id="_scheduling_3">10.2. Scheduling</h3>
<div class="ulist"><ul>
<li>
<p>
The emulator converts priority levels between the core POSIX and
  VxWorks scales using normalization (VxWorks &#8594; POSIX) and
  denormalization (POSIX &#8594; VxWorks) handlers.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Applications may override the default priority
normalization/denormalization handlers, by implementing the following
routines.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>int wind_task_normalize_priority(int wind_prio);

int wind_task_denormalize_priority(int core_prio);</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_the_transition_kit">11. Using the Transition Kit</h2>
<div class="sectionbody">
<div class="paragraph"><p>Xenomai 2 applications in user-space may use a library and a set of
compatibility headers, aimed at easing the process of transitioning to
Xenomai 3.</p></div>
<div class="paragraph"><p>Enabling this compatibility layer is done via passing specific
compilation and linker flags when building the
application. <code>xeno-config</code> can retrieve those flags using the
<code>--cflags</code> and <code>--ldflags</code> switches as usual, with the addition of the
<code>--compat</code> flag. Alternatively, passing the <code>--[skin=]native</code> switch
as to <code>xeno-config</code> implicitly turns on the compatibility mode for the
Alchemy API.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="../asciidoc-icons/note.png" alt="Note" />
</td>
<td class="content">The transition kit does not currently cover <em>all</em> the changes
introduced in Xenomai 3 yet, but a significant subset of them
nevertheless.</td>
</tr></table>
</div>
<div class="listingblock">
<div class="title">A typical Makefile fragment implicitly turning on backward compatibility</div>
<div class="content">
<pre><code>PREFIX := /usr/xenomai
CONFIG_CMD := $(PREFIX)/bin/xeno-config
CFLAGS= $(shell $(CONFIG_CMD) --skin=native --cflags) -g
LDFLAGS= $(shell $(CONFIG_CMD) --skin=native --ldflags)
CC = $(shell $(CONFIG_CMD) --cc)</code></pre>
</div></div>
<div class="listingblock">
<div class="title">Another example for using with the POSIX API</div>
<div class="content">
<pre><code>PREFIX := /usr/xenomai
CONFIG_CMD := $(PREFIX)/bin/xeno-config
CFLAGS= $(shell $(CONFIG_CMD) --skin=posix --cflags --compat) -g
LDFLAGS= $(shell $(CONFIG_CMD) --skin=posix --ldflags --compat)
CC = $(shell $(CONFIG_CMD) --cc)</code></pre>
</div></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2014-08-08 11:36:19 CEST
</div>
</div>
</body>
</html>
