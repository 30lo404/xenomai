#!/bin/bash

myusage() {
    cat >&1 <<EOF
xeno-test [options]
  runs latency test in all 3 test-modes
  -w <number>	spawn N workloads (dd if=/dev/zero of=/dev/null) default=1
  -d <device>	used as alternate src in workload (dd if=$device ..)
		The device must be mounted, and (unfortunately) cannot
		be an NFS mount a real device (ex /dev/hda) will
		generate interrupts
  -W <script>   script is an alternate workload.  If you need to pass args
		to your program, use quotes.  The program must clean
		up its children when it gets a SIGTERM
  -p <cmd>	cmd is run before and after rt-tests
		(forex: 'ntpdate -b <host>' or 'ntpq -p')
  -L	     	writes logs to /tmp/test-`uname -r`-<timestamp>
  -N <name>	like -L, but writes to name-<timestamp> (in PWD)
		name can be full or relative pathname
  -v		verbose
  -M <email>	sends output to given addr
  -m		sends output to xenomai-data@gna.org
  -U <url>	uploads output to given URL
	
  # following options are passed thru to latency
  -s	print statistics of sampled data (default on)
  -h	print histogram of sampled data (default on, implies -s)
  -q	quiet, dont print 1 sec sampled data (default on, off if !-T)
  -T <sec test>	(default: 120 sec)
  -l <data/header lines> (default 21)
  -H <bucketcount> (default 100)
  -B <bucketsize ns> (default 1000)
EOF
    # NB: many defaults are coded in latency
    exit 1
}

#set -e	# ctrl-C's should end everything, not just subshells. 
	# commenting it out may help to debug stuff.

set -o notify	# see dd's finish immediately.(or not!)

loudly() {
    [ "$1" = "" ] && return
    # run task after announcing it
    echo;  date;
    echo running: $*
    eval $* &		# eval helps w complex cmds, like zegrep -E
    wait $!
}

# defaults for cpu workload 
device=/dev/zero	
typeset -a dd_jobs
dd_jobs=()

# used in generate-loads
mkload() { exec dd if=$device of=/dev/null $* ; }

generate_loads() {
    local jobsct=$1; shift;

    reaper() { echo something died $*; }
    trap reaper CHLD
    trap cleanup_load EXIT	# under all exit conditions
    
    for (( ; $jobsct ; jobsct-- )) ; do
	mkload &
	dd_jobs[${#dd_jobs[*]}]=$!
    done;

    echo dd workload started, pids ${dd_jobs[*]}
}

cleanup_load() {
    # kill the workload
    echo killing workload pids ${dd_jobs[*]}
    kill ${dd_jobs[*]};
    unset dd_jobs;
}

whatconf="XENO|IPIPE|PREEMPT|CONFIG_ACPI|CONFIG_PM|CPU_FREQ|CONFIG_DEBUG_SPINLOCK|CONFIG_FRAME_POINTER"


boxinfo() { # static info, show once

    loudly ./xeno-config --verbose
    loudly ./xeno-info

    loudly cat /proc/cpuinfo	# bogomips changes under CPU_FREQ

    # how much of the config do we want ?
    local cmd="zgrep -E '$whatconf'"
    [ "$verbose" = 1 ] && cmd=cat

    if [ -f /proc/config.gz ]; then	# get the config
	loudly $cmd /proc/config.gz
    elif [ -f /lib/modules/`uname -r`/build/.config ]; then
	loudly $cmd /lib/modules/`uname -r`/build/.config
    fi

    [ -d /proc/adeos ] && for f in /proc/adeos/*; do loudly cat $f; done
    [ -d /proc/ipipe ] && for f in /proc/ipipe/*; do loudly cat $f; done
}

boxstatus() {     # get dynamic status

    loudly cat /proc/interrupts
    loudly cat /proc/loadavg
    loudly cat /proc/meminfo

    if [ -d /proc/xenomai ]; then
	for f in /proc/xenomai/*;   do [ -f $f ] && loudly cat $f; done
	for f in /proc/xenomai/*/*; do [ -f $f ] && loudly cat $f; done
    fi
    [ -n "$prepost" ] && loudly $prepost
    loudly top -bn1c | head -n $(( 12 + $workload ))
}


run_w_load() {
    local opts="$*";
    [ "$opts"  = '' ] && opts='-q -s -T 120'

    boxinfo
    loudly generate_loads $workload
    boxstatus
    (
	cd ../testsuite/latency
	loudly ./run --  $opts -t0
	loudly ./run --  $opts -t1
	loudly ./run --  $opts -t2
    )
    (	cd ../testsuite/switch 
	loudly ./run --  '# switch'
    )
    (	cd ../testsuite/cyclic
	loudly ./run -- -p 10 -n -l 1000 '# cyclictest'
    )

    boxstatus
}


#####################
# MAIN

if [ -f /proc/config.gz ] ; then

    # check/warn on problem configs
    
    eval `zgrep CONFIG_CPU_FREQ /proc/config.gz`;
    if [ ! -z "$CONFIG_CPU_FREQ" ] ; then
	echo "warning: CONFIG_CPU_FREQ=$CONFIG_CPU_FREQ may be problematic"
    fi

fi

workload=1	# default = 1 job

# *pass get all legit options, except -N, -L
pass=		# pass thru to latency
loadpass=	# pass thru to subshell, not to actual tests

logging=	# no logging by default
logfile=	# defaults to test-`uname -r`-<datestampe>
logprefix=/tmp/	# someplace usually there
prepost=	# command to run pre, and post test (ex ntpq -p)

email='xenomai-data@gna.org'
sentby='xenotest.sender@xenomai.org'
url=
sendit=		# send it by m-mail, u-url
verbose=

sendit() {
    local file=$1
    
    if [ "$sendit" == 'm' ]; then
	echo "mailing $file to $email"
	if [ "$file" != '' ]; then
	    mail -s 'xeno-test results' $email -- -F $sentby < $file
	else
	    cat - | mail -s 'xeno-test results' $email -- -F $sentby
	fi
    elif [ "$sendit" == 'u' ]; then
	which curl && curl -T $file $url
	# -x $proxy >/tmp/.submit_result
	# which wget && curl -T $file $url \
    fi
}


while getopts 'd:shqT:l:H:B:uLN:w:W:p:mM:U:' FOO ; do

    case $FOO in
	s|h|q)
	    pass="$pass -$FOO" ;;
	T|l|H|B)
	    pass="$pass -$FOO $OPTARG" ;;
	d) 
	    device=$OPTARG    
	    echo creating workload using dd if=$device
	    if !(mount | grep -q ^$device) ; then
		echo d option must be a block device, ie one of:
		mount | cut -d\  -f1 | egrep -ve 'sysfs|proc|depts'
		exit;
	    fi
	    loadpass="$loadpass -d $device"
	    ;;
	L)
	    logging=1
	    logfile=test-`uname -r`  ;;
	N)
	    logging=1
	    logprefix=$OPTARG ;;
	w)
	    workload=$OPTARG
	    loadpass="$loadpass -w $OPTARG"  ;;
	W)
	    altwork=$OPTARG
	    loadpass="$loadpass -W '$OPTARG'"  ;;
	p)
	    prepost=$OPTARG 
	    loadpass="$loadpass -p '$OPTARG'"  ;;
	M)
	    email=$OPTARG 
	    sendit='m' ;;
	m)
	    sendit='m' ;;
	U)
	    url=$OPTARG 
	    sendit='u' ;;
	v)
	    verbose=1 ;;
	n)
	    # accept note (from the outer process)
	    notes=$OPTARG ;;


	?)
	    myusage ;;
    esac
done

# all args have been handled, and split into 2 passthrus
shift $(($OPTIND - 1));


if [ "$logging" != "" ]; then
    # restart inside a script invocation, passing appropriate args
    wfile=$logprefix$logfile-`date +%y%m%d.%H%M%S`
    script -c "./xeno-test $loadpass $pass $*" $wfile && sendit $wfile
else
    if [ "$altwork" != "" ]; then
	mkload() { exec $altwork; }
    fi
    echo starting $0 $pass $loadpass $*
    if [ "$sendit" != '' ]; then
	run_w_load $pass $* | sendit
    else
	run_w_load $pass $*
    fi
fi

exit;


#################################################

DONE:

1. added -W <program invocation>

The program should generate a load that is appropriately demanding
upon cpu, interrupts, devices, etc.

It should also work when invoked more than once, and scale the loads
reasonably linearly (since the -w will count by N).

Also, if it spawns subtasks, it should end them all when it gets SIGTERM.


2. added timestamp to the output filename to avoid overwriting
   previous results.

3. added -p 'command', which runs command before, between, and after
   the latency tests.


TODO:

1. get workload child reaper to work when child is killed from
separate window, or when it finishes.  Forex, 'dd if=/dev/hda ...'
will eventually finish, and should be restarted to keep the load up.
Figure out why killall didnt work properly.

2. Much more testing.  Heres a weak start..

#!/bin/bash
PATH=.:$PATH
xeno-test -L
xeno-test -N foo -T 18 -l 6 -s
xeno-test -L -N foo1-
xeno-test -N foo0 -w0 -l 5 -T 30 -h
xeno-test -L -N foo4- -w4
xeno-test -L -N foo4W- -w4 -W 'dd if=/dev/hda1 of=/dev/null'

3.
