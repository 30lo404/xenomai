diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index d85ee91..8761b32 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -194,7 +194,12 @@ static void gic_handle_cascade_irq(unsigned int irq, struct irq_desc *desc)
 	unsigned long status, flags;
 
 	/* primary controller ack'ing */
+#ifndef CONFIG_IPIPE
 	chip->irq_ack(&desc->irq_data);
+#else /* CONFIG_IPIPE */
+	chip->irq_mask_ack(&desc->irq_data);
+#endif /* CONFIG_IPIPE */
+
 
 	spin_lock_irqsave_cond(&irq_controller_lock, flags);
 	status = readl_relaxed(chip_data->cpu_base + GIC_CPU_INTACK);
diff --git a/arch/arm/mach-mx5/clock.c b/arch/arm/mach-mx5/clock.c
index d34a8c9..35d8b98 100644
--- a/arch/arm/mach-mx5/clock.c
+++ b/arch/arm/mach-mx5/clock.c
@@ -4889,7 +4889,7 @@ int __init mx51_clocks_init(unsigned long ckil, unsigned long osc, unsigned long
 
 	/* System timer */
 	mxc_timer_init(&gpt_clk[0], MX51_IO_ADDRESS(MX51_GPT1_BASE_ADDR),
-		MX51_MXC_INT_GPT);
+		       MX51_GPT1_BASE_ADDR, MX51_MXC_INT_GPT);
 
 	return 0;
 }
@@ -5140,10 +5140,10 @@ int __init mx53_clocks_init(unsigned long ckil, unsigned long osc, unsigned long
 	/* set the freq of asrc_serial_clk */
 	clk_set_rate(&asrc_clk[0], clk_round_rate(&asrc_clk[0],
 			1190000));
-
+	clk_set_parent(&uart_main_clk, &pll2_sw_clk);
 	/* System timer */
 	mxc_timer_init(&gpt_clk[0], MX53_IO_ADDRESS(MX53_GPT1_BASE_ADDR),
-		MX53_INT_GPT);
+		       MX53_GPT1_BASE_ADDR, MX53_INT_GPT);
 	return 0;
 }
 
diff --git a/arch/arm/mach-mx5/clock_mx50.c b/arch/arm/mach-mx5/clock_mx50.c
index 4d2c2b9..24926cc 100644
--- a/arch/arm/mach-mx5/clock_mx50.c
+++ b/arch/arm/mach-mx5/clock_mx50.c
@@ -3572,7 +3572,7 @@ int __init mx50_clocks_init(unsigned long ckil, unsigned long osc, unsigned long
 	cpu_op_tbl = get_cpu_op(&cpu_op_nr);
 
 	base = MX50_IO_ADDRESS(MX50_GPT1_BASE_ADDR);
-	mxc_timer_init(&gpt_clk[0], base, MX50_INT_GPT);
+	mxc_timer_init(&gpt_clk[0], base, MX50_GPT1_BASE_ADDR, MX50_INT_GPT);
 
 	return 0;
 }
diff --git a/arch/arm/mach-mx6/clock.c b/arch/arm/mach-mx6/clock.c
index 124f340..21e0d01 100644
--- a/arch/arm/mach-mx6/clock.c
+++ b/arch/arm/mach-mx6/clock.c
@@ -1,4 +1,3 @@
-
 /*
  * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
  */
@@ -65,7 +64,7 @@ static struct clk usdhc3_clk;
 static struct cpu_op *cpu_op_tbl;
 static int cpu_op_nr;
 
-#define SPIN_DELAY	1200000 /* in nanoseconds */
+#define SPIN_DELAY	12000000 /* in nanoseconds */
 
 #define AUDIO_VIDEO_MIN_CLK_FREQ	650000000
 #define AUDIO_VIDEO_MAX_CLK_FREQ	1300000000
@@ -78,7 +77,7 @@ static int cpu_op_nr;
 	getnstimeofday(&nstimeofday); \
 	while (!(exp)) { \
 		getnstimeofday(&curtime); \
-		if ((curtime.tv_nsec - nstimeofday.tv_nsec) > (timeout)) { \
+		if ((long)(curtime.tv_nsec - nstimeofday.tv_nsec) > (timeout)) { \
 			result = 0; \
 			break; \
 		} \
@@ -952,6 +951,17 @@ static struct clk cpu_clk = {
 	.get_rate = _clk_arm_get_rate,
 };
 
+static unsigned long twd_clk_get_rate(struct clk *clk)
+{
+	return clk_get_rate(clk->parent) / 2;
+}
+
+static struct clk twd_clk = {
+	__INIT_CLK_DEBUG(twd_clk)
+	.parent = &cpu_clk,
+	.get_rate = twd_clk_get_rate,
+};
+
 static int _clk_periph_set_parent(struct clk *clk, struct clk *parent)
 {
 	u32 reg;
@@ -4644,6 +4654,7 @@ static struct clk dummy_clk = {
 
 static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "osc", osc_clk),
+	_REGISTER_CLOCK(NULL, "smp_twd", twd_clk),
 	_REGISTER_CLOCK(NULL, "ckih", ckih_clk),
 	_REGISTER_CLOCK(NULL, "ckih2", ckih2_clk),
 	_REGISTER_CLOCK(NULL, "ckil", ckil_clk),
@@ -4892,7 +4903,7 @@ int __init mx6_clocks_init(unsigned long ckil, unsigned long osc,
 	clk_set_parent(&spdif0_clk[0], &pll3_pfd_454M);
 
 	base = ioremap(GPT_BASE_ADDR, SZ_4K);
-	mxc_timer_init(&gpt_clk[0], base, MXC_INT_GPT);
+	mxc_timer_init(&gpt_clk[0], base, GPT_BASE_ADDR, MXC_INT_GPT);
 
 	/* Set the core to max frequency requested. */
 	mx6_set_cpu_voltage(cpu_op_tbl[0].cpu_voltage);
diff --git a/arch/arm/mach-mx6/localtimer.c b/arch/arm/mach-mx6/localtimer.c
index d72fa93..ce5c9a4 100644
--- a/arch/arm/mach-mx6/localtimer.c
+++ b/arch/arm/mach-mx6/localtimer.c
@@ -33,5 +33,8 @@ void __cpuinit local_timer_setup(struct clock_event_device *evt)
 #ifdef CONFIG_LOCAL_TIMERS
 	evt->irq = IRQ_LOCALTIMER;
 	twd_timer_setup(evt);
+#ifdef CONFIG_IPIPE
+	gt_setup(LOCAL_TWD_ADDR - 0x400, 32);
+#endif /* CONFIG_IPIPE */
 #endif
 }
diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
index 5899560..b39ac9f 100644
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -47,6 +47,7 @@ config ARCH_MX5
 config ARCH_MX6
 	bool "MX6-based"
 	select CPU_V7
+	select LOCAL_TIMERS if IPIPE && SMP
 	help
 	  This enable support for systems based on the Freescale i.MX 6 Series family
 
@@ -141,7 +142,7 @@ config ARCH_MXC_AUDMUX_V2
 
 config IRAM_ALLOC
 	bool
-        default y
+	default y
 	select GENERIC_ALLOCATOR
 
 config CLK_DEBUG
@@ -152,11 +153,11 @@ config CLK_DEBUG
 	  export clk debug information to user space
 
 config DMA_ZONE_SIZE
-        int "DMA memory zone size"
-        range 0 184
-        default 24
-        help
-          This is the size in MB for the DMA zone. The DMA zone is used for
-          dedicated memory for large contiguous video buffers
+	int "DMA memory zone size"
+	range 0 184
+	default 24
+	help
+	  This is the size in MB for the DMA zone. The DMA zone is used for
+	  dedicated memory for large contiguous video buffers
 
 endif
diff --git a/arch/arm/plat-mxc/cpu.c b/arch/arm/plat-mxc/cpu.c
index 5cafd19..e3657ad 100644
--- a/arch/arm/plat-mxc/cpu.c
+++ b/arch/arm/plat-mxc/cpu.c
@@ -1,15 +1,78 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
 #include <linux/module.h>
 #include <linux/io.h>
 #include <mach/hardware.h>
+#include <mach/clock.h>
 
 unsigned int __mxc_cpu_type;
 EXPORT_SYMBOL(__mxc_cpu_type);
+extern int mxc_early_serial_console_init(unsigned long base, struct clk *clk);
+int (*set_cpu_voltage)(u32 volt);
+void (*set_num_cpu_op)(int num);
 
 void mxc_set_cpu_type(unsigned int type)
 {
 	__mxc_cpu_type = type;
 }
 
+int mxc_jtag_enabled;		/* OFF: 0 (default), ON: 1 */
+int uart_at_24; 			/* OFF: 0 (default); ON: 1 */
+/*
+ * Here are the JTAG options from the command line. By default JTAG
+ * is OFF which means JTAG is not connected and WFI is enabled
+ *
+ *       "on" --  JTAG is connected, so WFI is disabled
+ *       "off" -- JTAG is disconnected, so WFI is enabled
+ */
+
+static int __init jtag_wfi_setup(char *p)
+{
+	if (memcmp(p, "on", 2) == 0) {
+		mxc_jtag_enabled = 1;
+		p += 2;
+	} else if (memcmp(p, "off", 3) == 0) {
+		mxc_jtag_enabled = 0;
+		p += 3;
+	}
+	return 0;
+}
+early_param("jtag", jtag_wfi_setup);
+
+/**
+ * early_console_setup - setup debugging console
+ *
+ * Consoles started here require little enough setup that we can start using
+ * them very early in the boot process, either right after the machine
+ * vector initialization, or even before if the drivers can detect their hw.
+ *
+ * Returns non-zero if a console couldn't be setup.
+ * This function is developed based on
+ * early_console_setup function as defined in arch/ia64/kernel/setup.c
+ */
+void __init early_console_setup(unsigned long base, struct clk *clk)
+{
+#ifdef CONFIG_SERIAL_IMX_CONSOLE
+	mxc_early_serial_console_init(base, clk);
+#endif
+}
+
 #ifdef CONFIG_IPIPE
 void ipipe_mach_allow_hwtimer_uaccess(unsigned long aips1, unsigned long aips2)
 {
diff --git a/arch/arm/plat-mxc/gpio.c b/arch/arm/plat-mxc/gpio.c
index 3ef2e4f..735ba5a 100644
--- a/arch/arm/plat-mxc/gpio.c
+++ b/arch/arm/plat-mxc/gpio.c
@@ -3,7 +3,7 @@
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  *
  * Based on code from Freescale,
- * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -203,7 +203,11 @@ static void mx3_gpio_irq_handler(u32 irq, struct irq_desc *desc)
 	u32 irq_stat;
 	struct mxc_gpio_port *port = get_irq_data(irq);
 
-#ifdef CONFIG_IPIPE
+#ifndef CONFIG_IPIPE
+#ifndef CONFIG_MXC_TZIC
+	desc->irq_data.chip->irq_ack(&desc->irq_data);
+#endif /* CONFIG_MXC_TZIC */
+#else /* CONFIG_IPIPE */
 	desc->irq_data.chip->irq_mask_ack(&desc->irq_data);
 #endif /* CONFIG_IPIPE */
 
@@ -275,6 +279,7 @@ static int gpio_set_wake_irq(struct irq_data *d, u32 enable)
 }
 
 static struct irq_chip gpio_irq_chip = {
+	.name = "GPIO",
 	.irq_ack = gpio_ack_irq,
 	.irq_mask = gpio_mask_irq,
 	.irq_unmask = gpio_unmask_irq,
@@ -336,9 +341,10 @@ static int mxc_gpio_direction_output(struct gpio_chip *chip,
 	return 0;
 }
 
-int __init mxc_gpio_init(struct mxc_gpio_port *port, int cnt)
+int mxc_gpio_init(struct mxc_gpio_port *port, int cnt)
 {
 	int i, j;
+	static bool initialed;
 
 	/* save for local usage */
 	mxc_gpio_ports = port;
@@ -367,10 +373,12 @@ int __init mxc_gpio_init(struct mxc_gpio_port *port, int cnt)
 
 		spin_lock_init(&port[i].lock);
 
-		/* its a serious configuration bug when it fails */
-		BUG_ON( gpiochip_add(&port[i].chip) < 0 );
+		if (!initialed)
+			/* its a serious configuration bug when it fails */
+			BUG_ON(gpiochip_add(&port[i].chip) < 0);
 
-		if (cpu_is_mx1() || cpu_is_mx3() || cpu_is_mx25() || cpu_is_mx51()) {
+		if (cpu_is_mx1() || cpu_is_mx3() || cpu_is_mx25() ||
+			cpu_is_mx51() || cpu_is_mx53() || cpu_is_mx6q()) {
 			/* setup one handler for each entry */
 			set_irq_chained_handler(port[i].irq, mx3_gpio_irq_handler);
 			set_irq_data(port[i].irq, &port[i]);
@@ -382,7 +390,7 @@ int __init mxc_gpio_init(struct mxc_gpio_port *port, int cnt)
 			}
 		}
 	}
-
+	initialed = true;
 	if (cpu_is_mx2()) {
 		/* setup one handler for all GPIO interrupts */
 		set_irq_chained_handler(port[0].irq, mx2_gpio_irq_handler);
@@ -392,116 +400,6 @@ int __init mxc_gpio_init(struct mxc_gpio_port *port, int cnt)
 	return 0;
 }
 
-#define DEFINE_IMX_GPIO_PORT_IRQ_HIGH(soc, _id, _hwid, _irq, _irq_high)	\
-	{								\
-		.chip.label = "gpio-" #_id,				\
-		.irq = _irq,						\
-		.irq_high = _irq_high,					\
-		.base = soc ## _IO_ADDRESS(				\
-				soc ## _GPIO ## _hwid ## _BASE_ADDR),	\
-		.virtual_irq_start = MXC_GPIO_IRQ_START + (_id) * 32,	\
-	}
-
-#define DEFINE_IMX_GPIO_PORT_IRQ(soc, _id, _hwid, _irq)			\
-	DEFINE_IMX_GPIO_PORT_IRQ_HIGH(soc, _id, _hwid, _irq, 0)
-#define DEFINE_IMX_GPIO_PORT(soc, _id, _hwid)				\
-	DEFINE_IMX_GPIO_PORT_IRQ(soc, _id, _hwid, 0)
-
-#define DEFINE_REGISTER_FUNCTION(prefix)				\
-int __init prefix ## _register_gpios(void)				\
-{									\
-	return mxc_gpio_init(prefix ## _gpio_ports,			\
-			ARRAY_SIZE(prefix ## _gpio_ports));		\
-}
-
-#if defined(CONFIG_SOC_IMX1)
-static struct mxc_gpio_port imx1_gpio_ports[] = {
-	DEFINE_IMX_GPIO_PORT_IRQ(MX1, 0, 1, MX1_GPIO_INT_PORTA),
-	DEFINE_IMX_GPIO_PORT_IRQ(MX1, 1, 2, MX1_GPIO_INT_PORTB),
-	DEFINE_IMX_GPIO_PORT_IRQ(MX1, 2, 3, MX1_GPIO_INT_PORTC),
-	DEFINE_IMX_GPIO_PORT_IRQ(MX1, 3, 4, MX1_GPIO_INT_PORTD),
-};
-
-DEFINE_REGISTER_FUNCTION(imx1)
-
-#endif /* if defined(CONFIG_SOC_IMX1) */
-
-#if defined(CONFIG_SOC_IMX21)
-static struct mxc_gpio_port imx21_gpio_ports[] = {
-	DEFINE_IMX_GPIO_PORT_IRQ(MX21, 0, 1, MX21_INT_GPIO),
-	DEFINE_IMX_GPIO_PORT(MX21, 1, 2),
-	DEFINE_IMX_GPIO_PORT(MX21, 2, 3),
-	DEFINE_IMX_GPIO_PORT(MX21, 3, 4),
-	DEFINE_IMX_GPIO_PORT(MX21, 4, 5),
-	DEFINE_IMX_GPIO_PORT(MX21, 5, 6),
-};
-
-DEFINE_REGISTER_FUNCTION(imx21)
-
-#endif /* if defined(CONFIG_SOC_IMX21) */
-
-#if defined(CONFIG_SOC_IMX25)
-static struct mxc_gpio_port imx25_gpio_ports[] = {
-	DEFINE_IMX_GPIO_PORT_IRQ(MX25, 0, 1, MX25_INT_GPIO1),
-	DEFINE_IMX_GPIO_PORT_IRQ(MX25, 1, 2, MX25_INT_GPIO2),
-	DEFINE_IMX_GPIO_PORT_IRQ(MX25, 2, 3, MX25_INT_GPIO3),
-	DEFINE_IMX_GPIO_PORT_IRQ(MX25, 3, 4, MX25_INT_GPIO4),
-};
-
-DEFINE_REGISTER_FUNCTION(imx25)
-
-#endif /* if defined(CONFIG_SOC_IMX25) */
-
-#if defined(CONFIG_SOC_IMX27)
-static struct mxc_gpio_port imx27_gpio_ports[] = {
-	DEFINE_IMX_GPIO_PORT_IRQ(MX27, 0, 1, MX27_INT_GPIO),
-	DEFINE_IMX_GPIO_PORT(MX27, 1, 2),
-	DEFINE_IMX_GPIO_PORT(MX27, 2, 3),
-	DEFINE_IMX_GPIO_PORT(MX27, 3, 4),
-	DEFINE_IMX_GPIO_PORT(MX27, 4, 5),
-	DEFINE_IMX_GPIO_PORT(MX27, 5, 6),
-};
-
-DEFINE_REGISTER_FUNCTION(imx27)
-
-#endif /* if defined(CONFIG_SOC_IMX27) */
-
-#if defined(CONFIG_SOC_IMX31)
-static struct mxc_gpio_port imx31_gpio_ports[] = {
-	DEFINE_IMX_GPIO_PORT_IRQ(MX31, 0, 1, MX31_INT_GPIO1),
-	DEFINE_IMX_GPIO_PORT_IRQ(MX31, 1, 2, MX31_INT_GPIO2),
-	DEFINE_IMX_GPIO_PORT_IRQ(MX31, 2, 3, MX31_INT_GPIO3),
-};
-
-DEFINE_REGISTER_FUNCTION(imx31)
-
-#endif /* if defined(CONFIG_SOC_IMX31) */
-
-#if defined(CONFIG_SOC_IMX35)
-static struct mxc_gpio_port imx35_gpio_ports[] = {
-	DEFINE_IMX_GPIO_PORT_IRQ(MX35, 0, 1, MX35_INT_GPIO1),
-	DEFINE_IMX_GPIO_PORT_IRQ(MX35, 1, 2, MX35_INT_GPIO2),
-	DEFINE_IMX_GPIO_PORT_IRQ(MX35, 2, 3, MX35_INT_GPIO3),
-};
-
-DEFINE_REGISTER_FUNCTION(imx35)
-
-#endif /* if defined(CONFIG_SOC_IMX35) */
-
-#if defined(CONFIG_SOC_IMX50)
-static struct mxc_gpio_port imx50_gpio_ports[] = {
-	DEFINE_IMX_GPIO_PORT_IRQ_HIGH(MX50, 0, 1, MX50_INT_GPIO1_LOW, MX50_INT_GPIO1_HIGH),
-	DEFINE_IMX_GPIO_PORT_IRQ_HIGH(MX50, 1, 2, MX50_INT_GPIO2_LOW, MX50_INT_GPIO2_HIGH),
-	DEFINE_IMX_GPIO_PORT_IRQ_HIGH(MX50, 2, 3, MX50_INT_GPIO3_LOW, MX50_INT_GPIO3_HIGH),
-	DEFINE_IMX_GPIO_PORT_IRQ_HIGH(MX50, 3, 4, MX50_INT_GPIO3_LOW, MX50_INT_GPIO3_HIGH),
-	DEFINE_IMX_GPIO_PORT_IRQ_HIGH(MX50, 4, 5, MX50_INT_GPIO3_LOW, MX50_INT_GPIO3_HIGH),
-	DEFINE_IMX_GPIO_PORT_IRQ_HIGH(MX50, 5, 6, MX50_INT_GPIO3_LOW, MX50_INT_GPIO3_HIGH),
-};
-
-DEFINE_REGISTER_FUNCTION(imx50)
-
-#endif /* if defined(CONFIG_SOC_IMX50) */
-
 #if defined(CONFIG_IPIPE) && defined(__IPIPE_FEATURE_PIC_MUTE)
 extern void tzic_set_irq_prio(int irq, int hi);
 
diff --git a/arch/arm/plat-mxc/include/mach/common.h b/arch/arm/plat-mxc/include/mach/common.h
index 7d8cf14..c71174e 100644
--- a/arch/arm/plat-mxc/include/mach/common.h
+++ b/arch/arm/plat-mxc/include/mach/common.h
@@ -1,16 +1,25 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
  * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #ifndef __ASM_ARCH_MXC_COMMON_H__
 #define __ASM_ARCH_MXC_COMMON_H__
 
+struct fec_platform_data;
 struct platform_device;
 struct clk;
 
@@ -23,7 +32,18 @@ extern void mx35_map_io(void);
 extern void mx50_map_io(void);
 extern void mx51_map_io(void);
 extern void mx53_map_io(void);
+extern void mx6_map_io(void);
 extern void mxc91231_map_io(void);
+extern void imx1_init_early(void);
+extern void imx21_init_early(void);
+extern void imx25_init_early(void);
+extern void imx27_init_early(void);
+extern void imx31_init_early(void);
+extern void imx35_init_early(void);
+extern void imx50_init_early(void);
+extern void imx51_init_early(void);
+extern void imx53_init_early(void);
+extern void mxc91231_init_early(void);
 extern void mxc_init_irq(void __iomem *);
 extern void tzic_init_irq(void __iomem *);
 extern void mx1_init_irq(void);
@@ -35,6 +55,7 @@ extern void mx35_init_irq(void);
 extern void mx50_init_irq(void);
 extern void mx51_init_irq(void);
 extern void mx53_init_irq(void);
+extern void mx6_init_irq(void);
 extern void mxc91231_init_irq(void);
 extern void epit_timer_init(struct clk *timer_clk, void __iomem *base, int irq);
 extern void mxc_timer_init(struct clk *timer_clk, void __iomem *, unsigned long, int);
@@ -48,6 +69,11 @@ extern int mx51_clocks_init(unsigned long ckil, unsigned long osc,
 			unsigned long ckih1, unsigned long ckih2);
 extern int mx53_clocks_init(unsigned long ckil, unsigned long osc,
 			unsigned long ckih1, unsigned long ckih2);
+extern int mx50_clocks_init(unsigned long ckil, unsigned long osc,
+			unsigned long ckih1);
+extern int mx6_clocks_init(unsigned long ckil, unsigned long osc,
+			unsigned long ckih1, unsigned long ckih2);
+extern void imx6_init_fec(struct fec_platform_data fec_data);
 extern int mxc91231_clocks_init(unsigned long fref);
 extern int mxc_register_gpios(void);
 extern int mxc_register_device(struct platform_device *pdev, void *data);
@@ -58,6 +84,7 @@ extern void mxc91231_arch_reset(int, const char *);
 extern void mxc91231_prepare_idle(void);
 extern void mx51_efikamx_reset(void);
 extern int mx53_revision(void);
+extern int mx50_revision(void);
 
 #ifdef CONFIG_IPIPE
 void ipipe_mach_allow_hwtimer_uaccess(unsigned long aips1, unsigned long aips2);
diff --git a/arch/arm/plat-mxc/include/mach/irqs.h b/arch/arm/plat-mxc/include/mach/irqs.h
index ceac92a..02e24b9 100644
--- a/arch/arm/plat-mxc/include/mach/irqs.h
+++ b/arch/arm/plat-mxc/include/mach/irqs.h
@@ -83,6 +83,10 @@ extern int imx_irq_set_priority(unsigned char irq, unsigned char prio);
 /* switch between IRQ and FIQ */
 extern int mxc_set_irq_fiq(unsigned int irq, unsigned int type);
 
+#if defined(CONFIG_ARCH_MX6) && defined(CONFIG_SMP)
+#include <asm/smp_twd.h>
+#endif /* CONFIG_ARCH_OMAP4 */
+
 #ifdef CONFIG_MXC_TZIC
 #define __IPIPE_FEATURE_PIC_MUTE
 #endif /* CONFIG_MXC_TZIC */
diff --git a/arch/arm/plat-mxc/time.c b/arch/arm/plat-mxc/time.c
index bf92b87..3189076 100644
--- a/arch/arm/plat-mxc/time.c
+++ b/arch/arm/plat-mxc/time.c
@@ -69,7 +69,7 @@
 #define timer_is_v1()	(cpu_is_mx1() || cpu_is_mx21() || cpu_is_mx27())
 #define timer_is_v2()	(!timer_is_v1())
 
-#ifdef CONFIG_IPIPE
+#if defined(CONFIG_IPIPE) && !defined(CONFIG_SMP)
 int __ipipe_mach_timerint;
 EXPORT_SYMBOL(__ipipe_mach_timerint);
 
@@ -78,9 +78,7 @@ EXPORT_SYMBOL(__ipipe_mach_timerstolen);
 
 unsigned int __ipipe_mach_ticks_per_jiffy = LATCH;
 EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
-
-static unsigned mxc_min_delay;
-#endif /* CONFIG_IPIPE */
+#endif /* CONFIG_IPIPE && !SMP */
 
 static struct clock_event_device clockevent_mxc;
 static enum clock_event_mode clockevent_mode = CLOCK_EVT_MODE_UNUSED;
@@ -284,7 +282,7 @@ static irqreturn_t mxc_timer_interrupt(int irq, void *dev_id)
 	else
 		tstat = __raw_readl(timer_base + MX1_2_TSTAT);
 
-#ifndef CONFIG_IPIPE
+#if !defined(CONFIG_IPIPE) || defined(CONFIG_SMP)
 	gpt_irq_acknowledge();
 #else /* !CONFIG_IPIPE */
 	__ipipe_tsc_update();
@@ -331,7 +329,7 @@ static int __init mxc_clockevent_init(struct clk *timer_clk)
 	return 0;
 }
 
-#ifdef CONFIG_IPIPE
+#if defined(CONFIG_IPIPE) && !defined(CONFIG_SMP)
 static struct __ipipe_tscinfo tsc_info = {
 	.type = IPIPE_TSC_TYPE_FREERUNNING,
 	.u = {
@@ -356,7 +354,7 @@ void __ipipe_mach_acktimer(void)
 
 void __ipipe_mach_set_dec(unsigned long delay)
 {
-	if (delay > mxc_min_delay) {
+	if (delay > 0xff) {
 		unsigned long tcmp;
 
 		if (!timer_is_v2()) {
@@ -388,7 +386,7 @@ unsigned long __ipipe_mach_get_dec(void)
 		return __raw_readl(timer_base + V2_TCMP)
 			- __raw_readl(timer_base + V2_TCN);
 }
-#endif /* CONFIG_IPIPE */
+#endif /* CONFIG_IPIPE && !SMP */
 
 void __init
 mxc_timer_init(struct clk *timer_clk,
@@ -421,11 +419,10 @@ mxc_timer_init(struct clk *timer_clk,
 	/* Make irqs happen */
 	setup_irq(irq, &mxc_timer_irq);
 
-#ifdef CONFIG_IPIPE
+#if defined(CONFIG_IPIPE) && !defined(CONFIG_SMP)
 	__ipipe_mach_timerint = irq;
 	__ipipe_mach_ticks_per_jiffy = (clk_get_rate(timer_clk) + HZ/2) / HZ;
 	tsc_info.freq = clk_get_rate(timer_clk);
-	mxc_min_delay = ((__ipipe_cpu_freq + 500000) / 1000000) ?: 1;
 
 	if (timer_is_v1()) {
 		tsc_info.u.counter_paddr = phys + MX1_2_TCN;
@@ -435,5 +432,5 @@ mxc_timer_init(struct clk *timer_clk,
 		tsc_info.counter_vaddr = (unsigned long)(timer_base + V2_TCN);
 	}
 	__ipipe_tsc_register(&tsc_info);
-#endif /* CONFIG_IPIPE */
+#endif /* CONFIG_IPIPE && !SMP */
 }
