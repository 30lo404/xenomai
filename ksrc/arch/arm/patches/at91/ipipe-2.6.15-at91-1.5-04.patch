diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp linux-2.6.15.7-at91-ipipe-1.5-01-ref/arch/arm/mach-at91rm9200/Kconfig linux-2.6.15.7-at91-ipipe-1.5-01/arch/arm/mach-at91rm9200/Kconfig
--- linux-2.6.15.7-at91-ipipe-1.5-01-ref/arch/arm/mach-at91rm9200/Kconfig	2006-11-21 00:53:59.000000000 +0100
+++ linux-2.6.15.7-at91-ipipe-1.5-01/arch/arm/mach-at91rm9200/Kconfig	2007-01-01 20:55:59.000000000 +0100
@@ -55,4 +55,15 @@ config AT91_PROGRAMMABLE_CLOCKS
 	  Select this if you need to program one or more of the PCK0..PCK3
 	  programmable clock outputs.
 
+config IPIPE_AT91_MCK
+	depends on IPIPE
+	int "AT91 Master clock Frequency"
+	default 46080000
+	help
+	When Adeos interrupt pipeline is enabled, AT91 timer is based on
+	the AT91 master clock, whose frequency need hence to be known at
+	compilation time.
+
+endmenu
+
 endif
diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp linux-2.6.15.7-at91-ipipe-1.5-01-ref/arch/arm/mach-at91rm9200/gpio.c linux-2.6.15.7-at91-ipipe-1.5-01/arch/arm/mach-at91rm9200/gpio.c
--- linux-2.6.15.7-at91-ipipe-1.5-01-ref/arch/arm/mach-at91rm9200/gpio.c	2006-11-05 15:31:59.000000000 +0100
+++ linux-2.6.15.7-at91-ipipe-1.5-01/arch/arm/mach-at91rm9200/gpio.c	2007-01-01 20:55:59.000000000 +0100
@@ -18,6 +18,11 @@
 #include <asm/mach/irq.h>
 #include <asm/arch/hardware.h>
 #include <asm/arch/gpio.h>
+#ifdef CONFIG_IPIPE
+#include <asm/irq.h>
+
+unsigned __ipipe_at91_gpio_banks = 0;
+#endif /* CONFIG_IPIPE */
 
 static const u32 pio_controller_offset[4] = {
 	AT91_PIOA,
@@ -232,6 +237,9 @@ static int gpio_irq_type(unsigned pin, u
 }
 
 static struct irqchip gpio_irqchip = {
+#ifdef CONFIG_IPIPE
+	.ack            = gpio_irq_mask,
+#endif
 	.mask		= gpio_irq_mask,
 	.unmask		= gpio_irq_unmask,
 	.set_type	= gpio_irq_type,
@@ -268,6 +276,50 @@ static void gpio_irq_handler(unsigned ir
 	/* now it may re-trigger */
 }
 
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_demux_irq(unsigned irq, struct pt_regs *regs)
+{
+	struct irqdesc *desc = irq_desc + irq;
+	unsigned	pin;
+	struct irqdesc	*gpio;
+	void __iomem	*pio;
+	u32		isr;
+
+	pio = (void __force __iomem *) desc->chipdata;
+
+	/* temporarily mask (level sensitive) parent IRQ */
+	desc->chip->ack(irq);
+	for (;;) {
+		isr = __raw_readl(pio + PIO_ISR) & __raw_readl(pio + PIO_IMR);
+		if (!isr)
+			break;
+
+		pin = (unsigned) desc->data;
+		gpio = &irq_desc[pin];
+
+		while (isr) {
+			if (isr & 1) {
+				if (unlikely(gpio->disable_depth)) {
+					/*
+					 * The core ARM interrupt handler lazily disables IRQs so
+					 * another IRQ must be generated before it actually gets
+					 * here to be disabled on the GPIO controller.
+					 */
+					gpio->chip->mask(pin);
+				}
+				else
+					__ipipe_handle_irq(pin, regs);
+			}
+			pin++;
+			gpio++;
+			isr >>= 1;
+		}
+	}
+	desc->chip->unmask(irq);
+	/* now it may re-trigger */
+}
+#endif /* CONFIG_IPIPE */
+
 /* call this from board-specific init_irq */
 void __init at91_gpio_irq_setup(unsigned banks)
 {
@@ -299,4 +351,7 @@ void __init at91_gpio_irq_setup(unsigned
 		at91_sys_write(AT91_PMC_PCER, 1 << id);
 	}
 	pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, banks);
+#ifdef CONFIG_IPIPE
+	__ipipe_at91_gpio_banks = banks;
+#endif /* CONFIG_IPIPE */
 }
diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp linux-2.6.15.7-at91-ipipe-1.5-01-ref/arch/arm/mach-at91rm9200/irq.c linux-2.6.15.7-at91-ipipe-1.5-01/arch/arm/mach-at91rm9200/irq.c
--- linux-2.6.15.7-at91-ipipe-1.5-01-ref/arch/arm/mach-at91rm9200/irq.c	2007-01-01 23:23:53.721502705 +0100
+++ linux-2.6.15.7-at91-ipipe-1.5-01/arch/arm/mach-at91rm9200/irq.c	2007-01-01 23:23:19.830719107 +0100
@@ -41,6 +41,7 @@
  * The default interrupt priority levels (0 = lowest, 7 = highest).
  */
 static unsigned int at91rm9200_default_irq_priority[NR_AIC_IRQS] __initdata = {
+#ifndef CONFIG_IPIPE
 	7,	/* Advanced Interrupt Controller */
 	7,	/* System Peripheral */
 	0,	/* Parallel IO Controller A */
@@ -73,6 +74,42 @@ static unsigned int at91rm9200_default_i
 	0,	/* Advanced Interrupt Controller */
 	0,	/* Advanced Interrupt Controller */
 	0	/* Advanced Interrupt Controller */
+#else /* CONFIG_IPIPE */
+/* Give the highest priority to TC, since they are used as timer interrupt by
+   I-pipe. */
+	7,	/* Advanced Interrupt Controller */
+	6,	/* System Peripheral */
+	0,	/* Parallel IO Controller A */
+	0,	/* Parallel IO Controller B */
+	0,	/* Parallel IO Controller C */
+	0,	/* Parallel IO Controller D */
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
+	5,	/* USART 3 */
+	0,	/* Multimedia Card Interface */
+	3,	/* USB Device Port */
+	0,	/* Two-Wire Interface */
+	5,	/* Serial Peripheral Interface */
+	4,	/* Serial Synchronous Controller */
+	4,	/* Serial Synchronous Controller */
+	4,	/* Serial Synchronous Controller */
+	7,	/* Timer Counter 0 */
+	7,	/* Timer Counter 1 */
+	7,	/* Timer Counter 2 */
+	0,	/* Timer Counter 3 */
+	0,	/* Timer Counter 4 */
+	0,	/* Timer Counter 5 */
+	2,	/* USB Host port */
+	2,	/* Ethernet MAC */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0	/* Advanced Interrupt Controller */
+#endif /*CONFIG_IPIPE */
 };
 
 
diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp linux-2.6.15.7-at91-ipipe-1.5-01-ref/arch/arm/mach-at91rm9200/time.c linux-2.6.15.7-at91-ipipe-1.5-01/arch/arm/mach-at91rm9200/time.c
--- linux-2.6.15.7-at91-ipipe-1.5-01-ref/arch/arm/mach-at91rm9200/time.c	2006-11-05 15:31:59.000000000 +0100
+++ linux-2.6.15.7-at91-ipipe-1.5-01/arch/arm/mach-at91rm9200/time.c	2007-01-01 23:06:49.900877736 +0100
@@ -25,12 +25,69 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/time.h>
+#include <linux/delay.h>
 
 #include <asm/hardware.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/mach/time.h>
 
+#ifdef CONFIG_IPIPE
+#include <linux/module.h>
+#include <asm/arch/board.h>	/* for at91_master_clock */
+#include <asm/arch/at91rm9200_tc.h>
+
+#ifdef CONFIG_NO_IDLE_HZ
+#error "dynamic tick timer not yet supported with IPIPE"
+#endif /* CONFIG_NO_IDLE_HZ */
+
+#define KERNEL_TIMER 0
+#define TCNXCNS(timer,v) ((v) << ((timer)<<1))
+#define AT91_TC_REG_MASK (0xffff)
+
+#if (KERNEL_TIMER==0)
+#   define KERNEL_TIMER_IRQ_NUM AT91_ID_TC0
+#elif (KERNEL_TIMER==1)
+#   define KERNEL_TIMER_IRQ_NUM AT91_ID_TC1
+#elif (KERNEL_TIMER==2)
+#   define KERNEL_TIMER_IRQ_NUM AT91_ID_TC2
+#else
+#error Weird -- KERNEL_TIMER is not defined or something....
+#endif
+
+static inline unsigned int at91_tc_read(unsigned int reg_offset)
+{
+	void __iomem *addr =
+		(void __iomem *)AT91_VA_BASE_TCB0 + 0x40 * KERNEL_TIMER;
+
+	return readl(addr + reg_offset);
+}
+
+static inline void at91_tc_write(unsigned int reg_offset, unsigned long value)
+{
+	void __iomem *addr =
+		(void __iomem *)AT91_VA_BASE_TCB0 + 0x40 * KERNEL_TIMER;
+
+	writel(value, addr + reg_offset);
+}
+
+#define read_CV() at91_tc_read(AT91_TC_CV)
+#define read_RC() at91_tc_read(AT91_TC_RC)
+#define write_RC(value) at91_tc_write(AT91_TC_RC, value)
+
+int __ipipe_mach_timerint = KERNEL_TIMER_IRQ_NUM;
+EXPORT_SYMBOL(__ipipe_mach_timerint);
+
+int __ipipe_mach_timerstolen = 0;
+EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+
+unsigned int __ipipe_mach_ticks_per_jiffy = LATCH;
+EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+
+static int at91_timer_initialized;
+static unsigned long last_jiffy_time;
+#endif /* CONFIG_IPIPE */
+
 /*
  * The ST_CRTR is updated asynchronously to the master clock.  It is therefore
  *  necessary to read it twice (with the same value) to ensure accuracy.
@@ -38,14 +95,16 @@
 static inline unsigned long read_CRTR(void) {
 	unsigned long x1, x2;
 
+	x2 = at91_sys_read(AT91_ST_CRTR);
 	do {
-		x1 = at91_sys_read(AT91_ST_CRTR);
+		x1 = x2;
 		x2 = at91_sys_read(AT91_ST_CRTR);
 	} while (x1 != x2);
 
 	return x1;
 }
 
+#ifndef CONFIG_IPIPE
 /*
  * Returns number of microseconds since last timer interrupt.  Note that interrupts
  * will have been disabled by do_gettimeofday()
@@ -85,9 +144,135 @@ static irqreturn_t at91rm9200_timer_inte
 		return IRQ_NONE;		/* not handled */
 }
 
+#else /* CONFIG_IPIPE */
+
+/*
+ * Returns number of microseconds since last timer interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeofday()
+ *  'LATCH' is hwclock ticks (see CLOCK_TICK_RATE in timex.h) per jiffy.
+ *  'tick' is usecs per jiffy (linux/timex.h).
+ */
+static unsigned long at91rm9200_gettimeoffset(void)
+{
+	unsigned long elapsed;
+
+	elapsed = (read_CV() - last_jiffy_time) & AT91_TC_REG_MASK;
+
+	return (unsigned long) (elapsed * (tick_nsec / 1000)) / LATCH;
+}
+
+void __ipipe_mach_acktimer(void)
+{
+	at91_tc_read(AT91_TC_SR);
+}
+
+/*
+ * IRQ handler for the timer.
+ */
+static irqreturn_t at91rm9200_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/*
+	 * - if Linux is running under ipipe, but it still has the control over
+	 *   the timer (no Xenomai for example), then reprogram the timer (ipipe
+	 *   has already acked it)
+	 * - if some other domain has taken over the timer, then do nothing
+	 *   (ipipe has acked it, and the other domain has reprogramed it)
+	 */
+
+	write_seqlock(&xtime_lock);
+
+	if (__ipipe_mach_timerstolen) {
+		timer_tick(regs);
+		last_jiffy_time = (last_jiffy_time + LATCH) & AT91_TC_REG_MASK;
+	} else {
+		while (((read_CV() - last_jiffy_time) & AT91_TC_REG_MASK) >= LATCH) {
+			timer_tick(regs);
+			last_jiffy_time = (last_jiffy_time + LATCH) & AT91_TC_REG_MASK;
+		}
+		write_RC((last_jiffy_time + LATCH) & AT91_TC_REG_MASK);
+	}
+
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+notrace unsigned long long __ipipe_mach_get_tsc(void)
+{
+	if (likely(at91_timer_initialized)) {
+		static union {
+#ifdef __BIG_ENDIAN
+			struct {
+				unsigned long high;
+				unsigned short mid;
+				unsigned short low;
+			};
+#else /* __LITTLE_ENDIAN */
+			struct {
+				unsigned short low;
+				unsigned short mid;
+				unsigned long high;
+			};
+#endif /* __LITTLE_ENDIAN */
+			unsigned long long full;
+		} tsc[NR_CPUS], *local_tsc;
+		unsigned long long result;
+		unsigned short stamp;
+		unsigned long flags;
+
+		local_irq_save_hw(flags);
+		local_tsc = &tsc[ipipe_processor_id()];
+		stamp = read_CV();
+		if (unlikely(stamp < local_tsc->low)) {
+			if (unlikely(!++local_tsc->mid))
+				/* 32 bit counter wrapped, increment high word. */
+				local_tsc->high++;
+		}
+		local_tsc->low = stamp;
+		result = local_tsc->full;
+		local_irq_restore_hw(flags);
+
+		return result;
+	}
+	
+        return 0;
+}
+EXPORT_SYMBOL(__ipipe_mach_get_tsc);
+
+/*
+ * Reprogram the timer
+ */
+
+void __ipipe_mach_set_dec(unsigned long delay)
+{
+	unsigned long flags;
+
+	local_irq_save_hw(flags);
+	write_RC((read_CV() + delay) & AT91_TC_REG_MASK);
+	local_irq_restore_hw(flags);
+}
+EXPORT_SYMBOL(__ipipe_mach_set_dec);
+
+void __ipipe_mach_release_timer(void)
+{
+       __ipipe_mach_set_dec(__ipipe_mach_ticks_per_jiffy);
+}
+EXPORT_SYMBOL(__ipipe_mach_release_timer);
+
+unsigned long __ipipe_mach_get_dec(void)
+{
+	return (read_RC() - read_CV()) & AT91_TC_REG_MASK;
+}
+
+#endif /* CONFIG_IPIPE */
+
 static struct irqaction at91rm9200_timer_irq = {
 	.name		= "at91_tick",
+#ifndef CONFIG_IPIPE
 	.flags		= SA_SHIRQ | SA_INTERRUPT,
+#else /* !CONFIG_IPIPE */
+	.flags		= SA_INTERRUPT,
+#endif /* !CONFIG_IPIPE */
 	.handler	= at91rm9200_timer_interrupt
 };
 
@@ -96,6 +281,7 @@ static struct irqaction at91rm9200_timer
  */
 void __init at91rm9200_timer_init(void)
 {
+#ifndef CONFIG_IPIPE
 	/* Disable all timer interrupts */
 	at91_sys_write(AT91_ST_IDR, AT91_ST_PITS | AT91_ST_WDOVF | AT91_ST_RTTINC | AT91_ST_ALMS);
 	(void) at91_sys_read(AT91_ST_SR);	/* Clear any pending interrupts */
@@ -119,6 +305,49 @@ void __init at91rm9200_timer_init(void)
 
 	/* Enable Period Interval Timer interrupt */
 	at91_sys_write(AT91_ST_IER, AT91_ST_PITS);
+#else /* CONFIG_IPIPE */
+	unsigned long v;
+
+	if (at91_master_clock != CONFIG_IPIPE_AT91_MCK)
+		panic("Please recompile the kernel with IPIPE_AT91_MCK"
+		      " set to %lu Hz\n", at91_master_clock);
+
+	/* FIXME: there may well be a cleaner way to do this. */
+	at91_sys_write(AT91_PMC_PCER, 1 << (KERNEL_TIMER + 6));
+
+	/* No Sync. */
+	at91_tc_write(AT91_TC_BCR, 0);
+
+	/* program NO signal on XCN */
+	v = readl((void __iomem *) AT91_VA_BASE_TCB0 + AT91_TC_BMR);
+	v &= ~TCNXCNS(KERNEL_TIMER, 3);
+	v |= TCNXCNS(KERNEL_TIMER, 1); /* AT91_TC_TCNXCNS_NONE */
+	writel(v, (void __iomem *) AT91_VA_BASE_TCB0 + AT91_TC_BMR);
+
+	/* Disable the channel */
+	at91_tc_write(AT91_TC_CCR, AT91_TC_CLKDIS);
+
+	/* Select TIMER_CLOCK3 (MCLK/32) as input frequency for TC. */
+	at91_tc_write(AT91_TC_CMR, AT91_TC_TIMER_CLOCK3);
+
+	/* Disable all interrupts. */
+	at91_tc_write(AT91_TC_IDR, ~0ul);
+
+	/* Load the TC register C. */
+	last_jiffy_time = 0;
+	write_RC(LATCH);
+
+	/* Enable CPCS interrupt. */
+	at91_tc_write(AT91_TC_IER, AT91_TC_CPCS);
+
+	/* Set up the interrupt. */
+	setup_irq(KERNEL_TIMER_IRQ_NUM, &at91rm9200_timer_irq);
+
+	/* Enable the channel. */
+	at91_tc_write(AT91_TC_CCR, AT91_TC_CLKEN | AT91_TC_SWTRG);
+
+	at91_timer_initialized = 1;
+#endif /* CONFIG_IPIPE */
 }
 
 struct sys_timer at91rm9200_timer = {
diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp linux-2.6.15.7-at91-ipipe-1.5-01-ref/include/asm-arm/arch-at91rm9200/irqs.h linux-2.6.15.7-at91-ipipe-1.5-01/include/asm-arm/arch-at91rm9200/irqs.h
--- linux-2.6.15.7-at91-ipipe-1.5-01-ref/include/asm-arm/arch-at91rm9200/irqs.h	2006-11-05 15:31:59.000000000 +0100
+++ linux-2.6.15.7-at91-ipipe-1.5-01/include/asm-arm/arch-at91rm9200/irqs.h	2007-01-01 20:55:59.000000000 +0100
@@ -49,4 +49,12 @@
 extern void at91rm9200_init_irq(unsigned int priority[]);
 #endif
 
+#if defined(CONFIG_IPIPE) && !defined(__ASSEMBLY__)
+extern unsigned __ipipe_at91_gpio_banks;
+
+#define __ipipe_mach_irq_mux_p(irq) \
+	((unsigned) (irq - AT91_ID_PIOA) < __ipipe_at91_gpio_banks)
+
+#endif /* CONFIG_IPIPE && !__ASSEMBLY__ */
+
 #endif
diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp linux-2.6.15.7-at91-ipipe-1.5-01-ref/include/asm-arm/arch-at91rm9200/timex.h linux-2.6.15.7-at91-ipipe-1.5-01/include/asm-arm/arch-at91rm9200/timex.h
--- linux-2.6.15.7-at91-ipipe-1.5-01-ref/include/asm-arm/arch-at91rm9200/timex.h	2006-11-05 15:31:59.000000000 +0100
+++ linux-2.6.15.7-at91-ipipe-1.5-01/include/asm-arm/arch-at91rm9200/timex.h	2007-01-01 22:45:09.771628731 +0100
@@ -23,6 +23,10 @@
 
 #include <asm/arch/hardware.h>
 
+#ifndef CONFIG_IPIPE
 #define CLOCK_TICK_RATE		(AT91_SLOW_CLOCK)
+#else /* !CONFIG_IPIPE */
+#define CLOCK_TICK_RATE         (CONFIG_IPIPE_AT91_MCK / 32)
+#endif /* !CONFIG_IPIPE */
 
 #endif
